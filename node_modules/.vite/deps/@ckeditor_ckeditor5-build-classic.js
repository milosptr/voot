import {
  __commonJS
} from "./chunk-OL3AADLO.js";

// node_modules/@ckeditor/ckeditor5-build-classic/build/ckeditor.js
var require_ckeditor = __commonJS({
  "node_modules/@ckeditor/ckeditor5-build-classic/build/ckeditor.js"(exports, module) {
    !function(t) {
      const e = t.en = t.en || {};
      e.dictionary = Object.assign(e.dictionary || {}, { "%0 of %1": "%0 of %1", Aquamarine: "Aquamarine", Black: "Black", "Block quote": "Block quote", Blue: "Blue", Bold: "Bold", "Break text": "Break text", "Bulleted List": "Bulleted List", Cancel: "Cancel", "Cannot upload file:": "Cannot upload file:", "Centered image": "Centered image", "Change image text alternative": "Change image text alternative", "Choose heading": "Choose heading", Column: "Column", "Could not insert image at the current position.": "Could not insert image at the current position.", "Could not obtain resized image URL.": "Could not obtain resized image URL.", "Decrease indent": "Decrease indent", "Delete column": "Delete column", "Delete row": "Delete row", "Dim grey": "Dim grey", Downloadable: "Downloadable", "Dropdown toolbar": "Dropdown toolbar", "Edit block": "Edit block", "Edit link": "Edit link", "Editor toolbar": "Editor toolbar", "Enter image caption": "Enter image caption", "Full size image": "Full size image", Green: "Green", Grey: "Grey", "Header column": "Header column", "Header row": "Header row", Heading: "Heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", "Image toolbar": "Image toolbar", "image widget": "image widget", "In line": "In line", "Increase indent": "Increase indent", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Insert image": "Insert image", "Insert image or file": "Insert image or file", "Insert media": "Insert media", "Insert paragraph after block": "Insert paragraph after block", "Insert paragraph before block": "Insert paragraph before block", "Insert row above": "Insert row above", "Insert row below": "Insert row below", "Insert table": "Insert table", "Inserting image failed": "Inserting image failed", Italic: "Italic", "Left aligned image": "Left aligned image", "Light blue": "Light blue", "Light green": "Light green", "Light grey": "Light grey", Link: "Link", "Link URL": "Link URL", "Media URL": "Media URL", "media widget": "media widget", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Merge cell right": "Merge cell right", "Merge cell up": "Merge cell up", "Merge cells": "Merge cells", Next: "Next", "Numbered List": "Numbered List", "Open in a new tab": "Open in a new tab", "Open link in new tab": "Open link in new tab", Orange: "Orange", Paragraph: "Paragraph", "Paste the media URL in the input.": "Paste the media URL in the input.", Previous: "Previous", Purple: "Purple", Red: "Red", Redo: "Redo", "Rich Text Editor": "Rich Text Editor", "Rich Text Editor, %0": "Rich Text Editor, %0", "Right aligned image": "Right aligned image", Row: "Row", Save: "Save", "Select all": "Select all", "Select column": "Select column", "Select row": "Select row", "Selecting resized image failed": "Selecting resized image failed", "Show more items": "Show more items", "Side image": "Side image", "Split cell horizontally": "Split cell horizontally", "Split cell vertically": "Split cell vertically", "Table toolbar": "Table toolbar", "Text alternative": "Text alternative", "The URL must not be empty.": "The URL must not be empty.", "This link has no URL": "This link has no URL", "This media URL is not supported.": "This media URL is not supported.", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", "Toggle caption off": "Toggle caption off", "Toggle caption on": "Toggle caption on", Turquoise: "Turquoise", Undo: "Undo", Unlink: "Unlink", "Upload failed": "Upload failed", "Upload in progress": "Upload in progress", White: "White", "Widget toolbar": "Widget toolbar", "Wrap text": "Wrap text", Yellow: "Yellow" });
    }(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.ClassicEditor = e() : t.ClassicEditor = e();
    }(self, function() {
      return (() => {
        "use strict";
        var t = { 3062: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAEC,eAAgB,CAGhB,mBAAoB,CACpB,kBAAmB,CAEnB,aAAc,CACd,cAAe,CACf,iBAAkB,CAClB,0BACD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: ['/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n	/* See #12 */\n	overflow: hidden;\n\n	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n	padding-right: 1.5em;\n	padding-left: 1.5em;\n\n	margin-left: 0;\n	margin-right: 0;\n	font-style: italic;\n	border-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n	border-left: 0;\n	border-right: solid 5px hsl(0, 0%, 80%);\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 903: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;position:relative;pointer-events:none}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);border:1px solid var(--ck-clipboard-drop-target-color);background:var(--ck-clipboard-drop-target-color);margin-left:-1px}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{content:"";width:0;height:0;display:block;position:absolute;left:50%;top:calc(var(--ck-clipboard-drop-target-dot-height)*-0.5);transform:translateX(-50%);border-left:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-bottom:0 solid transparent;border-right:calc(var(--ck-clipboard-drop-target-dot-width)*0.5) solid transparent;border-top:calc(var(--ck-clipboard-drop-target-dot-height)) solid var(--ck-clipboard-drop-target-color)}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}', "", { version: 3, sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CACf,iBAAkB,CAClB,mBAMD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEACC,4DAA8D,CAC9D,yDAA2D,CAC3D,sDAAuD,CACvD,gDAAiD,CACjD,gBAkBD,CAfC,yEACC,UAAW,CACX,OAAQ,CACR,QAAS,CAET,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,yDAA2D,CAE3D,0BAA2B,CAG3B,iFAAmB,CAAnB,iCAAmB,CAAnB,kFAAmB,CAAnB,uGACD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	/*\n	 * Vertical drop target (in text).\n	 */\n	& .ck.ck-clipboard-drop-target-position {\n		display: inline;\n		position: relative;\n		pointer-events: none;\n\n		& span {\n			position: absolute;\n			width: 0;\n		}\n	}\n\n	/*\n	 * Styles of the widget being dragged (its preview).\n	 */\n	& .ck-widget:-webkit-drag {\n		& > .ck-widget__selection-handle {\n			display: none;\n		}\n\n		& > .ck-widget__type-around {\n			display: none;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-clipboard-drop-target-dot-width: 12px;\n	--ck-clipboard-drop-target-dot-height: 8px;\n	--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n	/*\n	 * Vertical drop target (in text).\n	 */\n	& .ck.ck-clipboard-drop-target-position {\n		& span {\n			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n			border: 1px solid var(--ck-clipboard-drop-target-color);\n			background: var(--ck-clipboard-drop-target-color);\n			margin-left: -1px;\n\n			/* The triangle above the marker */\n			&::after {\n				content: "";\n				width: 0;\n				height: 0;\n\n				display: block;\n				position: absolute;\n				left: 50%;\n				top: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n				transform: translateX(-50%);\n				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n				border-style: solid;\n			}\n		}\n	}\n\n	/*\n	// Horizontal drop target (between blocks).\n	& .ck.ck-clipboard-drop-target-position {\n		display: block;\n		position: relative;\n		width: 100%;\n		height: 0;\n		margin: 0;\n		text-align: initial;\n\n		& .ck-clipboard-drop-target__line {\n			position: absolute;\n			width: 100%;\n			height: 0;\n			border: 1px solid var(--ck-clipboard-drop-target-color);\n			margin-top: -1px;\n\n			&::before {\n				content: "";\n				width: 0;\n				height: 0;\n\n				display: block;\n				position: absolute;\n				left: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n				top: 0;\n\n				transform: translateY(-50%);\n				border-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n				border-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n				border-style: solid;\n			}\n\n			&::after {\n				content: "";\n				width: 0;\n				height: 0;\n\n				display: block;\n				position: absolute;\n				right: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n				top: 0;\n\n				transform: translateY(-50%);\n				border-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n				border-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n				border-style: solid;\n			}\n		}\n	}\n	*/\n\n	/*\n	 * Styles of the widget that it a drop target.\n	 */\n	& .ck-widget.ck-clipboard-drop-target-range {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n	}\n\n	/*\n	 * Styles of the widget being dragged (its preview).\n	 */\n	& .ck-widget:-webkit-drag {\n		zoom: 0.6;\n		outline: none !important;\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 3143: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n	/* All the elements within `.ck-editor` are positioned relatively to it.\n	 If any element needs to be positioned with respect to the <body>, etc.,\n	 it must land outside of the `.ck-editor` in DOM. */\n	position: relative;\n\n	& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n		z-index: var(--ck-z-modal);\n	}\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 4717: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-placeholder,.ck .ck-placeholder{position:relative}.ck.ck-placeholder:before,.ck .ck-placeholder:before{position:absolute;left:0;right:0;content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDACC,iBAAkB,CAClB,MAAO,CACP,OAAQ,CACR,8BAA+B,CAG/B,mBACD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDACC,WAAY,CACZ,6CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n	position: relative;\n\n	&::before {\n		position: absolute;\n		left: 0;\n		right: 0;\n		content: attr(data-placeholder);\n\n		/* See ckeditor/ckeditor5#469. */\n		pointer-events: none;\n	}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n	&::before {\n		display: none;\n	}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n	position: relative;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n	&::before {\n		cursor: text;\n		color: var(--ck-color-engine-placeholder-text);\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 9315: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n	display: none;\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 8733: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n	font-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n	font-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n	font-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n	font-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n	& .ck-dropdown__button .ck-button__label {\n		width: 8em;\n	}\n\n	& .ck-dropdown__panel .ck-list__item {\n		min-width: 18em;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 3508: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck-content .image{display:table;clear:both;text-align:center;margin:.9em auto;min-width:50px}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{display:inline-flex;max-width:100%;align-items:flex-start}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{padding-left:inherit;padding-right:inherit;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBACC,aAAc,CACd,UAAW,CACX,iBAAkB,CAKlB,gBAAkB,CAGlB,cAeD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAMC,mBAAoB,CAGpB,cAAe,CAGf,sBAiBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEACC,oBAAqB,CACrB,qBAAsB,CAMtB,kBAAmB,CACnB,eAAgB,CAChB,sBACD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n	& .image {\n		display: table;\n		clear: both;\n		text-align: center;\n\n		/* Make sure there is some space between the content and the image. Center image by default. */\n		/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n		margin: 0.9em auto;\n\n		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n		min-width: 50px;\n\n		& img {\n			/* Prevent unnecessary margins caused by line-height (see #44). */\n			display: block;\n\n			/* Center the image if its width is smaller than the content\'s width. */\n			margin: 0 auto;\n\n			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n			max-width: 100%;\n\n			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n			min-width: 100%\n		}\n	}\n\n	& .image-inline {\n		/*\n		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n		 * This strange behavior does not happen with inline-flex.\n		 */\n		display: inline-flex;\n\n		/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n		max-width: 100%;\n\n		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n		align-items: flex-start;\n\n		/* When the picture is present it must act as a flex container to let the img resize properly */\n		& picture {\n			display: flex;\n		}\n\n		/* When the picture is present, it must act like a resizable img. */\n		& picture,\n		& img {\n			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n			flex-grow: 1;\n			flex-shrink: 1;\n\n			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n			max-width: 100%;\n		}\n	}\n}\n\n.ck.ck-editor__editable {\n	/*\n	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n	 * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n	 * caret does, and not at the edge of <figcaption>.\n	 */\n	& .image > figcaption.ck-placeholder::before {\n		padding-left: inherit;\n		padding-right: inherit;\n\n		/*\n		 * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9162.\n		 */\n		white-space: nowrap;\n		overflow: hidden;\n		text-overflow: ellipsis;\n	}\n\n\n	/*\n	 * Make sure the selected inline image always stays on top of its siblings.\n	 * See https://github.com/ckeditor/ckeditor5/issues/9108.\n	 */\n	& .image.ck-widget_selected {\n		z-index: 1;\n	}\n\n	& .image-inline.ck-widget_selected {\n		z-index: 1;\n\n		/*\n		 * Make sure the native browser selection style is not displayed.\n		 * Inline image widgets have their own styles for the selected state and\n		 * leaving this up to the browser is asking for a visual collision.\n		 */\n		& ::selection {\n			display: none;\n		}\n	}\n\n	/* The inline image nested in the table should have its original size if not resized.\n	See https://github.com/ckeditor/ckeditor5/issues/9117. */\n	& td,\n	& th {\n		& .image-inline img {\n			max-width: none;\n		}\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 2640: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:var(--ck-color-image-caption-text);background-color:var(--ck-color-image-caption-background);padding:.6em;font-size:.75em;outline-offset:-1px}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BACC,qBAAsB,CACtB,mBAAoB,CACpB,qBAAsB,CACtB,wCAAyC,CACzC,yDAA0D,CAC1D,YAAa,CACb,eAAgB,CAChB,mBACD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-image-caption-background: hsl(0, 0%, 97%);\n	--ck-color-image-caption-text: hsl(0, 0%, 20%);\n	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n	display: table-caption;\n	caption-side: bottom;\n	word-break: break-word;\n	color: var(--ck-color-image-caption-text);\n	background-color: var(--ck-color-image-caption-background);\n	padding: .6em;\n	font-size: .75em;\n	outline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n	animation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n	0% {\n		background-color: var(--ck-color-image-caption-highligted-background);\n	}\n\n	100% {\n		background-color: var(--ck-color-image-caption-background);\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 5083: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-right:0;margin-left:auto}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-top:var(--ck-inline-image-style-spacing);margin-bottom:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CACC,cAAe,CACf,gBACD,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAEC,+CAAgD,CAChD,kDACD,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-image-style-spacing: 1.5em;\n	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n	confirming successful application of the style if image width exceeds the editor's size.\n	See https://github.com/ckeditor/ckeditor5/issues/9342 */\n	& .image-style-block-align-left,\n	& .image-style-block-align-right {\n		max-width: calc(100% - var(--ck-image-style-spacing));\n	}\n\n	/* Allows displaying multiple floating images in the same line.\n	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n	& .image-style-align-left,\n	& .image-style-align-right {\n		clear: none;\n	}\n\n	& .image-style-side {\n		float: right;\n		margin-left: var(--ck-image-style-spacing);\n		max-width: 50%;\n	}\n\n	& .image-style-align-left {\n		float: left;\n		margin-right: var(--ck-image-style-spacing);\n	}\n\n	& .image-style-align-center {\n		margin-left: auto;\n		margin-right: auto;\n	}\n\n	& .image-style-align-right {\n		float: right;\n		margin-left: var(--ck-image-style-spacing);\n	}\n\n	& .image-style-block-align-right {\n		margin-right: 0;\n		margin-left: auto;\n	}\n\n	& .image-style-block-align-left {\n		margin-left: 0;\n		margin-right: auto;\n	}\n\n	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n	& p + .image-style-align-left,\n	& p + .image-style-align-right,\n	& p + .image-style-side {\n		margin-top: 0;\n	}\n\n	& .image-inline {\n		&.image-style-align-left,\n		&.image-style-align-right {\n			margin-top: var(--ck-inline-image-style-spacing);\n			margin-bottom: var(--ck-inline-image-style-spacing);\n		}\n\n		&.image-style-align-left {\n			margin-right: var(--ck-inline-image-style-spacing);\n		}\n\n		&.image-style-align-right {\n			margin-left: var(--ck-inline-image-style-spacing);\n		}\n	}\n}\n\n.ck.ck-splitbutton {\n	/* The button should display as a regular drop-down if the action button\n	is forced to fire the same action as the arrow button. */\n	&.ck-splitbutton_flatten {\n		&:hover,\n		&.ck-splitbutton_open {\n			& > .ck-splitbutton__action:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n				background-color: var(--ck-color-button-on-background);\n\n				&::after {\n					display: none;\n				}\n			}\n		}\n\n		&.ck-splitbutton_open:hover {\n			& > .ck-splitbutton__action:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n				background-color: var(--ck-color-button-on-hover-background);\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 4036: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck-image-upload-complete-icon{display:block;position:absolute;top:min(var(--ck-spacing-medium),6%);right:min(var(--ck-spacing-medium),6%);border-radius:50%;z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:calc(1px*var(--ck-image-upload-icon-size));animation-delay:0ms,3s;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BACC,aAAc,CACd,iBAAkB,CAMlB,oCAAsC,CACtC,sCAAwC,CACxC,iBAAkB,CAClB,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BACC,SAAU,CACV,uDAAwD,CACxD,wEAA0E,CAC1E,qCAAuC,CACvC,0BAAgC,CAGhC,oDAAuD,CAGvD,sBAA4B,CAM5B,eAAgB,CAChB,mFAAsF,CACtF,oFAyBD,CAtBC,qCAEC,QAAS,CAET,OAAQ,CACR,SAAU,CACV,QAAS,CACT,OAAQ,CAER,mCAAoC,CACpC,yBAA0B,CAC1B,oFAAqF,CACrF,sFAAuF,CAEvF,4CAA6C,CAC7C,sBAAyB,CACzB,mBAAsB,CACtB,4BAA6B,CAG7B,qBACD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GACC,SAAU,CACV,OAAQ,CACR,QACD,CACA,IACC,UAAY,CACZ,QACD,CACA,GACC,SAAU,CACV,UAAY,CACZ,YACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n	display: block;\n	position: absolute;\n\n	/*\n	 * Smaller images should have the icon closer to the border.\n	 * Match the icon position with the linked image indicator brought by the link image feature.\n	 */\n	top: min(var(--ck-spacing-medium), 6%);\n	right: min(var(--ck-spacing-medium), 6%);\n	border-radius: 50%;\n	z-index: 1;\n\n	&::after {\n		content: "";\n		position: absolute;\n	}\n}\n', '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n	/* Match the icon size with the linked image indicator brought by the link image feature. */\n	--ck-image-upload-icon-size: 20;\n	--ck-image-upload-icon-width: 2px;\n	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n	opacity: 0;\n	background: var(--ck-color-image-upload-icon-background);\n	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n	animation-fill-mode: forwards, forwards;\n	animation-duration: 500ms, 500ms;\n\n	/* To make animation scalable. */\n	font-size: calc(1px * var(--ck-image-upload-icon-size));\n\n	/* Hide completed upload icon after 3 seconds. */\n	animation-delay: 0ms, 3000ms;\n\n	/*\n	 * Use CSS math to simulate container queries.\n	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n	 */\n	overflow: hidden;\n	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n	/* This is check icon element made from border-width mixed with animations. */\n	&::after {\n		/* Because of border transformation we need to "hard code" left position. */\n		left: 25%;\n\n		top: 50%;\n		opacity: 0;\n		height: 0;\n		width: 0;\n\n		transform: scaleX(-1) rotate(135deg);\n		transform-origin: left top;\n		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n		animation-name: ck-upload-complete-icon-check;\n		animation-duration: 500ms;\n		animation-delay: 500ms;\n		animation-fill-mode: forwards;\n\n		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n		box-sizing: border-box;\n	}\n}\n\n@keyframes ck-upload-complete-icon-show {\n	from {\n		opacity: 0;\n	}\n\n	to {\n		opacity: 1;\n	}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n	from {\n		opacity: 1;\n	}\n\n	to {\n		opacity: 0;\n	}\n}\n\n@keyframes ck-upload-complete-icon-check {\n	0% {\n		opacity: 1;\n		width: 0;\n		height: 0;\n	}\n	33% {\n		width: 0.3em;\n		height: 0;\n	}\n	100% {\n		opacity: 1;\n		width: 0.3em;\n		height: 0.45em;\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 3773: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCACC,iBAAkB,CAClB,YAAa,CACb,kBAAmB,CACnB,sBAAuB,CACvB,KAAM,CACN,MAMD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAEC,UAAW,CACX,QAeD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCACC,UAAW,CACX,WAUD,CARC,yCACC,8CAA+C,CAC/C,+CAAgD,CAChD,iBAAkB,CAClB,8DAA+D,CAC/D,kCAAmC,CACnC,yDACD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n	position: absolute;\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	top: 0;\n	left: 0;\n\n	&::before {\n		content: '';\n		position: relative;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n	--ck-upload-placeholder-loader-size: 32px;\n	--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n	/* We need to control the full width of the SVG gray background. */\n	width: 100%;\n	margin: 0;\n\n	&.image-inline {\n		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n	}\n\n	& img {\n		/*\n		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n		 * There's nothing special about this number except that it should make the image placeholder look like\n		 * a real image during this short period after the upload started and before the image was read from the\n		 * file system (and a rich preview was loaded).\n		 */\n		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n	}\n}\n\n.ck .ck-upload-placeholder-loader {\n	width: 100%;\n	height: 100%;\n\n	&::before {\n		width: var(--ck-upload-placeholder-loader-size);\n		height: var(--ck-upload-placeholder-loader-size);\n		border-radius: 50%;\n		border-top: 3px solid var(--ck-color-upload-placeholder-loader);\n		border-right: 2px solid transparent;\n		animation: ck-upload-placeholder-loader 1s linear infinite;\n	}\n}\n\n@keyframes ck-upload-placeholder-loader {\n	to {\n		transform: rotate( 360deg );\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 3689: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image-inline .ck-progress-bar,.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image-inline .ck-progress-bar,.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAEC,iBAAkB,CAClB,KAAM,CACN,MACD,CCRC,yFACC,oBACD,CAID,uGAEC,UAAW,CACX,OAAQ,CACR,gDAAiD,CACjD,oBACD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& .image,\n	& .image-inline {\n		position: relative;\n	}\n\n	/* Upload progress bar. */\n	& .image .ck-progress-bar,\n	& .image-inline .ck-progress-bar {\n		position: absolute;\n		top: 0;\n		left: 0;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& .image,\n	& .image-inline {\n		/* Showing animation. */\n		&.ck-appear {\n			animation: fadeIn 700ms;\n		}\n	}\n\n	/* Upload progress bar. */\n	& .image .ck-progress-bar,\n	& .image-inline .ck-progress-bar {\n		height: 2px;\n		width: 0;\n		background: var(--ck-color-upload-bar-background);\n		transition: width 100ms;\n	}\n}\n\n@keyframes fadeIn {\n	from { opacity: 0; }\n	to   { opacity: 1; }\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 1905: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-labeled-field-view {\n		display: inline-block;\n	}\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 9773: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCACC,WAAY,CACZ,gDAAiD,CACjD,iBAAkB,CAClB,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n	background: var(--ck-color-link-selected-background);\n\n	/* Give linked inline images some outline to let the user know they are also part of the link. */\n	& span.image-inline {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n	}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n	background: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n	height: 100%;\n	border-right: 1px solid var(--ck-color-base-text);\n	margin-right: -1px;\n	outline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 2347: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCKA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EACC,kCAAmC,CACnC,kCAAmC,CACnC,sBAAuB,CACvB,cAAe,CAIf,+BAAgC,CAChC,aAAc,CACd,iBAKD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDvDD,oCC2DC,wDACC,8DAMD,CAJC,0EACC,WAAY,CACZ,cACD,CAGD,gJAME,aAEF,CD1ED", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-link-actions__preview {\n		display: inline-block;\n\n		& .ck-button__label {\n			overflow: hidden;\n		}\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-link-actions__preview {\n			flex-basis: 100%;\n		}\n\n		& .ck-button:not(.ck-link-actions__preview) {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`], sourceRoot: "" }]);
          const a = s;
        }, 7754: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{padding:0;min-width:var(--ck-input-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCACC,SAAU,CACV,+BA8CD,CA5CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CACC,kCAAmC,CACnC,QAAS,CACT,eAAgB,CAChB,QAAS,CACT,gDAAiD,CACjD,SAaD,CAnBA,4GAaE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAWD,CATC,wEACC,QAAS,CACT,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n	display: flex;\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n	display: block;\n\n	/*\n	 * Whether the form is in the responsive mode or not, if there are decorator buttons\n	 * keep the top margin of action buttons medium.\n	 */\n	& .ck-button {\n		&.ck-button-save,\n		&.ck-button-cancel {\n			margin-top: var(--ck-spacing-medium);\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n	padding: 0;\n	min-width: var(--ck-input-width);\n\n	& .ck-labeled-field-view {\n		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n		& .ck-input-text {\n			min-width: 0;\n			width: 100%;\n		}\n	}\n\n	& .ck-button {\n		padding: var(--ck-spacing-standard);\n		margin: 0;\n		border-radius: 0;\n		border: 0;\n		border-top: 1px solid var(--ck-color-base-border);\n		width: 50%;\n\n		@mixin ck-dir ltr {\n			margin-left: 0;\n		}\n\n		@mixin ck-dir rtl {\n			margin-left: 0;\n\n			&:last-of-type {\n				border-right: 1px solid var(--ck-color-base-border);\n			}\n		}\n	}\n\n	/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n	& .ck.ck-list {\n		margin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n		& .ck-button.ck-switchbutton {\n			border: 0;\n			padding: 0;\n			width: 100%;\n\n			&:hover {\n				background: none;\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 4652: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck-content .media{clear:both;margin:.9em 0;display:block;min-width:15em}", "", { version: 3, sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembed.css"], names: [], mappings: "AAKA,mBAGC,UAAW,CAKX,aAAe,CAIf,aAAc,CAId,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n	/* Don\'t allow floated content overlap the media.\n	https://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n	clear: both;\n\n	/* Make sure there is some space between the content and the media. */\n	/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n	margin: 0.9em 0;\n\n	/* Make sure media is not overriden with Bootstrap default `flex` value.\n	See: https://github.com/ckeditor/ckeditor5/issues/1373. */\n	display: block;\n\n	/* Give the media some minimal width in the content to prevent them\n	from being "squashed" in tight spaces, e.g. in table cells (#44) */\n	min-width: 15em;\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 7442: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck-media__wrapper .ck-media__placeholder{display:flex;flex-direction:column;align-items:center}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{visibility:visible;opacity:1}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{overflow:hidden;display:block}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{padding:calc(var(--ck-spacing-standard)*3);background:var(--ck-color-base-foreground)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{min-width:var(--ck-media-embed-placeholder-icon-size);height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);background-position:50%;background-size:cover}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{width:100%;height:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);white-space:nowrap;text-align:center;font-style:italic;text-overflow:ellipsis}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-width:300px;max-height:380px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMDAzLjc4IDEuNjFoNDkuNjIxYzEuNjk0IDAgMy4xOS0uNzk4IDQuMTQ2LTIuMDM3eiIgZmlsbD0iIzVjODhjNSIvPjxwYXRoIGQ9Ik0yMjYuNzQyIDIyMi45ODhjLTkuMjY2IDAtMTYuNzc3IDcuMTctMTYuNzc3IDE2LjAxNC4wMDcgMi43NjIuNjYzIDUuNDc0IDIuMDkzIDcuODc1LjQzLjcwMy44MyAxLjQwOCAxLjE5IDIuMTA3LjMzMy41MDIuNjUgMS4wMDUuOTUgMS41MDguMzQzLjQ3Ny42NzMuOTU3Ljk4OCAxLjQ0IDEuMzEgMS43NjkgMi41IDMuNTAyIDMuNjM3IDUuMTY4Ljc5MyAxLjI3NSAxLjY4MyAyLjY0IDIuNDY2IDMuOTkgMi4zNjMgNC4wOTQgNC4wMDcgOC4wOTIgNC42IDEzLjkxNHYuMDEyYy4xODIuNDEyLjUxNi42NjYuODc5LjY2Ny40MDMtLjAwMS43NjgtLjMxNC45My0uNzk5LjYwMy01Ljc1NiAyLjIzOC05LjcyOSA0LjU4NS0xMy43OTQuNzgyLTEuMzUgMS42NzMtMi43MTUgMi40NjUtMy45OSAxLjEzNy0xLjY2NiAyLjMyOC0zLjQgMy42MzgtNS4xNjkuMzE1LS40ODIuNjQ1LS45NjIuOTg4LTEuNDM5LjMtLjUwMy42MTctMS4wMDYuOTUtMS41MDguMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0eiIgZmlsbD0iI2RkNGIzZSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48ZWxsaXBzZSByeT0iNS41NjQiIHJ4PSI1LjgyOCIgY3k9IjIzOS4wMDIiIGN4PSIyMjYuNzQyIiBmaWxsPSIjODAyZDI3IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0xOTAuMzAxIDIzNy4yODNjLTQuNjcgMC04LjQ1NyAzLjg1My04LjQ1NyA4LjYwNnMzLjc4NiA4LjYwNyA4LjQ1NyA4LjYwN2MzLjA0MyAwIDQuODA2LS45NTggNi4zMzctMi41MTYgMS41My0xLjU1NyAyLjA4Ny0zLjkxMyAyLjA4Ny02LjI5IDAtLjM2Mi0uMDIzLS43MjItLjA2NC0xLjA3OWgtOC4yNTd2My4wNDNoNC44NWMtLjE5Ny43NTktLjUzMSAxLjQ1LTEuMDU4IDEuOTg2LS45NDIuOTU4LTIuMDI4IDEuNTQ4LTMuOTAxIDEuNTQ4LTIuODc2IDAtNS4yMDgtMi4zNzItNS4yMDgtNS4yOTkgMC0yLjkyNiAyLjMzMi01LjI5OSA1LjIwOC01LjI5OSAxLjM5OSAwIDIuNjE4LjQwNyAzLjU4NCAxLjI5M2wyLjM4MS0yLjM4YzAtLjAwMi0uMDAzLS4wMDQtLjAwNC0uMDA1LTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTV6bTQuNDMgNS42NmwuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxNS4xODQgMjUxLjkyOWwtNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMjMzIDUuMjMzIDAgMDAuNDQ5LTIuMTIzdi0zMS4xNjVjLS40NjkuNjc1LS45MzQgMS4zNDktMS4zODIgMi4wMDUtLjc5MiAxLjI3NS0xLjY4MiAyLjY0LTIuNDY1IDMuOTktMi4zNDcgNC4wNjUtMy45ODIgOC4wMzgtNC41ODUgMTMuNzk0LS4xNjIuNDg1LS41MjcuNzk4LS45My43OTktLjM2My0uMDAxLS42OTctLjI1NS0uODc5LS42Njd2LS4wMTJjLS41OTMtNS44MjItMi4yMzctOS44Mi00LjYtMTMuOTE0LS43ODMtMS4zNS0xLjY3My0yLjcxNS0yLjQ2Ni0zLjk5LTEuMTM3LTEuNjY2LTIuMzI3LTMuNC0zLjYzNy01LjE2OWwtLjAwMi0uMDAzeiIgZmlsbD0iI2MzYzNjMyIvPjxwYXRoIGQ9Ik0yMTIuOTgzIDI0OC40OTVsLTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAwNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYuMjc1IDEzNi4yNzUgMCAwMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAwLS45ODktMS40NCAzNS4xMjcgMzUuMTI3IDAgMDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OXoiIGZpbGw9IiNmZGRjNGYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxMS45OTggMjYxLjA4M2wtNi4xNTIgNi4xNTEgMjQuMjY0IDI0LjI2NGguNzgxYTUuMjI3IDUuMjI3IDAgMDA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OXptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OXoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzN6bTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1ek00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", { version: 3, sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./../ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"], names: [], mappings: "AAQC,0CACC,YAAa,CACb,qBAAsB,CACtB,kBAmBD,CCpBA,kFACC,aAqBD,CAHC,oBAnBD,kFAoBE,YAEF,CADC,CDlBA,sEAIC,cAAe,CAEf,iBAUD,CCoBD,wFACC,kBAAmB,CACnB,SACD,CD3BE,wGACC,eAAgB,CAChB,aACD,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CElDA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CACC,0CAA+C,CAC/C,0CA4BD,CA1BC,uEACC,qDAAsD,CACtD,kDAAmD,CACnD,qCAAsC,CACtC,uBAA2B,CAC3B,qBAMD,CAJC,gFACC,UAAW,CACX,WACD,CAGD,4EACC,sDAAuD,CACvD,kBAAmB,CACnB,iBAAkB,CAClB,iBAAkB,CAClB,sBAOD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDACC,eAAgB,CAChB,gBACD,CAEA,4UAIC,gvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,48BACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n\n.ck-media__wrapper {\n	& .ck-media__placeholder {\n		display: flex;\n		flex-direction: column;\n		align-items: center;\n\n		& .ck-media__placeholder__url {\n			@mixin ck-tooltip_enabled;\n\n			/* Otherwise the URL will overflow when the content is very narrow. */\n			max-width: 100%;\n\n			position: relative;\n\n			&:hover {\n				@mixin ck-tooltip_visible;\n			}\n\n			& .ck-media__placeholder__url__text {\n				overflow: hidden;\n				display: block;\n			}\n		}\n	}\n\n	&[data-oembed-url*="twitter.com"],\n	&[data-oembed-url*="google.com/maps"],\n	&[data-oembed-url*="goo.gl/maps"],\n	&[data-oembed-url*="maps.google.com"],\n	&[data-oembed-url*="maps.app.goo.gl"],\n	&[data-oembed-url*="facebook.com"],\n	&[data-oembed-url*="instagram.com"] {\n		& .ck-media__placeholder__icon * {\n			display: none;\n		}\n	}\n}\n\n/* Disable all mouse interaction as long as the editor is not read\u2013only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n	pointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n	pointer-events: none;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n	& .ck-tooltip {\n		display: block;\n\n		/*\n		 * Don't display tooltips in devices which don't support :hover.\n		 * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n		 * the primary action, when tooltips are enabled.\n		 *\n		 * Q: OK, but why not the following query?\n		 *\n		 *   @media (hover) {\n		 *       display: block;\n		 *   }\n		 *\n		 * A: Because FF does not support it and it would completely disable tooltips\n		 * in that browser.\n		 *\n		 * More in https://github.com/ckeditor/ckeditor5/issues/920.\n		 */\n		@media (hover:none) {\n			display: none;\n		}\n	}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n	& .ck-tooltip {\n		display: none;\n	}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n	& .ck-tooltip {\n		visibility: visible;\n		opacity: 1;\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-media-embed-placeholder-icon-size: 3em;\n\n	--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n	--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n	margin: 0 auto;\n\n	& .ck-media__placeholder {\n		padding: calc( 3 * var(--ck-spacing-standard) );\n		background: var(--ck-color-base-foreground);\n\n		& .ck-media__placeholder__icon {\n			min-width: var(--ck-media-embed-placeholder-icon-size);\n			height: var(--ck-media-embed-placeholder-icon-size);\n			margin-bottom: var(--ck-spacing-large);\n			background-position: center;\n			background-size: cover;\n\n			& .ck-icon {\n				width: 100%;\n				height: 100%;\n			}\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: var(--ck-color-media-embed-placeholder-url-text);\n			white-space: nowrap;\n			text-align: center;\n			font-style: italic;\n			text-overflow: ellipsis;\n\n			&:hover {\n				color: var(--ck-color-media-embed-placeholder-url-text-hover);\n				cursor: pointer;\n				text-decoration: underline;\n			}\n		}\n	}\n\n	&[data-oembed-url*="open.spotify.com"] {\n		max-width: 300px;\n		max-height: 380px;\n	}\n\n	&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n		background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n	}\n\n	&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n		background: hsl(220, 46%, 48%);\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: hsl(220, 100%, 90%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n\n	&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n		background: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n		}\n\n		/* stylelint-disable-next-line no-descending-specificity */\n		& .ck-media__placeholder__url__text {\n			color: hsl(302, 100%, 94%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n\n	&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n		/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n		background: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: hsl(201, 100%, 86%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 9292: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-media-form{display:flex;align-items:flex-start;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-media-embed/theme/mediaform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,kBACC,YAAa,CACb,sBAAuB,CACvB,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n	display: flex;\n	align-items: flex-start;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-labeled-field-view {\n		display: inline-block;\n	}\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 1613: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAEC,oJAA2J,CAC3J,yFACD,CAEA,qCACC,iBACD,CAEA,uCACC,+CAAgD,CAChD,iDAAkD,CAClD,iDAAkD,CAClD,4CAA6C,CAC7C,iBAMD,CAJC,6CACC,yCAA0C,CAC1C,6CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-insert-table-dropdown-padding: 10px;\n	--ck-insert-table-dropdown-box-height: 11px;\n	--ck-insert-table-dropdown-box-width: 12px;\n	--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label {\n	text-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n	width: var(--ck-insert-table-dropdown-box-width);\n	height: var(--ck-insert-table-dropdown-box-height);\n	margin: var(--ck-insert-table-dropdown-box-margin);\n	border: 1px solid var(--ck-color-base-border);\n	border-radius: 1px;\n\n	&.ck-on {\n		border-color: var(--ck-color-focus-border);\n		background: var(--ck-color-focus-outer-shadow);\n	}\n}\n\n"], sourceRoot: "" }]);
          const a = s;
        }, 6306: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck-content .table{margin:.9em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAIC,gBAAkB,CAClB,aAgCD,CA9BC,yBAEC,wBAAyB,CACzB,gBAAiB,CAIjB,UAAW,CACX,WAAY,CAIZ,yBAiBD,CAfC,wDAEC,aAAc,CACd,YAAa,CAKb,wBACD,CAEA,4BACC,eAAiB,CACjB,2BACD,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`], sourceRoot: "" }]);
          const a = s;
        }, 3881: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,8DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-table-focused-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n	& td,\n	& th {\n		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n		&.ck-editor__nested-editable:focus {\n			/* A very slight background to highlight the focused cell */\n			background: var(--ck-color-table-focused-cell-background);\n\n			/* Fixes the problem where surrounding cells cover the focused cell's border.\n			It does not fix the problem in all places but the UX is improved.\n			See https://github.com/ckeditor/ckeditor5-table/issues/29. */\n			border-style: none;\n			outline: 1px solid var(--ck-color-focus-border);\n			outline-offset: -1px; /* progressive enhancement - no IE support */\n		}\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 6945: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,0.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{position:relative;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{content:"";pointer-events:none;background-color:var(--ck-table-selected-cell-background);position:absolute;top:0;left:0;right:0;bottom:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,yDACD,CAGC,0IAEC,iBAAkB,CAClB,uBAAwB,CACxB,aAAc,CACd,gBA8BD,CA3BC,sJACC,UAAW,CACX,mBAAoB,CACpB,yDAA0D,CAC1D,iBAAkB,CAClB,KAAM,CACN,MAAO,CACP,OAAQ,CACR,QACD,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n	& td.ck-editor__editable_selected,\n	& th.ck-editor__editable_selected {\n		position: relative;\n		caret-color: transparent;\n		outline: unset;\n		box-shadow: unset;\n\n		/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n		&:after {\n			content: '';\n			pointer-events: none;\n			background-color: var(--ck-table-selected-cell-background);\n			position: absolute;\n			top: 0;\n			left: 0;\n			right: 0;\n			bottom: 0;\n		}\n\n		& ::selection,\n		&:focus {\n			background-color: transparent;\n		}\n\n		/*\n		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9491.\n		 */\n		& .ck-widget {\n			outline: unset;\n\n			& > .ck-widget__selection-handle {\n				display: none;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 4906: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAQA,6BCCC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6BD,CE/BC,qDACC,aAqBD,CAHC,oBAnBD,qDAoBE,YAEF,CADC,CFvBF,6BAKC,iBAAkB,CAClB,mBAAoB,CACpB,kBAAmB,CACnB,oBAyBD,CAvBC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEkBA,iEACC,kBAAmB,CACnB,SACD,CAbA,yFACC,YACD,CC7BD,6BCAC,oDD0ID,CCvIE,6EACC,0DACD,CAEA,+EACC,2DAA4C,CAC5C,uEACD,CAID,qDACC,6DACD,CDhBD,6BEDC,eF2ID,CA1IA,wIEGE,qCFuIF,CA1IA,6BAKC,kBAAmB,CACnB,cAAe,CACf,qBAAsB,CACtB,8BAA+B,CAC/B,iBAAkB,CAGlB,2CAA4C,CAC5C,4CAA6C,CAI7C,aAAc,CAGd,iBAAkB,CAGlB,4BAA6B,CAG7B,4DAA8D,CAG9D,uBA6GD,CA3GC,oFGjCA,YAAa,CACb,2BAA2B,CCF3B,2CJsCA,CAIC,kJAEC,aACD,CAGD,iEAEC,iBAAkB,CAClB,mBAAoB,CACpB,aAAc,CACd,cAAe,CAIf,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAEA,uFK3FD,kCL6FC,CAGA,yFKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAOE,6CAAgD,CAChD,mCAEF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDiIA,CC9HC,yFACC,qDACD,CAEA,2FACC,sDAA4C,CAC5C,kEACD,CAID,iEACC,wDACD,CDmHA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC7IC,mDDkJD,CC/IE,2FACC,yDACD,CAEA,6FACC,0DAA4C,CAC5C,sEACD,CAID,mEACC,4DACD,CD6HD,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-button,\na.ck.ck-button {\n	@mixin ck-unselectable;\n	@mixin ck-tooltip_enabled;\n\n	position: relative;\n	display: inline-flex;\n	align-items: center;\n	justify-content: left;\n\n	& .ck-button__label {\n		display: none;\n	}\n\n	&.ck-button_with-text {\n		& .ck-button__label {\n			display: inline-block;\n		}\n	}\n\n	/* Center the icon horizontally in a button without text. */\n	&:not(.ck-button_with-text)  {\n		justify-content: center;\n	}\n\n	&:hover {\n		@mixin ck-tooltip_visible;\n	}\n\n	/* Get rid of the native focus outline around the tooltip when focused (but not :hover). */\n	&:focus:not(:hover) {\n		@mixin ck-tooltip_disabled;\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n	& .ck-tooltip {\n		display: block;\n\n		/*\n		 * Don't display tooltips in devices which don't support :hover.\n		 * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n		 * the primary action, when tooltips are enabled.\n		 *\n		 * Q: OK, but why not the following query?\n		 *\n		 *   @media (hover) {\n		 *       display: block;\n		 *   }\n		 *\n		 * A: Because FF does not support it and it would completely disable tooltips\n		 * in that browser.\n		 *\n		 * More in https://github.com/ckeditor/ckeditor5/issues/920.\n		 */\n		@media (hover:none) {\n			display: none;\n		}\n	}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n	& .ck-tooltip {\n		display: none;\n	}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n	& .ck-tooltip {\n		visibility: visible;\n		opacity: 1;\n	}\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n	background: var($(prefix)-background);\n\n	&:not(.ck-disabled) {\n		&:hover {\n			background: var($(prefix)-hover-background);\n		}\n\n		&:active {\n			background: var($(prefix)-active-background);\n			box-shadow: inset 0 2px 2px var($(prefix)-active-shadow);\n		}\n	}\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n	&.ck-disabled {\n		background: var($(prefix)-disabled-background);\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 5332: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,mDAAoD,CACpD,qCAAsC,CACtC,gKAKD,CAGC,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDC3BA,eDoEA,CAzCA,yICvBC,qCDgED,CAzCA,2DAKE,gBAoCF,CAzCA,2DAUE,iBA+BF,CAzCA,iDAcC,8BAAiC,CAEjC,0CAA2C,CAC3C,uDAwBD,CAtBC,2EC9CD,eD2DC,CAbA,6LC1CA,qCAAsC,CD4CpC,+CAWF,CAbA,2EAMC,6CAA8C,CAC9C,+CAAgD,CAChD,gDAAiD,CACjD,yDAA0D,CAG1D,uBACD,CAEA,uDACC,6DAKD,CAHC,iFACC,+DACD,CAIF,6DExEA,kCF0EA,CAEA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,yDAMF,CAXA,2FASE,kEAEF", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n	& .ck-button__toggle {\n		display: block;\n\n		& .ck-button__toggle__inner {\n			display: block;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating\u2013point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n	/* 34px at 13px font-size */\n	--ck-switch-button-toggle-width: 2.6153846154em;\n	/* 14px at 13px font-size */\n	--ck-switch-button-toggle-inner-size: 1.0769230769em;\n	--ck-switch-button-toggle-spacing: 1px;\n	--ck-switch-button-translation: calc(\n		var(--ck-switch-button-toggle-width) -\n		var(--ck-switch-button-toggle-inner-size) -\n		2 * var(--ck-switch-button-toggle-spacing)\n	);\n}\n\n.ck.ck-button.ck-switchbutton {\n	& .ck-button__label {\n		@mixin ck-dir ltr {\n			/* Separate the label from the switch */\n			margin-right: calc(2 * var(--ck-spacing-large));\n		}\n\n		@mixin ck-dir rtl {\n			/* Separate the label from the switch */\n			margin-left: calc(2 * var(--ck-spacing-large));\n		}\n	}\n\n	& .ck-button__toggle {\n		@mixin ck-rounded-corners;\n\n		@mixin ck-dir ltr {\n			/* Make sure the toggle is always to the right as far as possible. */\n			margin-left: auto;\n		}\n\n		@mixin ck-dir rtl {\n			/* Make sure the toggle is always to the left as far as possible. */\n			margin-right: auto;\n		}\n\n		/* Gently animate the background color of the toggle switch */\n		transition: background 400ms ease;\n\n		width: var(--ck-switch-button-toggle-width);\n		background: var(--ck-color-switch-button-off-background);\n\n		& .ck-button__toggle__inner {\n			@mixin ck-rounded-corners {\n				border-radius: calc(.5 * var(--ck-border-radius));\n			}\n\n			/* Leave some tiny bit of space around the inner part of the switch */\n			margin: var(--ck-switch-button-toggle-spacing);\n			width: var(--ck-switch-button-toggle-inner-size);\n			height: var(--ck-switch-button-toggle-inner-size);\n			background: var(--ck-color-switch-button-inner-background);\n\n			/* Gently animate the inner part of the toggle switch */\n			transition: all 300ms ease;\n		}\n\n		&:hover {\n			background: var(--ck-color-switch-button-off-hover-background);\n\n			& .ck-button__toggle__inner {\n				box-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n			}\n		}\n	}\n\n	&.ck-disabled .ck-button__toggle {\n		@mixin ck-disabled;\n	}\n\n	&.ck-on .ck-button__toggle {\n		background: var(--ck-color-switch-button-on-background);\n\n		&:hover {\n			background: var(--ck-color-switch-button-on-hover-background);\n		}\n\n		& .ck-button__toggle__inner {\n			/*\n			 * Move the toggle switch to the right. It will be animated.\n			 */\n			@mixin ck-dir ltr {\n				transform: translateX( var( --ck-switch-button-translation ) );\n			}\n\n			@mixin ck-dir rtl {\n				transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 6781: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,qCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBACC,oCAAqC,CACrC,qCAAsC,CACtC,wCAAyC,CACzC,yCAA0C,CAC1C,SAAU,CACV,8BAA+B,CAC/B,QAmCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCACC,YAAa,CACb,2CACD,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n	display: grid;\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(0, 0%, 0%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-table__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`], sourceRoot: "" }]);
          const a = s;
        }, 5485: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);max-width:var(--ck-dropdown-max-width);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBAqFD,CAnFC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UAOD,CCUA,iEACC,YACD,CDVA,oCAGC,kCAAmC,CAEnC,YAAa,CACb,yBAA0B,CAC1B,sCAAuC,CAEvC,iBAyDD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSASC,QAAS,CACT,WACD,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CEhGA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CACC,gCAAiC,CAGjC,sCACD,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEACC,SAAU,CACV,eAAgB,CAChB,sBACD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBEpFC,oCAA8B,CFwF9B,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CAGT,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD", sourcesContent: [`/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../tooltip/mixins/_tooltip.css";

:root {
	--ck-dropdown-max-width: 75vw;
}

.ck.ck-dropdown {
	display: inline-block;
	position: relative;

	& .ck-dropdown__arrow {
		pointer-events: none;
		z-index: var(--ck-z-default);
	}

	/* Dropdown button should span horizontally, e.g. in vertical toolbars */
	& .ck-button.ck-dropdown__button {
		width: 100%;

		/* Disable main button's tooltip when the dropdown is open. Otherwise the panel may
		partially cover the tooltip */
		&.ck-on {
			@mixin ck-tooltip_disabled;
		}
	}

	& .ck-dropdown__panel {
		/* This is to get rid of flickering when the tooltip is shown under the panel,
		which looks like the panel moves vertically a pixel down and up. */
		-webkit-backface-visibility: hidden;

		display: none;
		z-index: var(--ck-z-modal);
		max-width: var(--ck-dropdown-max-width);

		position: absolute;

		&.ck-dropdown__panel-visible {
			display: inline-block;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_n,
		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_nme {
			bottom: 100%;
		}

		&.ck-dropdown__panel_se,
		&.ck-dropdown__panel_sw,
		&.ck-dropdown__panel_smw,
		&.ck-dropdown__panel_sme,
		&.ck-dropdown__panel_s {
			/*
			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.
			 * See https://github.com/ckeditor/ckeditor5/issues/1053.
			 */
			top: 100%;
			bottom: auto;
		}

		&.ck-dropdown__panel_ne,
		&.ck-dropdown__panel_se {
			left: 0px;
		}

		&.ck-dropdown__panel_nw,
		&.ck-dropdown__panel_sw {
			right: 0px;
		}

		&.ck-dropdown__panel_s,
		&.ck-dropdown__panel_n {
			/* Positioning panels relative to the center of the button */
			left: 50%;
			transform: translateX(-50%);
		}

		&.ck-dropdown__panel_nmw,
		&.ck-dropdown__panel_smw {
			/* Positioning panels relative to the middle-west of the button */
			left: 75%;
			transform: translateX(-75%);
		}

		&.ck-dropdown__panel_nme,
		&.ck-dropdown__panel_sme {
			/* Positioning panels relative to the middle-east of the button */
			left: 25%;
			transform: translateX(-25%);
		}
	}
}

/*
 * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.
 * See https://github.com/ckeditor/ckeditor5/issues/7874
 */
.ck.ck-toolbar .ck-dropdown__panel {
	z-index: calc( var(--ck-z-modal) + 1 );
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n	& .ck-tooltip {\n		display: block;\n\n		/*\n		 * Don't display tooltips in devices which don't support :hover.\n		 * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n		 * the primary action, when tooltips are enabled.\n		 *\n		 * Q: OK, but why not the following query?\n		 *\n		 *   @media (hover) {\n		 *       display: block;\n		 *   }\n		 *\n		 * A: Because FF does not support it and it would completely disable tooltips\n		 * in that browser.\n		 *\n		 * More in https://github.com/ckeditor/ckeditor5/issues/920.\n		 */\n		@media (hover:none) {\n			display: none;\n		}\n	}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n	& .ck-tooltip {\n		display: none;\n	}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n	& .ck-tooltip {\n		visibility: visible;\n		opacity: 1;\n	}\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;
			
			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 3949: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDIpC,wBAAyB,CACzB,2BAA4B,CAC5B,4BAEF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n	/* Disabled radius of top-left border to be consistent with .dropdown__button\n	https://github.com/ckeditor/ckeditor5/issues/816 */\n	@mixin ck-rounded-corners {\n		border-top-left-radius: 0;\n	}\n\n	/* Make sure the button belonging to the first/last child of the list goes well with the\n	border radius of the entire panel. */\n	& .ck-list__item {\n		&:first-child .ck-button {\n			@mixin ck-rounded-corners {\n				border-top-left-radius: 0;\n				border-bottom-left-radius: 0;\n				border-bottom-right-radius: 0;\n			}\n		}\n\n		&:last-child .ck-button {\n			@mixin ck-rounded-corners {\n				border-top-left-radius: 0;\n				border-top-right-radius: 0;\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 7686: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{content:"";position:absolute;width:1px;height:100%;background-color:var(--ck-color-split-button-hover-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,mBAEC,iBAUD,CARC,iDACC,qCACD,CC0BA,8DACC,YACD,CClCD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAIE,6BAA8B,CAC9B,gCAQF,CAbA,oIAUE,4BAA6B,CAC7B,+BAEF,CAEA,0CAGC,eAiBD,CApBA,oDAOE,4BAA6B,CAC7B,+BAYF,CApBA,oDAaE,6BAA8B,CAC9B,gCAMF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAIA,8JACC,UAAW,CACX,iBAAkB,CAClB,SAAU,CACV,WAAY,CACZ,0DACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCC7EA,eDuFA,CAVA,qHCzEC,qCDmFD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-splitbutton {\n	/* Enable font size inheritance, which allows fluid UI scaling. */\n	font-size: inherit;\n\n	& .ck-splitbutton__action:focus {\n		z-index: calc(var(--ck-z-default) + 1);\n	}\n\n	/* Disable tooltips for the buttons when the button is "open" */\n	&.ck-splitbutton_open > .ck-button {\n		@mixin ck-tooltip_disabled;\n	}\n}\n\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n	& .ck-tooltip {\n		display: block;\n\n		/*\n		 * Don't display tooltips in devices which don't support :hover.\n		 * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n		 * the primary action, when tooltips are enabled.\n		 *\n		 * Q: OK, but why not the following query?\n		 *\n		 *   @media (hover) {\n		 *       display: block;\n		 *   }\n		 *\n		 * A: Because FF does not support it and it would completely disable tooltips\n		 * in that browser.\n		 *\n		 * More in https://github.com/ckeditor/ckeditor5/issues/920.\n		 */\n		@media (hover:none) {\n			display: none;\n		}\n	}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n	& .ck-tooltip {\n		display: none;\n	}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n	& .ck-tooltip {\n		visibility: visible;\n		opacity: 1;\n	}\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 7339: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{width:max-content;max-width:var(--ck-toolbar-dropdown-max-width)}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAEC,iBAAkB,CAClB,8CAOD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n	/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n	width: max-content;\n	max-width: var(--ck-toolbar-dropdown-max-width);\n\n	& .ck-button {\n		&:focus {\n			z-index: calc(var(--ck-z-default) + 1);\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n	border: 0;\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 9688: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEERA,YAAa,CACb,2BAA2B,CCF3B,qCHYA,CAGD,+BACC,aAAc,CACd,oCAAqC,CACrC,4BA4BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n	@mixin ck-rounded-corners;\n\n	&.ck-focused {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n	}\n}\n\n.ck.ck-editor__editable_inline {\n	overflow: auto;\n	padding: 0 var(--ck-spacing-standard);\n	border: 1px solid transparent;\n\n	&[dir="ltr"] {\n		text-align: left;\n	}\n\n	&[dir="rtl"] {\n		text-align: right;\n	}\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n	& > *:first-child {\n		margin-top: var(--ck-spacing-large);\n	}\n\n	/* https://github.com/ckeditor/ckeditor5/issues/847 */\n	& > *:last-child {\n		/*\n		 * This value should match with the default margins of the block elements (like .media or .image)\n		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n		 */\n		margin-bottom: var(--ck-spacing-large);\n	}\n\n	/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n	&.ck-blurred ::selection {\n		background: var(--ck-color-editable-blur-selection);\n	}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n	&::after {\n		border-bottom-color: var(--ck-color-base-foreground);\n	}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n	&::after {\n		border-top-color: var(--ck-color-base-foreground);\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 8847: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-form__header{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{padding:var(--ck-spacing-small) var(--ck-spacing-large);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,kBAAmB,CACnB,6BACD,CCNA,MACC,4BACD,CAEA,oBACC,uDAAwD,CACxD,mCAAoC,CACpC,wCAAyC,CACzC,mDAKD,CAHC,4CACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	align-items: center;\n	justify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n	padding: var(--ck-spacing-small) var(--ck-spacing-large);\n	height: var(--ck-form-header-height);\n	line-height: var(--ck-form-header-height);\n	border-bottom: 1px solid var(--ck-color-base-border);\n\n	& .ck-form__header__label {\n		font-weight: bold;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 6574: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YACC,yBAA0B,CAC1B,0BAA2B,CAG3B,uBAAwB,CAQxB,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n	vertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n	width: var(--ck-icon-size);\n	height: var(--ck-icon-size);\n\n	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n	font-size: .8333350694em;\n\n	color: inherit;\n\n	/* Inherit cursor style (#5). */\n	cursor: inherit;\n\n	/* This will prevent blurry icons on Firefox. See #340. */\n	will-change: transform;\n\n	& * {\n		/* Inherit cursor style (#5). */\n		cursor: inherit;\n\n		/* Allows dynamic coloring of the icons. */\n		color: inherit;\n\n		&:not([fill]) {\n			/* Needed by FF. */\n			fill: currentColor;\n		}\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 4879: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-input[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-input-shake .3s ease both}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAC9C,6DAA8D,CAC9D,+BAAgC,CAGhC,4CAA6C,CAG7C,4DA0BD,CAxBC,mBEpBA,YAAa,CACb,2BAA2B,CCF3B,2CHwBA,CAEA,uBACC,sDAAuD,CACvD,oDAAqD,CACrD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBACC,+CAAgD,CAChD,sCAKD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-input-width: 18em;\n\n	/* Backward compatibility. */\n	--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n	@mixin ck-rounded-corners;\n\n	background: var(--ck-color-input-background);\n	border: 1px solid var(--ck-color-input-border);\n	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n	min-width: var(--ck-input-width);\n\n	/* This is important to stay of the same height as surrounding buttons */\n	min-height: var(--ck-ui-component-min-height);\n\n	/* Apply some smooth transition to the box-shadow and border. */\n	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n	&:focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n	}\n\n	&[readonly] {\n		border: 1px solid var(--ck-color-input-disabled-border);\n		background: var(--ck-color-input-disabled-background);\n		color: var(--ck-color-input-disabled-text);\n\n		&:focus {\n			/* The read-only input should have a slightly less visible shadow when focused. */\n			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n		}\n	}\n\n	&.ck-error {\n		border-color: var(--ck-color-input-error-border);\n		animation: ck-input-shake .3s ease both;\n\n		&:focus {\n			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n		}\n	}\n}\n\n@keyframes ck-input-shake {\n	20% {\n		transform: translateX(-2px);\n	}\n\n	40% {\n		transform: translateX(2px);\n	}\n\n	60% {\n		transform: translateX(-1px);\n	}\n\n	80% {\n		transform: translateX(1px);\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 3662: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n	display: block;\n}\n\n.ck.ck-voice-label {\n	display: none;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n	font-weight: bold;\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 2577: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{pointer-events:none;transform-origin:0 0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);background:var(--ck-color-labeled-field-label-background);padding:0 calc(var(--ck-font-size-tiny)*0.5);line-height:normal;font-weight:400;text-overflow:ellipsis;overflow:hidden;max-width:100%;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-spacing-medium),calc(var(--ck-font-size-base)*0.6)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-spacing-medium)*-1),calc(var(--ck-font-size-base)*0.6)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));background:transparent;padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,yEACD,CAEA,0BCHC,eD4GD,CAzGA,2FCCE,qCDwGF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAWC,mBAAoB,CACpB,oBAAqB,CAGrB,6DAA+D,CAE/D,yDAA0D,CAC1D,4CAA8C,CAC9C,kBAAoB,CACpB,eAAmB,CAGnB,sBAAuB,CACvB,eAAgB,CAEhB,cAAe,CAEf,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,yFAYF,CAfA,oUAOE,kGAQF,CAfA,gTAWC,iEAAkE,CAElE,sBAAuB,CACvB,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n	& > .ck.ck-labeled-field-view__input-wrapper {\n		display: flex;\n		position: relative;\n	}\n\n	& .ck.ck-label {\n		display: block;\n		position: absolute;\n	}\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
			}

			@mixin ck-dir rtl {
				right: 0px;
			}

			pointer-events: none;
			transform-origin: 0 0;

			/* By default, display the label scaled down above the field. */
			transform: translate(var(--ck-spacing-medium), -6px) scale(.75);

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-spacing-medium), calc(0.6 * var(--ck-font-size-base))) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-spacing-medium)), calc(0.6 * var(--ck-font-size-base))) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 1046: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,qBAcD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAGC,oBAAqB,CACrB,0CACD,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BACC,gBAAiB,CACjB,UAAW,CACX,eAAgB,CAChB,eAAgB,CAKhB,mIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,2DACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBACC,UAAW,CACX,UAAW,CACX,sCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n	@mixin ck-unselectable;\n\n	display: flex;\n	flex-direction: column;\n\n	& .ck-list__item,\n	& .ck-list__separator {\n		display: block;\n	}\n\n	/* Make sure that whatever child of the list item gets focus, it remains on the\n	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n	adjacent list items. */\n	& .ck-list__item > *:focus {\n		position: relative;\n		z-index: var(--ck-z-default);\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		text-align: left;
		border-radius: 0;

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding:
			calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
			calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 8793: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCJC,eD4ID,CAxIA,iFCAE,qCDwIF,CAxIA,qBENC,oCAA8B,CFU9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAiID,CA9HE,+GAEC,OAAQ,CACR,QAAS,CACT,kBACD,CAIA,uFAEC,oDAAoH,CAApH,kDAAoH,CAApH,qDAAoH,CAApH,kBACD,CAEA,4CACC,gDACD,CAEA,uFAHC,6BAA8E,CAA9E,8BAA8E,CAA9E,4BAMD,CAHA,2CACC,oDAAkF,CAClF,yCACD,CAIA,uFAEC,oDAAoH,CAApH,qBAAoH,CAApH,qDAAoH,CAApH,+CACD,CAEA,4CACC,6CAAkE,CAClE,uDACD,CAEA,uFAJC,6BAAkE,CAAlE,+BAAkE,CAAlE,8BAOD,CAHA,2CACC,iDAAkF,CAClF,4CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,8CACD,CAIA,2GAEC,+CAAkD,CAClD,8CACD,CAIA,2GAEC,gDAAmD,CACnD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,8CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* Make sure the balloon arrow does not float over its children. */\n	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n	display: none;\n	position: absolute;\n\n	z-index: var(--ck-z-modal);\n\n	&.ck-balloon-panel_with-arrow {\n		&::before,\n		&::after {\n			content: "";\n			position: absolute;\n		}\n\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&[class*="arrow_n"] {\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&[class*="arrow_s"] {\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&.ck-balloon-panel_visible {\n		display: block;\n	}\n}\n', '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-balloon-arrow-offset: 2px;\n	--ck-balloon-arrow-height: 10px;\n	--ck-balloon-arrow-half-width: 8px;\n	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n	@mixin ck-rounded-corners;\n	@mixin ck-drop-shadow;\n\n	min-height: 15px;\n\n	background: var(--ck-color-panel-background);\n	border: 1px solid var(--ck-color-panel-border);\n\n	&.ck-balloon-panel_with-arrow {\n		&::before,\n		&::after {\n			width: 0;\n			height: 0;\n			border-style: solid;\n		}\n	}\n\n	&[class*="arrow_n"] {\n		&::before,\n		&::after {\n			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n		}\n\n		&::before {\n			border-color: transparent transparent var(--ck-color-panel-border) transparent;\n		}\n\n		&::after {\n			border-color: transparent transparent var(--ck-color-panel-background) transparent;\n			margin-top: var(--ck-balloon-arrow-offset);\n		}\n	}\n\n	&[class*="arrow_s"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n		}\n\n		&::before {\n			border-color: var(--ck-color-panel-border) transparent transparent;\n			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n		}\n\n		&::after {\n			border-color: var(--ck-color-panel-background) transparent transparent transparent;\n			margin-bottom: var(--ck-balloon-arrow-offset);\n		}\n	}\n\n	&.ck-balloon-panel_arrow_n {\n		&::before,\n		&::after {\n			left: 50%;\n			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nw {\n		&::before,\n		&::after {\n			left: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_ne {\n		&::before,\n		&::after {\n			right: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_s {\n		&::before,\n		&::after {\n			left: 50%;\n			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_sw {\n		&::before,\n		&::after {\n			left: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_se {\n		&::before,\n		&::after {\n			right: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_sme {\n		&::before,\n		&::after {\n			right: 25%;\n			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_smw {\n		&::before,\n		&::after {\n			left: 25%;\n			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nme {\n		&::before,\n		&::after {\n			right: 25%;\n			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nmw {\n		&::before,\n		&::after {\n			left: 25%;\n			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 4650: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCACC,oCAAqC,CACrC,kCAAmC,CACnC,qCACD,CAGA,iEACC,uCAAwC,CAGxC,mCACD,CAMA,2DACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n	display: flex;\n	align-items: center;\n	justify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n	justify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n	background: var(--ck-color-toolbar-background);\n	border-bottom: 1px solid var(--ck-color-toolbar-border);\n	padding: 0 var(--ck-spacing-small);\n\n	/* Let's keep similar appearance to `ck-toolbar`. */\n	& > * {\n		margin-right: var(--ck-spacing-small);\n		margin-top: var(--ck-spacing-small);\n		margin-bottom: var(--ck-spacing-small);\n	}\n\n	/* Gives counter more breath than buttons. */\n	& .ck-balloon-rotator__counter {\n		margin-right: var(--ck-spacing-standard);\n\n		/* We need to use smaller margin because of previous button's right margin. */\n		margin-left: var(--ck-spacing-small);\n	}\n}\n\n.ck .ck-balloon-rotator__content {\n\n	/* Disable default annotation shadow inside rotator with fake panels. */\n	& .ck.ck-annotation-wrapper {\n		box-shadow: none;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 7676: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBCJC,oCAA8B,CDO9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CAEtC,UAAW,CACX,WACD,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n	position: absolute;\n\n	/* Fake panels should be placed under main balloon content. */\n	z-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n	position: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n	z-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n	z-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-balloon-fake-panel-offset-horizontal: 6px;\n	--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n	@mixin ck-drop-shadow;\n\n	min-height: 15px;\n\n	background: var(--ck-color-panel-background);\n	border: 1px solid var(--ck-color-panel-border);\n	border-radius: var(--ck-border-radius);\n\n	width: 100%;\n	height: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n	margin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n	--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 5868: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDACC,yBAA0B,CAC1B,cAAe,CACf,KACD,CAEA,kEACC,QAAS,CACT,iBACD,CCPA,qDCCA,oCAA8B,CDE7B,sBAAuB,CACvB,wBAAyB,CACzB,yBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n	& .ck-sticky-panel__content_sticky {\n		z-index: var(--ck-z-modal); /* #315 */\n		position: fixed;\n		top: 0;\n	}\n\n	& .ck-sticky-panel__content_sticky_bottom-limit {\n		top: auto;\n		position: absolute;\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n	& .ck-sticky-panel__content_sticky {\n		@mixin ck-drop-shadow;\n\n		border-width: 0 1px 1px;\n		border-top-left-radius: 0;\n		border-top-right-radius: 0;\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 6764: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-large);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after,[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAOA,mCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCTC,oCDaC,wCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCnBD,CCAD,qDACC,kDACD,CAEA,uBACC,+BAkED,CAhEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,qCA6CF,CA3CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAID,iGAEC,kCAAmC,CACnC,kCAAmC,CAEnC,eAAgB,CAChB,QAAS,CACT,gDAaD,CApBA,0OAcE,aAMF,CAGC,yMACC,kDACD,CDpEF", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button::after {\n	content: "";\n	width: 0;\n	position: absolute;\n	right: -1px;\n	top: var(--ck-spacing-small);\n	bottom: var(--ck-spacing-small);\n	z-index: 1;\n}\n\n.ck.ck-responsive-form {\n	@mixin ck-media-phone {\n		& .ck-button::after {\n			content: "";\n			width: 0;\n			position: absolute;\n			right: -1px;\n			top: var(--ck-spacing-small);\n			bottom: var(--ck-spacing-small);\n			z-index: 1;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n	border-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n	padding: var(--ck-spacing-large);\n\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n\n	@mixin ck-dir ltr {\n		& > :not(:first-child) {\n			margin-left: var(--ck-spacing-standard);\n		}\n	}\n\n	@mixin ck-dir rtl {\n		& > :not(:last-child) {\n			margin-left: var(--ck-spacing-standard);\n		}\n	}\n\n	@mixin ck-media-phone {\n		padding: 0;\n		width: calc(.8 * var(--ck-input-width));\n\n		& .ck-labeled-field-view {\n			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n			& .ck-input-text {\n				min-width: 0;\n				width: 100%;\n			}\n\n			/* Let the long error messages wrap in the narrow form. */\n			& .ck-labeled-field-view__error {\n				white-space: normal;\n			}\n		}\n\n		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n		& > .ck-button:nth-last-child(1),\n		& > .ck-button:nth-last-child(2) {\n			padding: var(--ck-spacing-standard);\n			margin-top: var(--ck-spacing-large);\n\n			border-radius: 0;\n			border: 0;\n			border-top: 1px solid var(--ck-color-base-border);\n\n			@mixin ck-dir ltr {\n				margin-left: 0;\n			}\n\n			@mixin ck-dir rtl {\n				margin-left: 0;\n\n				&:last-of-type {\n					border-right: 1px solid var(--ck-color-base-border);\n				}\n			}\n		}\n\n		& > .ck-button:nth-last-child(2) {\n			&::after {\n				border-right: 1px solid var(--ck-color-base-border);\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
          const a = s;
        }, 9695: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n	position: absolute;\n	z-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-block-toolbar-button: var(--ck-color-text);\n	--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n	color: var(--ck-color-block-toolbar-button);\n	font-size: var(--ck-block-toolbar-size);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 5542: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,oBAAqB,CACrB,kBA6CD,CA3CC,kCACC,YAAa,CACb,kBAAmB,CACnB,kBAAmB,CACnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eD0FD,CA7FA,qECOE,qCDsFF,CA7FA,eAGC,6CAA8C,CAC9C,iCAAkC,CAClC,+CAwFD,CAtFC,yCACC,kBAAmB,CACnB,SAAU,CACV,aAAc,CACd,yCAA0C,CAM1C,kCAAmC,CACnC,qCACD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAGC,kCAAmC,CACnC,qCACD,CAEA,mCAEC,SAgBD,CAbC,0DAEC,UAAW,CAGX,QAAS,CAGT,eAAgB,CAGhB,QACD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAvFF,qCA2FE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JACC,wBAAyB,CACzB,2BACD,CAGA,2JACC,yBAA0B,CAC1B,4BACD,CAID,qGACC,mCACD,CAGA,yLACC,mCACD,CAWA,qHACC,cACD,CAIC,6JACC,yBAA0B,CAC1B,4BACD,CAGA,2JACC,wBAAyB,CACzB,2BACD,CAID,qGACC,oCACD,CAGA,yLACC,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n	@mixin ck-unselectable;\n\n	display: flex;\n	flex-flow: row nowrap;\n	align-items: center;\n\n	& > .ck-toolbar__items {\n		display: flex;\n		flex-flow: row wrap;\n		align-items: center;\n		flex-grow: 1;\n\n	}\n\n	& .ck.ck-toolbar__separator {\n		display: inline-block;\n\n		/*\n		 * A leading or trailing separator makes no sense (separates from nothing on one side).\n		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n		 * moved to another toolbar in the dropdown.\n		 */\n		&:first-child,\n		&:last-child {\n			display: none;\n		}\n	}\n\n	& .ck-toolbar__line-break {\n		flex-basis: 100%;\n	}\n\n	&.ck-toolbar_grouping > .ck-toolbar__items {\n		flex-wrap: nowrap;\n	}\n\n	&.ck-toolbar_vertical > .ck-toolbar__items {\n		flex-direction: column;\n	}\n\n	&.ck-toolbar_floating > .ck-toolbar__items {\n		flex-wrap: nowrap;\n	}\n\n	& > .ck.ck-toolbar__grouped-dropdown {\n		& > .ck-dropdown__button .ck-dropdown__arrow {\n			display: none;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;

			/* Items in a vertical toolbar span the entire width so any border is pointless. */
			border: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 3332: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_se,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_sw{right:50%;left:auto}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_se{left:50%;right:auto}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text{right:auto;left:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after{right:auto;left:0;transform:translateX(50%)}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_e{left:calc(100% + var(--ck-tooltip-arrow-size));top:50%}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text:after{left:calc(var(--ck-tooltip-arrow-size)*-1);top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:transparent;border-bottom-color:transparent;border-right-color:var(--ck-color-tooltip-background);border-top-color:transparent;border-left-width:0;border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}.ck.ck-tooltip.ck-tooltip_w{right:calc(100% + var(--ck-tooltip-arrow-size));left:auto;top:50%}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text:after{left:100%;top:calc(50% - var(--ck-tooltip-arrow-size)*1);border-left-color:var(--ck-color-tooltip-background);border-bottom-color:transparent;border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:0;border-top-width:var(--ck-tooltip-arrow-size)}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,sDAEC,iBAAkB,CAGlB,mBAAoB,CAIpB,kCACD,CAEA,eAEC,iBAAkB,CAClB,SAAU,CACV,YAAa,CACb,yBAWD,CATC,iCACC,oBAOD,CALC,uCACC,UAAW,CACX,OAAQ,CACR,QACD,CCxBF,MACC,2BACD,CAEA,eACC,QAAS,CAMT,KAAM,CAON,sCAwKD,CAtKC,iCChBA,eDqCA,CArBA,yGCZC,qCDiCD,CArBA,iCAGC,cAAe,CACf,eAAgB,CAChB,kCAAmC,CACnC,wDAAyD,CACzD,6CAA8C,CAC9C,iBAAkB,CAClB,SAYD,CAVC,uCAMC,sCAAuC,CACvC,kBAAmB,CACnB,QACD,CAYD,sFAGC,4CAA+C,CAC/C,0BASD,CAPC,8JAEC,+CAAkD,CAClD,0BAA6B,CAC7B,6BAAoF,CAApF,sDAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,kBACD,CAaD,6BACC,SAAU,CACV,SAWD,CATC,+CACC,SAAU,CACV,2CACD,CAEA,qDACC,SAAU,CACV,OACD,CAYD,6BACC,QAAS,CACT,UAYD,CAVC,+CACC,UAAW,CACX,0CACD,CAEA,qDACC,UAAW,CACX,MAAO,CACP,yBACD,CAYD,4BACC,yCAA4C,CAC5C,2BAQD,CANC,oDACC,4CAA+C,CAC/C,0BAA6B,CAC7B,6BAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,mDAAoF,CACpF,8CAAsG,CAAtG,qBAAsG,CAAtG,+CAAsG,CAAtG,6CACD,CAUD,4BACC,8CAA+C,CAC/C,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDACC,0CAA6C,CAC7C,8CAAiD,CACjD,6BAAoF,CAApF,+BAAoF,CAApF,qDAAoF,CAApF,4BAAoF,CACpF,mBAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,6CACD,CAWF,4BACC,+CAAgD,CAChD,SAAU,CACV,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDACC,SAAU,CACV,8CAAiD,CACjD,oDAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,oBAAsG,CAAtG,6CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck.ck-tooltip,
.ck.ck-tooltip .ck-tooltip__text::after {
	position: absolute;

	/* Without this, hovering the tooltip could keep it visible. */
	pointer-events: none;

	/* This is to get rid of flickering when transitioning opacity in Chrome.
	It's weird but it works. */
	-webkit-backface-visibility: hidden;
}

.ck.ck-tooltip {
	/* Tooltip is hidden by default. */
	visibility: hidden;
	opacity: 0;
	display: none;
	z-index: var(--ck-z-modal);

	& .ck-tooltip__text {
		display: inline-block;

		&::after {
			content: "";
			width: 0;
			height: 0;
		}
	}
}
`, '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n	--ck-tooltip-arrow-size: 5px;\n}\n\n.ck.ck-tooltip {\n	left: 50%;\n\n	/*\n	 * Prevent blurry tooltips in LoDPI environments.\n	 * See https://github.com/ckeditor/ckeditor5/issues/1802.\n	 */\n	top: 0;\n\n	/*\n	 * For the transition to work, the tooltip must be controlled\n	 * using visibility+opacity. A delay prevents a "tooltip avalanche"\n	 * i.e. when scanning the toolbar with mouse cursor.\n	 */\n	transition: opacity .2s ease-in-out .2s;\n\n	& .ck-tooltip__text {\n		@mixin ck-rounded-corners;\n\n		font-size: .9em;\n		line-height: 1.5;\n		color: var(--ck-color-tooltip-text);\n		padding: var(--ck-spacing-small) var(--ck-spacing-medium);\n		background: var(--ck-color-tooltip-background);\n		position: relative;\n		left: -50%;\n\n		&::after {\n			/*\n			 * For the transition to work, the tooltip must be controlled\n			 * using visibility+opacity. A delay prevents a "tooltip avalanche"\n			 * i.e. when scanning the toolbar with mouse cursor.\n			 */\n			transition: opacity .2s ease-in-out .2s;\n			border-style: solid;\n			left: 50%;\n		}\n	}\n\n	/**\n	 * A class that displays the tooltip south of the element.\n	 *\n	 *       [element]\n	 *           ^\n	 *     +-----------+\n	 *     |  Tooltip  |\n	 *     +-----------+\n	 */\n	&.ck-tooltip_s,\n	&.ck-tooltip_sw,\n	&.ck-tooltip_se {\n		bottom: calc(-1 * var(--ck-tooltip-arrow-size));\n		transform: translateY( 100% );\n\n		& .ck-tooltip__text::after {\n			/* 1px addresses gliches in rendering causing gap between the triangle and the text */\n			top: calc(-1 * var(--ck-tooltip-arrow-size) + 1px);\n			transform: translateX( -50% );\n			border-color: transparent transparent var(--ck-color-tooltip-background) transparent;\n			border-width: 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n		}\n	}\n\n	/**\n	 * A class that displays the tooltip south-west of the element.\n	 *\n	 *        [element]\n	 *            ^\n	 *  +-----------+\n	 *  |  Tooltip  |\n	 *  +-----------+\n	 */\n\n	&.ck-tooltip_sw {\n		right: 50%;\n		left: auto;\n\n		& .ck-tooltip__text {\n			left: auto;\n			right: calc( -2 * var(--ck-tooltip-arrow-size));\n		}\n\n		& .ck-tooltip__text::after {\n			left: auto;\n			right: 0;\n		}\n	}\n\n	/**\n	 * A class that displays the tooltip south-east of the element.\n	 *\n	 *  [element]\n	 *      ^\n	 *    +-----------+\n	 *    |  Tooltip  |\n	 *    +-----------+\n	 */\n	&.ck-tooltip_se {\n		left: 50%;\n		right: auto;\n\n		& .ck-tooltip__text {\n			right: auto;\n			left: calc( -2 * var(--ck-tooltip-arrow-size));\n		}\n\n		& .ck-tooltip__text::after {\n			right: auto;\n			left: 0;\n			transform: translateX( 50% );\n		}\n	}\n\n	/**\n	 * A class that displays the tooltip north of the element.\n	 *\n	 *     +-----------+\n	 *     |  Tooltip  |\n	 *     +-----------+\n	 *           V\n	 *       [element]\n	 */\n	&.ck-tooltip_n {\n		top: calc(-1 * var(--ck-tooltip-arrow-size));\n		transform: translateY( -100% );\n\n		& .ck-tooltip__text::after {\n			bottom: calc(-1 * var(--ck-tooltip-arrow-size));\n			transform: translateX( -50% );\n			border-color: var(--ck-color-tooltip-background) transparent transparent transparent;\n			border-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);\n		}\n	}\n\n	/**\n	 * A class that displays the tooltip east of the element.\n	 *\n	 *                +----------+\n	 *    [element] < |   east   |\n	 *                +----------+\n	 */\n	&.ck-tooltip_e {\n		left: calc(100% + var(--ck-tooltip-arrow-size));\n		top: 50%;\n\n		& .ck-tooltip__text {\n			left: 0;\n			transform: translateY( -50% );\n\n			&::after {\n				left: calc(-1 * var(--ck-tooltip-arrow-size));\n				top: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n				border-color: transparent var(--ck-color-tooltip-background) transparent transparent;\n				border-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0;\n			}\n		}\n	}\n\n	/**\n	 * A class that displays the tooltip west of the element.\n	 *\n	 *    +----------+\n	 *    |   west   | > [element]\n	 *    +----------+\n	 */\n	&.ck-tooltip_w {\n		right: calc(100% + var(--ck-tooltip-arrow-size));\n		left: auto;\n		top: 50%;\n\n		& .ck-tooltip__text {\n			left: 0;\n			transform: translateY( -50% );\n\n			&::after {\n				left: 100%;\n				top: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n				border-color: transparent transparent transparent var(--ck-color-tooltip-background);\n				border-width: var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 4793: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,iDAGC,qBAAsB,CACtB,UAAW,CACX,WAAY,CACZ,eACD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAgD,CAChD,8BAAmD,CACnD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAmD,CACnD,oCAAuD,CACvD,6BAAkD,CAIlD,+CAAwD,CACxD,qEAA+E,CAC/E,qCAAwD,CACxD,sDAA8D,CAC9D,iDAAyD,CACzD,yCAAqD,CACrD,uCAAsD,CACtD,6CAA0D,CAC1D,uCAAsD,CAItD,gDAAuD,CACvD,kDAA+D,CAC/D,mDAAgE,CAChE,+CAA6D,CAC7D,yDAA8D,CAE9D,uCAAuD,CACvD,6CAA4D,CAC5D,8CAA4D,CAC5D,0CAAyD,CACzD,gDAA8D,CAE9D,+DAAsE,CACtE,iDAAkE,CAClE,kDAAkE,CAClE,8CAA+D,CAC/D,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA4D,CAC5D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAmE,CACnE,yEAA8E,CAC9E,qDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,+BAAiD,CACjD,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,wCAAwD,CACxD,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,gEAAuE,CACvE,4EAAiF,CACjF,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,wDAAmE,CACnE,mDAAgE,CCpGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJoGD,CI9FA,iDAIC,QAAS,CACT,SAAU,CACV,QAAS,CACT,sBAAuB,CACvB,oBAAqB,CACrB,qBAAsB,CACtB,eAAgB,CAGhB,oBACD,CAKA,oCAGC,wBAAyB,CACzB,iGAAkG,CAClG,0BAA2B,CAC3B,eAAgB,CAChB,kBAAmB,CACnB,WAAY,CACZ,UACD,CAGC,2BACC,gBACD,CAEA,wBAEC,sBACD,CAEA,0BACC,oBACD,CAEA,kGAGC,WACD,CAEA,gIAGC,cACD,CAEA,0BACC,YAAa,CACb,yBACD,CAEA,0CAEC,SAAU,CACV,QACD,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n	/* Override selector specificity. Otherwise, all elements with some display\n	style defined will override this one, which is not a desired result. */\n	display: none !important;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n	box-sizing: border-box;\n	width: auto;\n	height: auto;\n	position: static;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-z-default: 1;\n	--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n	transition: none !important;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-base-foreground: 								hsl(0, 0%, 98%);\n	--ck-color-base-background: 								hsl(0, 0%, 100%);\n	--ck-color-base-border: 									hsl(0, 0%, 77%);\n	--ck-color-base-action: 									hsl(104, 44%, 48%);\n	--ck-color-base-focus: 										hsl(209, 92%, 70%);\n	--ck-color-base-text: 										hsl(0, 0%, 20%);\n	--ck-color-base-active: 									hsl(208, 88%, 52%);\n	--ck-color-base-active-focus:								hsl(208, 88%, 47%);\n	--ck-color-base-error:										hsl(15, 100%, 43%);\n\n	/* -- Generic colors ------------------------------------------------------------------------ */\n\n	--ck-color-focus-border-coordinates: 						208, 79%, 51%;\n	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));\n	--ck-color-focus-outer-shadow:								hsl(207, 89%, 86%);\n	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);\n	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);\n	--ck-color-text: 											var(--ck-color-base-text);\n	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);\n	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);\n	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);\n\n	/* -- Buttons ------------------------------------------------------------------------------- */\n\n	--ck-color-button-default-background: 						transparent;\n	--ck-color-button-default-hover-background: 				hsl(0, 0%, 90%);\n	--ck-color-button-default-active-background: 				hsl(0, 0%, 85%);\n	--ck-color-button-default-active-shadow: 					hsl(0, 0%, 75%);\n	--ck-color-button-default-disabled-background: 				transparent;\n\n	--ck-color-button-on-background: 							hsl(0, 0%, 87%);\n	--ck-color-button-on-hover-background: 						hsl(0, 0%, 77%);\n	--ck-color-button-on-active-background: 					hsl(0, 0%, 73%);\n	--ck-color-button-on-active-shadow: 						hsl(0, 0%, 63%);\n	--ck-color-button-on-disabled-background: 					hsl(0, 0%, 87%);\n\n	--ck-color-button-action-background: 						var(--ck-color-base-action);\n	--ck-color-button-action-hover-background: 					hsl(104, 44%, 43%);\n	--ck-color-button-action-active-background: 				hsl(104, 44%, 41%);\n	--ck-color-button-action-active-shadow: 					hsl(104, 44%, 36%);\n	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);\n	--ck-color-button-action-text: 								var(--ck-color-base-background);\n\n	--ck-color-button-save: 									hsl(120, 100%, 27%);\n	--ck-color-button-cancel: 									hsl(15, 100%, 43%);\n\n	--ck-color-switch-button-off-background:					hsl(0, 0%, 69%);\n	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 64%);\n	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);\n	--ck-color-switch-button-on-hover-background:				hsl(104, 44%, 43%);\n	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);\n	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);\n\n	/* -- Dropdown ------------------------------------------------------------------------------ */\n\n	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);\n	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);\n\n	/* -- Input --------------------------------------------------------------------------------- */\n\n	--ck-color-input-background: 								var(--ck-color-base-background);\n	--ck-color-input-border: 									hsl(0, 0%, 78%);\n	--ck-color-input-error-border:								var(--ck-color-base-error);\n	--ck-color-input-text: 										var(--ck-color-base-text);\n	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);\n	--ck-color-input-disabled-border: 							hsl(0, 0%, 78%);\n	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);\n\n	/* -- List ---------------------------------------------------------------------------------- */\n\n	--ck-color-list-background: 								var(--ck-color-base-background);\n	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);\n	--ck-color-list-button-on-background: 						var(--ck-color-base-active);\n	--ck-color-list-button-on-background-focus: 				var(--ck-color-base-active-focus);\n	--ck-color-list-button-on-text:								var(--ck-color-base-background);\n\n	/* -- Panel --------------------------------------------------------------------------------- */\n\n	--ck-color-panel-background: 								var(--ck-color-base-background);\n	--ck-color-panel-border: 									var(--ck-color-base-border);\n\n	/* -- Toolbar ------------------------------------------------------------------------------- */\n\n	--ck-color-toolbar-background: 								var(--ck-color-base-foreground);\n	--ck-color-toolbar-border: 									var(--ck-color-base-border);\n\n	/* -- Tooltip ------------------------------------------------------------------------------- */\n\n	--ck-color-tooltip-background: 								var(--ck-color-base-text);\n	--ck-color-tooltip-text: 									var(--ck-color-base-background);\n\n	/* -- Engine -------------------------------------------------------------------------------- */\n\n	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);\n\n	/* -- Upload -------------------------------------------------------------------------------- */\n\n	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);\n\n	/* -- Link -------------------------------------------------------------------------------- */\n\n	--ck-color-link-default:									hsl(240, 100%, 47%);\n	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);\n	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * An opacity value of disabled UI item.\n	 */\n	--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * The geometry of the of focused element's outer shadow.\n	 */\n	--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n	/**\n	 * A visual style of focused element's outer shadow.\n	 */\n	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n	/**\n	 * A visual style of focused element's outer shadow (when disabled).\n	 */\n	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n	/**\n	 * A visual style of focused element's outer shadow (when has errors).\n	 */\n	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n	/**\n	 * A visual style of focused element's border or outline.\n	 */\n	--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-font-size-base: 13px;\n	--ck-line-height-base: 1.84615;\n	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n	--ck-font-size-tiny: 0.7em;\n	--ck-font-size-small: 0.75em;\n	--ck-font-size-normal: 1em;\n	--ck-font-size-big: 1.4em;\n	--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* This is super-important. This is **manually** adjusted so a button without an icon\n	is never smaller than a button with icon, additionally making sure that text-less buttons\n	are perfect squares. The value is also shared by other components which should stay "in-line"\n	with buttons. */\n	--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n	/* Do not include inheritable rules here. */\n	margin: 0;\n	padding: 0;\n	border: 0;\n	background: transparent;\n	text-decoration: none;\n	vertical-align: middle;\n	transition: none;\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n	word-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n	/* These are rule inherited by all children elements. */\n	border-collapse: collapse;\n	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n	color: var(--ck-color-text);\n	text-align: left;\n	white-space: nowrap;\n	cursor: auto;\n	float: none;\n}\n\n.ck.ck-reset_all {\n	& .ck-rtl * {\n		text-align: right;\n	}\n\n	& iframe {\n		/* For IE */\n		vertical-align: inherit;\n	}\n\n	& textarea {\n		white-space: pre-wrap;\n	}\n\n	& textarea,\n	& input[type="text"],\n	& input[type="password"] {\n		cursor: text;\n	}\n\n	& textarea[disabled],\n	& input[type="text"][disabled],\n	& input[type="password"][disabled] {\n		cursor: default;\n	}\n\n	& fieldset {\n		padding: 10px;\n		border: 2px groove hsl(255, 7%, 88%);\n	}\n\n	& button::-moz-focus-inner {\n		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n		padding: 0;\n		border: 0\n	}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n	text-align: right;\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n	--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * A visual style of element's inner shadow (i.e. input).\n	 */\n	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n	/**\n	 * A visual style of element's drop shadow (i.e. panel).\n	 */\n	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n	/**\n	 * A visual style of element's active shadow (i.e. comment or suggestion).\n	 */\n	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-spacing-unit: 						0.6em;\n	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);\n	--ck-spacing-standard: 					var(--ck-spacing-unit);\n	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);\n	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);\n	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);\n	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 3488: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:0 var(--ck-spacing-small);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{top:calc(var(--ck-resizer-tooltip-height)*-1);left:50%;transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness));top:0}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CACtD,0CAA2C,CAC3C,qDAAsD,CACtD,6CAA8C,CAC9C,kCAAmC,CACnC,aAAc,CACd,iCAAkC,CAClC,uCAAwC,CACxC,4CAoCD,CAlCC,8NAKC,iBACD,CAEA,0CACC,oCAAqC,CACrC,qCACD,CAEA,2CACC,oCAAqC,CACrC,sCACD,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CACC,6CAAgD,CAChD,QAAS,CACT,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eACC,gDAAiD,CACjD,mBAAoB,CACpB,yBAA0B,CAC1B,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGC/BA,YAAa,CACb,2BAA2B,CCF3B,qCAA8B,CFqC7B,iEACD,CAIA,4EACC,WAAY,CACZ,qBAAsB,CAGtB,4BAA6B,CAC7B,SAAU,CAMV,6SAG6F,CAG7F,iEAAkE,CAGlE,2BAA4B,CAC5B,mDAAoD,CACpD,KAqBD,CAnBC,qFAEC,wCAAyC,CACzC,yCAA0C,CAC1C,oDASD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFACC,SAAU,CACV,oDACD,CAKC,oMACC,SAAU,CACV,6CAMD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-resizer: var(--ck-color-focus-border);\n	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n	--ck-resizer-border-radius: var(--ck-border-radius);\n	--ck-resizer-tooltip-offset: 10px;\n	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n	/* This is neccessary for type around UI to be positioned properly. */\n	position: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n	/* Make the widget wrapper a relative positioning container for the drag handle. */\n	position: relative;\n\n	& .ck-widget__selection-handle {\n		position: absolute;\n\n		& .ck-icon {\n			/* Make sure the icon in not a subject to font-size or line-height to avoid\n			unnecessary spacing around it. */\n			display: block;\n		}\n	}\n\n	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n	&:hover > .ck-widget__selection-handle {\n		visibility: visible;\n	}\n\n	/* Show the selection handle when the widget is selected, but not for nested widgets. */\n	&.ck-widget_selected > .ck-widget__selection-handle {\n		visibility: visible;\n	}\n}\n\n.ck .ck-size-view {\n	background: var(--ck-color-resizer-tooltip-background);\n	color: var(--ck-color-resizer-tooltip-text);\n	border: 1px solid var(--ck-color-resizer-tooltip-text);\n	border-radius: var(--ck-resizer-border-radius);\n	font-size: var(--ck-font-size-tiny);\n	display: block;\n	padding: 0 var(--ck-spacing-small);\n	height: var(--ck-resizer-tooltip-height);\n	line-height: var(--ck-resizer-tooltip-height);\n\n	&.ck-orientation-top-left,\n	&.ck-orientation-top-right,\n	&.ck-orientation-bottom-right,\n	&.ck-orientation-bottom-left,\n	&.ck-orientation-above-center {\n		position: absolute;\n	}\n\n	&.ck-orientation-top-left {\n		top: var(--ck-resizer-tooltip-offset);\n		left: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-top-right {\n		top: var(--ck-resizer-tooltip-offset);\n		right: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-bottom-right {\n		bottom: var(--ck-resizer-tooltip-offset);\n		right: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-bottom-left {\n		bottom: var(--ck-resizer-tooltip-offset);\n		left: var(--ck-resizer-tooltip-offset);\n	}\n\n	/* Class applied if the widget is too small to contain the size label */\n	&.ck-orientation-above-center {\n		top: calc(var(--ck-resizer-tooltip-height) * -1);\n		left: 50%;\n		transform: translate(-50%);\n	}\n}\n", '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n	--ck-widget-outline-thickness: 3px;\n	--ck-widget-handler-icon-size: 16px;\n	--ck-widget-handler-animation-duration: 200ms;\n	--ck-widget-handler-animation-curve: ease;\n\n	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n	--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n	outline-width: var(--ck-widget-outline-thickness);\n	outline-style: solid;\n	outline-color: transparent;\n	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n	}\n\n	&:hover {\n		outline-color: var(--ck-color-widget-hover-border);\n	}\n}\n\n.ck .ck-editor__nested-editable {\n	border: 1px solid transparent;\n\n	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n	These styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n	&.ck-editor__nested-editable_focused,\n	&:focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n\n		background-color: var(--ck-color-widget-editable-focus-background);\n	}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n	& .ck-widget__selection-handle {\n		padding: 4px;\n		box-sizing: border-box;\n\n		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n		background-color: transparent;\n		opacity: 0;\n\n		/* Transition:\n		   * background-color for the .ck-widget_selected state change,\n		   * visibility for hiding the handler,\n		   * opacity for the proper look of the icon when the handler disappears. */\n		transition:\n			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n		/* Make only top corners round. */\n		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n		/* Place the drag handler outside the widget wrapper. */\n		transform: translateY(-100%);\n		left: calc(0px - var(--ck-widget-outline-thickness));\n		top: 0;\n\n		& .ck-icon {\n			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n			width: var(--ck-widget-handler-icon-size);\n			height: var(--ck-widget-handler-icon-size);\n			color: var(--ck-color-widget-drag-handler-icon-color);\n\n			/* The "selected" part of the icon is invisible by default */\n			& .ck-icon__selected-indicator {\n				opacity: 0;\n\n				/* Note: The animation is longer on purpose. Simply feels better. */\n				transition: opacity 300ms var(--ck-widget-handler-animation-curve);\n			}\n		}\n\n		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n		&:hover .ck-icon .ck-icon__selected-indicator {\n			opacity: 1;\n		}\n	}\n\n	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n	&:hover > .ck-widget__selection-handle {\n		opacity: 1;\n		background-color: var(--ck-color-widget-hover-border);\n	}\n\n	/* Show the selection handler when the widget is selected, but not for nested widgets. */\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		& > .ck-widget__selection-handle {\n			opacity: 1;\n			background-color: var(--ck-color-focus-border);\n\n			/* When the widget is selected, notify the user using the proper look of the icon. */\n			& .ck-icon .ck-icon__selected-indicator {\n				opacity: 1;\n			}\n		}\n	}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n	left: auto;\n	right: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n	/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n	transition: none;\n\n	&:not(.ck-widget_selected) {\n		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n		 * See: https://github.com/ckeditor/ckeditor5/issues/1261\n		 *\n		 * Leave the unit because this custom property is used in calc() by other features.\n		 * See: https://github.com/ckeditor/ckeditor5/issues/6775\n		 */\n		--ck-widget-outline-thickness: 0px;\n	}\n\n	&.ck-widget_with-selection-handle {\n		& .ck-widget__selection-handle,\n		& .ck-widget__selection-handle:hover {\n			background: var(--ck-color-widget-blurred-border);\n		}\n	}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		outline-color: var(--ck-color-widget-blurred-border);\n\n		&.ck-widget_with-selection-handle {\n			& > .ck-widget__selection-handle,\n			& > .ck-widget__selection-handle:hover {\n				background: var(--ck-color-widget-blurred-border);\n			}\n		}\n	}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n	In fact, anything with overflow: hidden.\n	https://github.com/ckeditor/ckeditor5-block-quote/issues/28\n	https://github.com/ckeditor/ckeditor5-widget/issues/44\n	https://github.com/ckeditor/ckeditor5-widget/issues/66 */\n	margin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 8506: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CACb,iBAAkB,CAGlB,mBAAoB,CAEpB,MAAO,CACP,KACD,CAGC,2EACC,aACD,CAGD,gCACC,iBAAkB,CAGlB,kBAWD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCACC,4BAA6B,CAC7B,6BAA8B,CAC9B,uCAAwC,CACxC,gDAA6D,CAC7D,6CAqBD,CAnBC,oEACC,4BAA6B,CAC7B,6BACD,CAEA,qEACC,4BAA6B,CAC7B,8BACD,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n	/* Make the widget wrapper a relative positioning container for the drag handle. */\n	position: relative;\n}\n\n.ck .ck-widget__resizer {\n	display: none;\n	position: absolute;\n\n	/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n	pointer-events: none;\n\n	left: 0;\n	top: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n	& > .ck-widget__resizer {\n		display: block;\n	}\n}\n\n.ck .ck-widget__resizer__handle {\n	position: absolute;\n\n	/* Resizers are the only UI elements that should interfere with a pointer device. */\n	pointer-events: all;\n\n	&.ck-widget__resizer__handle-top-left,\n	&.ck-widget__resizer__handle-bottom-right {\n		cursor: nwse-resize;\n	}\n\n	&.ck-widget__resizer__handle-top-right,\n	&.ck-widget__resizer__handle-bottom-left {\n		cursor: nesw-resize;\n	}\n}\n", "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-resizer-size: 10px;\n\n	/* Set the resizer with a 50% offset. */\n	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n	--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n	outline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n	width: var(--ck-resizer-size);\n	height: var(--ck-resizer-size);\n	background: var(--ck-color-focus-border);\n	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n	border-radius: var(--ck-resizer-border-radius);\n\n	&.ck-widget__resizer__handle-top-left {\n		top: var(--ck-resizer-offset);\n		left: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-top-right {\n		top: var(--ck-resizer-offset);\n		right: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-bottom-right {\n		bottom: var(--ck-resizer-offset);\n		right: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-bottom-left {\n		bottom: var(--ck-resizer-offset);\n		left: var(--ck-resizer-offset);\n	}\n}\n"], sourceRoot: "" }]);
          const a = s;
        }, 4921: (t2, e2, n2) => {
          n2.d(e2, { Z: () => a });
          var o2 = n2(1799), i = n2.n(o2), r = n2(2609), s = n2.n(r)()(i());
          s.push([t2.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CACd,iBAAkB,CAClB,eAAgB,CAChB,2BAwBD,CAtBC,mDACC,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAEA,qFAEC,iDAAoD,CACpD,kBAAoB,CAEpB,0BACD,CAEA,oFAEC,oDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CACd,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAMD,2EACC,YAAa,CACb,iBAAkB,CAClB,MAAO,CACP,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHACC,qDAA0D,CAC1D,aACD,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CACC,8CAA+C,CAC/C,+CAAgD,CAChD,oDAAqD,CACrD,mBAAoB,CACpB,uMAAyM,CAb1M,SAAU,CACV,mBA0DA,CA1CC,mDACC,UAAW,CACX,UAAW,CACX,8BAA+B,CAC/B,6BAA8B,CAC9B,cAgBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLACC,0DAA2D,CAC3D,2DAA4D,CAC5D,mBAAoB,CACpB,uEACD,CAOD,8GACC,gBACD,CAKA,mDACC,mBAAoB,CACpB,UAAW,CACX,mFAAoF,CAMpF,oCAAwC,CACxC,oCACD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,0jBACC,SACD,CASF,mPACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`], sourceRoot: "" }]);
          const a = s;
        }, 2609: (t2) => {
          t2.exports = function(t3) {
            var e2 = [];
            return e2.toString = function() {
              return this.map(function(e3) {
                var n2 = t3(e3);
                return e3[2] ? "@media ".concat(e3[2], " {").concat(n2, "}") : n2;
              }).join("");
            }, e2.i = function(t4, n2, o2) {
              "string" == typeof t4 && (t4 = [[null, t4, ""]]);
              var i = {};
              if (o2)
                for (var r = 0; r < this.length; r++) {
                  var s = this[r][0];
                  null != s && (i[s] = true);
                }
              for (var a = 0; a < t4.length; a++) {
                var c = [].concat(t4[a]);
                o2 && i[c[0]] || (n2 && (c[2] ? c[2] = "".concat(n2, " and ").concat(c[2]) : c[2] = n2), e2.push(c));
              }
            }, e2;
          };
        }, 1799: (t2) => {
          function e2(t3, e3) {
            return function(t4) {
              if (Array.isArray(t4))
                return t4;
            }(t3) || function(t4, e4) {
              var n3 = t4 && ("undefined" != typeof Symbol && t4[Symbol.iterator] || t4["@@iterator"]);
              if (null == n3)
                return;
              var o2, i, r = [], s = true, a = false;
              try {
                for (n3 = n3.call(t4); !(s = (o2 = n3.next()).done) && (r.push(o2.value), !e4 || r.length !== e4); s = true)
                  ;
              } catch (t5) {
                a = true, i = t5;
              } finally {
                try {
                  s || null == n3.return || n3.return();
                } finally {
                  if (a)
                    throw i;
                }
              }
              return r;
            }(t3, e3) || function(t4, e4) {
              if (!t4)
                return;
              if ("string" == typeof t4)
                return n2(t4, e4);
              var o2 = Object.prototype.toString.call(t4).slice(8, -1);
              "Object" === o2 && t4.constructor && (o2 = t4.constructor.name);
              if ("Map" === o2 || "Set" === o2)
                return Array.from(t4);
              if ("Arguments" === o2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o2))
                return n2(t4, e4);
            }(t3, e3) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function n2(t3, e3) {
            (null == e3 || e3 > t3.length) && (e3 = t3.length);
            for (var n3 = 0, o2 = new Array(e3); n3 < e3; n3++)
              o2[n3] = t3[n3];
            return o2;
          }
          t2.exports = function(t3) {
            var n3 = e2(t3, 4), o2 = n3[1], i = n3[3];
            if (!i)
              return o2;
            if ("function" == typeof btoa) {
              var r = btoa(unescape(encodeURIComponent(JSON.stringify(i)))), s = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r), a = "/*# ".concat(s, " */"), c = i.sources.map(function(t4) {
                return "/*# sourceURL=".concat(i.sourceRoot || "").concat(t4, " */");
              });
              return [o2].concat(c).concat([a]).join("\n");
            }
            return [o2].join("\n");
          };
        }, 6062: (t2, e2, n2) => {
          var o2, i = function() {
            return void 0 === o2 && (o2 = Boolean(window && document && document.all && !window.atob)), o2;
          }, r = function() {
            var t3 = {};
            return function(e3) {
              if (void 0 === t3[e3]) {
                var n3 = document.querySelector(e3);
                if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
                  try {
                    n3 = n3.contentDocument.head;
                  } catch (t4) {
                    n3 = null;
                  }
                t3[e3] = n3;
              }
              return t3[e3];
            };
          }(), s = [];
          function a(t3) {
            for (var e3 = -1, n3 = 0; n3 < s.length; n3++)
              if (s[n3].identifier === t3) {
                e3 = n3;
                break;
              }
            return e3;
          }
          function c(t3, e3) {
            for (var n3 = {}, o3 = [], i2 = 0; i2 < t3.length; i2++) {
              var r2 = t3[i2], c2 = e3.base ? r2[0] + e3.base : r2[0], l2 = n3[c2] || 0, d2 = "".concat(c2, " ").concat(l2);
              n3[c2] = l2 + 1;
              var h2 = a(d2), u2 = { css: r2[1], media: r2[2], sourceMap: r2[3] };
              -1 !== h2 ? (s[h2].references++, s[h2].updater(u2)) : s.push({ identifier: d2, updater: f(u2, e3), references: 1 }), o3.push(d2);
            }
            return o3;
          }
          function l(t3) {
            var e3 = document.createElement("style"), o3 = t3.attributes || {};
            if (void 0 === o3.nonce) {
              var i2 = n2.nc;
              i2 && (o3.nonce = i2);
            }
            if (Object.keys(o3).forEach(function(t4) {
              e3.setAttribute(t4, o3[t4]);
            }), "function" == typeof t3.insert)
              t3.insert(e3);
            else {
              var s2 = r(t3.insert || "head");
              if (!s2)
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
              s2.appendChild(e3);
            }
            return e3;
          }
          var d, h = (d = [], function(t3, e3) {
            return d[t3] = e3, d.filter(Boolean).join("\n");
          });
          function u(t3, e3, n3, o3) {
            var i2 = n3 ? "" : o3.media ? "@media ".concat(o3.media, " {").concat(o3.css, "}") : o3.css;
            if (t3.styleSheet)
              t3.styleSheet.cssText = h(e3, i2);
            else {
              var r2 = document.createTextNode(i2), s2 = t3.childNodes;
              s2[e3] && t3.removeChild(s2[e3]), s2.length ? t3.insertBefore(r2, s2[e3]) : t3.appendChild(r2);
            }
          }
          function g(t3, e3, n3) {
            var o3 = n3.css, i2 = n3.media, r2 = n3.sourceMap;
            if (i2 ? t3.setAttribute("media", i2) : t3.removeAttribute("media"), r2 && "undefined" != typeof btoa && (o3 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r2)))), " */")), t3.styleSheet)
              t3.styleSheet.cssText = o3;
            else {
              for (; t3.firstChild; )
                t3.removeChild(t3.firstChild);
              t3.appendChild(document.createTextNode(o3));
            }
          }
          var m = null, p = 0;
          function f(t3, e3) {
            var n3, o3, i2;
            if (e3.singleton) {
              var r2 = p++;
              n3 = m || (m = l(e3)), o3 = u.bind(null, n3, r2, false), i2 = u.bind(null, n3, r2, true);
            } else
              n3 = l(e3), o3 = g.bind(null, n3, e3), i2 = function() {
                !function(t4) {
                  if (null === t4.parentNode)
                    return false;
                  t4.parentNode.removeChild(t4);
                }(n3);
              };
            return o3(t3), function(e4) {
              if (e4) {
                if (e4.css === t3.css && e4.media === t3.media && e4.sourceMap === t3.sourceMap)
                  return;
                o3(t3 = e4);
              } else
                i2();
            };
          }
          t2.exports = function(t3, e3) {
            (e3 = e3 || {}).singleton || "boolean" == typeof e3.singleton || (e3.singleton = i());
            var n3 = c(t3 = t3 || [], e3);
            return function(t4) {
              if (t4 = t4 || [], "[object Array]" === Object.prototype.toString.call(t4)) {
                for (var o3 = 0; o3 < n3.length; o3++) {
                  var i2 = a(n3[o3]);
                  s[i2].references--;
                }
                for (var r2 = c(t4, e3), l2 = 0; l2 < n3.length; l2++) {
                  var d2 = a(n3[l2]);
                  0 === s[d2].references && (s[d2].updater(), s.splice(d2, 1));
                }
                n3 = r2;
              }
            };
          };
        } }, e = {};
        function n(o2) {
          var i = e[o2];
          if (void 0 !== i)
            return i.exports;
          var r = e[o2] = { id: o2, exports: {} };
          return t[o2](r, r.exports, n), r.exports;
        }
        n.n = (t2) => {
          var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
          return n.d(e2, { a: e2 }), e2;
        }, n.d = (t2, e2) => {
          for (var o2 in e2)
            n.o(e2, o2) && !n.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
        }, n.g = function() {
          if ("object" == typeof globalThis)
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t2) {
            if ("object" == typeof window)
              return window;
          }
        }(), n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
        var o = {};
        return (() => {
          n.d(o, { default: () => _A });
          const t2 = function() {
            return function t3() {
              t3.called = true;
            };
          };
          class e2 {
            constructor(e3, n2) {
              this.source = e3, this.name = n2, this.path = [], this.stop = t2(), this.off = t2();
            }
          }
          const i = new Array(256).fill().map((t3, e3) => ("0" + e3.toString(16)).slice(-2));
          function r() {
            const t3 = 4294967296 * Math.random() >>> 0, e3 = 4294967296 * Math.random() >>> 0, n2 = 4294967296 * Math.random() >>> 0, o2 = 4294967296 * Math.random() >>> 0;
            return "e" + i[t3 >> 0 & 255] + i[t3 >> 8 & 255] + i[t3 >> 16 & 255] + i[t3 >> 24 & 255] + i[e3 >> 0 & 255] + i[e3 >> 8 & 255] + i[e3 >> 16 & 255] + i[e3 >> 24 & 255] + i[n2 >> 0 & 255] + i[n2 >> 8 & 255] + i[n2 >> 16 & 255] + i[n2 >> 24 & 255] + i[o2 >> 0 & 255] + i[o2 >> 8 & 255] + i[o2 >> 16 & 255] + i[o2 >> 24 & 255];
          }
          const s = { get(t3) {
            return "number" != typeof t3 ? this[t3] || this.normal : t3;
          }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
          class a extends Error {
            constructor(t3, e3, n2) {
              super(function(t4, e4) {
                const n3 = /* @__PURE__ */ new WeakSet(), o2 = (t5, e5) => {
                  if ("object" == typeof e5 && null !== e5) {
                    if (n3.has(e5))
                      return `[object ${e5.constructor.name}]`;
                    n3.add(e5);
                  }
                  return e5;
                }, i2 = e4 ? ` ${JSON.stringify(e4, o2)}` : "", r2 = l(t4);
                return t4 + i2 + r2;
              }(t3, n2)), this.name = "CKEditorError", this.context = e3, this.data = n2;
            }
            is(t3) {
              return "CKEditorError" === t3;
            }
            static rethrowUnexpectedError(t3, e3) {
              if (t3.is && t3.is("CKEditorError"))
                throw t3;
              const n2 = new a(t3.message, e3);
              throw n2.stack = t3.stack, n2;
            }
          }
          function c(t3, e3) {
            console.warn(...d(t3, e3));
          }
          function l(t3) {
            return `
Read more: https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html#error-${t3}`;
          }
          function d(t3, e3) {
            const n2 = l(t3);
            return e3 ? [t3, e3, n2] : [t3, n2];
          }
          const h = "33.0.0", u = "object" == typeof window ? window : n.g;
          if (u.CKEDITOR_VERSION)
            throw new a("ckeditor-duplicated-modules", null);
          u.CKEDITOR_VERSION = h;
          const g = Symbol("listeningTo"), m = Symbol("emitterId"), p = { on(t3, e3, n2 = {}) {
            this.listenTo(this, t3, e3, n2);
          }, once(t3, e3, n2) {
            let o2 = false;
            this.listenTo(this, t3, function(t4, ...n3) {
              o2 || (o2 = true, t4.off(), e3.call(this, t4, ...n3));
            }, n2);
          }, off(t3, e3) {
            this.stopListening(this, t3, e3);
          }, listenTo(t3, e3, n2, o2 = {}) {
            let i2, r2;
            this[g] || (this[g] = {});
            const s2 = this[g];
            b(t3) || k(t3);
            const a2 = b(t3);
            (i2 = s2[a2]) || (i2 = s2[a2] = { emitter: t3, callbacks: {} }), (r2 = i2.callbacks[e3]) || (r2 = i2.callbacks[e3] = []), r2.push(n2), function(t4, e4, n3, o3, i3) {
              e4._addEventListener ? e4._addEventListener(n3, o3, i3) : t4._addEventListener.call(e4, n3, o3, i3);
            }(this, t3, e3, n2, o2);
          }, stopListening(t3, e3, n2) {
            const o2 = this[g];
            let i2 = t3 && b(t3);
            const r2 = o2 && i2 && o2[i2], s2 = r2 && e3 && r2.callbacks[e3];
            if (!(!o2 || t3 && !r2 || e3 && !s2))
              if (n2) {
                v(this, t3, e3, n2);
                -1 !== s2.indexOf(n2) && (1 === s2.length ? delete r2.callbacks[e3] : v(this, t3, e3, n2));
              } else if (s2) {
                for (; n2 = s2.pop(); )
                  v(this, t3, e3, n2);
                delete r2.callbacks[e3];
              } else if (r2) {
                for (e3 in r2.callbacks)
                  this.stopListening(t3, e3);
                delete o2[i2];
              } else {
                for (i2 in o2)
                  this.stopListening(o2[i2].emitter);
                delete this[g];
              }
          }, fire(t3, ...n2) {
            try {
              const o2 = t3 instanceof e2 ? t3 : new e2(this, t3), i2 = o2.name;
              let r2 = A(this, i2);
              if (o2.path.push(this), r2) {
                const t4 = [o2, ...n2];
                r2 = Array.from(r2);
                for (let e3 = 0; e3 < r2.length && (r2[e3].callback.apply(this, t4), o2.off.called && (delete o2.off.called, this._removeEventListener(i2, r2[e3].callback)), !o2.stop.called); e3++)
                  ;
              }
              if (this._delegations) {
                const t4 = this._delegations.get(i2), e3 = this._delegations.get("*");
                t4 && _(t4, o2, n2), e3 && _(e3, o2, n2);
              }
              return o2.return;
            } catch (t4) {
              a.rethrowUnexpectedError(t4, this);
            }
          }, delegate(...t3) {
            return { to: (e3, n2) => {
              this._delegations || (this._delegations = /* @__PURE__ */ new Map()), t3.forEach((t4) => {
                const o2 = this._delegations.get(t4);
                o2 ? o2.set(e3, n2) : this._delegations.set(t4, /* @__PURE__ */ new Map([[e3, n2]]));
              });
            } };
          }, stopDelegating(t3, e3) {
            if (this._delegations)
              if (t3)
                if (e3) {
                  const n2 = this._delegations.get(t3);
                  n2 && n2.delete(e3);
                } else
                  this._delegations.delete(t3);
              else
                this._delegations.clear();
          }, _addEventListener(t3, e3, n2) {
            !function(t4, e4) {
              const n3 = w(t4);
              if (n3[e4])
                return;
              let o3 = e4, i3 = null;
              const r3 = [];
              for (; "" !== o3 && !n3[o3]; )
                n3[o3] = { callbacks: [], childEvents: [] }, r3.push(n3[o3]), i3 && n3[o3].childEvents.push(i3), i3 = o3, o3 = o3.substr(0, o3.lastIndexOf(":"));
              if ("" !== o3) {
                for (const t5 of r3)
                  t5.callbacks = n3[o3].callbacks.slice();
                n3[o3].childEvents.push(i3);
              }
            }(this, t3);
            const o2 = C(this, t3), i2 = s.get(n2.priority), r2 = { callback: e3, priority: i2 };
            for (const t4 of o2) {
              let e4 = false;
              for (let n3 = 0; n3 < t4.length; n3++)
                if (t4[n3].priority < i2) {
                  t4.splice(n3, 0, r2), e4 = true;
                  break;
                }
              e4 || t4.push(r2);
            }
          }, _removeEventListener(t3, e3) {
            const n2 = C(this, t3);
            for (const t4 of n2)
              for (let n3 = 0; n3 < t4.length; n3++)
                t4[n3].callback == e3 && (t4.splice(n3, 1), n3--);
          } }, f = p;
          function k(t3, e3) {
            t3[m] || (t3[m] = e3 || r());
          }
          function b(t3) {
            return t3[m];
          }
          function w(t3) {
            return t3._events || Object.defineProperty(t3, "_events", { value: {} }), t3._events;
          }
          function C(t3, e3) {
            const n2 = w(t3)[e3];
            if (!n2)
              return [];
            let o2 = [n2.callbacks];
            for (let e4 = 0; e4 < n2.childEvents.length; e4++) {
              const i2 = C(t3, n2.childEvents[e4]);
              o2 = o2.concat(i2);
            }
            return o2;
          }
          function A(t3, e3) {
            let n2;
            return t3._events && (n2 = t3._events[e3]) && n2.callbacks.length ? n2.callbacks : e3.indexOf(":") > -1 ? A(t3, e3.substr(0, e3.lastIndexOf(":"))) : null;
          }
          function _(t3, n2, o2) {
            for (let [i2, r2] of t3) {
              r2 ? "function" == typeof r2 && (r2 = r2(n2.name)) : r2 = n2.name;
              const t4 = new e2(n2.source, r2);
              t4.path = [...n2.path], i2.fire(t4, ...o2);
            }
          }
          function v(t3, e3, n2, o2) {
            e3._removeEventListener ? e3._removeEventListener(n2, o2) : t3._removeEventListener.call(e3, n2, o2);
          }
          const y = function(t3) {
            var e3 = typeof t3;
            return null != t3 && ("object" == e3 || "function" == e3);
          };
          const x = "object" == typeof global && global && global.Object === Object && global;
          var E = "object" == typeof self && self && self.Object === Object && self;
          const D = x || E || Function("return this")();
          const I = D.Symbol;
          var M = Object.prototype, S = M.hasOwnProperty, T = M.toString, N = I ? I.toStringTag : void 0;
          const B = function(t3) {
            var e3 = S.call(t3, N), n2 = t3[N];
            try {
              t3[N] = void 0;
              var o2 = true;
            } catch (t4) {
            }
            var i2 = T.call(t3);
            return o2 && (e3 ? t3[N] = n2 : delete t3[N]), i2;
          };
          var z = Object.prototype.toString;
          const P = function(t3) {
            return z.call(t3);
          };
          var L = I ? I.toStringTag : void 0;
          const O = function(t3) {
            return null == t3 ? void 0 === t3 ? "[object Undefined]" : "[object Null]" : L && L in Object(t3) ? B(t3) : P(t3);
          };
          const R = function(t3) {
            if (!y(t3))
              return false;
            var e3 = O(t3);
            return "[object Function]" == e3 || "[object GeneratorFunction]" == e3 || "[object AsyncFunction]" == e3 || "[object Proxy]" == e3;
          };
          const j = D["__core-js_shared__"];
          var F = function() {
            var t3 = /[^.]+$/.exec(j && j.keys && j.keys.IE_PROTO || "");
            return t3 ? "Symbol(src)_1." + t3 : "";
          }();
          const V = function(t3) {
            return !!F && F in t3;
          };
          var U = Function.prototype.toString;
          const H = function(t3) {
            if (null != t3) {
              try {
                return U.call(t3);
              } catch (t4) {
              }
              try {
                return t3 + "";
              } catch (t4) {
              }
            }
            return "";
          };
          var q = /^\[object .+?Constructor\]$/, W = Function.prototype, G = Object.prototype, Y = W.toString, Q = G.hasOwnProperty, K = RegExp("^" + Y.call(Q).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          const $ = function(t3) {
            return !(!y(t3) || V(t3)) && (R(t3) ? K : q).test(H(t3));
          };
          const Z = function(t3, e3) {
            return null == t3 ? void 0 : t3[e3];
          };
          const J = function(t3, e3) {
            var n2 = Z(t3, e3);
            return $(n2) ? n2 : void 0;
          };
          const X = function() {
            try {
              var t3 = J(Object, "defineProperty");
              return t3({}, "", {}), t3;
            } catch (t4) {
            }
          }();
          const tt = function(t3, e3, n2) {
            "__proto__" == e3 && X ? X(t3, e3, { configurable: true, enumerable: true, value: n2, writable: true }) : t3[e3] = n2;
          };
          const et = function(t3, e3) {
            return t3 === e3 || t3 != t3 && e3 != e3;
          };
          var nt = Object.prototype.hasOwnProperty;
          const ot = function(t3, e3, n2) {
            var o2 = t3[e3];
            nt.call(t3, e3) && et(o2, n2) && (void 0 !== n2 || e3 in t3) || tt(t3, e3, n2);
          };
          const it = function(t3, e3, n2, o2) {
            var i2 = !n2;
            n2 || (n2 = {});
            for (var r2 = -1, s2 = e3.length; ++r2 < s2; ) {
              var a2 = e3[r2], c2 = o2 ? o2(n2[a2], t3[a2], a2, n2, t3) : void 0;
              void 0 === c2 && (c2 = t3[a2]), i2 ? tt(n2, a2, c2) : ot(n2, a2, c2);
            }
            return n2;
          };
          const rt = function(t3) {
            return t3;
          };
          const st = function(t3, e3, n2) {
            switch (n2.length) {
              case 0:
                return t3.call(e3);
              case 1:
                return t3.call(e3, n2[0]);
              case 2:
                return t3.call(e3, n2[0], n2[1]);
              case 3:
                return t3.call(e3, n2[0], n2[1], n2[2]);
            }
            return t3.apply(e3, n2);
          };
          var at = Math.max;
          const ct = function(t3, e3, n2) {
            return e3 = at(void 0 === e3 ? t3.length - 1 : e3, 0), function() {
              for (var o2 = arguments, i2 = -1, r2 = at(o2.length - e3, 0), s2 = Array(r2); ++i2 < r2; )
                s2[i2] = o2[e3 + i2];
              i2 = -1;
              for (var a2 = Array(e3 + 1); ++i2 < e3; )
                a2[i2] = o2[i2];
              return a2[e3] = n2(s2), st(t3, this, a2);
            };
          };
          const lt = function(t3) {
            return function() {
              return t3;
            };
          };
          const dt = X ? function(t3, e3) {
            return X(t3, "toString", { configurable: true, enumerable: false, value: lt(e3), writable: true });
          } : rt;
          var ht = Date.now;
          const ut = function(t3) {
            var e3 = 0, n2 = 0;
            return function() {
              var o2 = ht(), i2 = 16 - (o2 - n2);
              if (n2 = o2, i2 > 0) {
                if (++e3 >= 800)
                  return arguments[0];
              } else
                e3 = 0;
              return t3.apply(void 0, arguments);
            };
          };
          const gt = ut(dt);
          const mt = function(t3, e3) {
            return gt(ct(t3, e3, rt), t3 + "");
          };
          const pt = function(t3) {
            return "number" == typeof t3 && t3 > -1 && t3 % 1 == 0 && t3 <= 9007199254740991;
          };
          const ft = function(t3) {
            return null != t3 && pt(t3.length) && !R(t3);
          };
          var kt = /^(?:0|[1-9]\d*)$/;
          const bt = function(t3, e3) {
            var n2 = typeof t3;
            return !!(e3 = null == e3 ? 9007199254740991 : e3) && ("number" == n2 || "symbol" != n2 && kt.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e3;
          };
          const wt = function(t3, e3, n2) {
            if (!y(n2))
              return false;
            var o2 = typeof e3;
            return !!("number" == o2 ? ft(n2) && bt(e3, n2.length) : "string" == o2 && e3 in n2) && et(n2[e3], t3);
          };
          const Ct = function(t3) {
            return mt(function(e3, n2) {
              var o2 = -1, i2 = n2.length, r2 = i2 > 1 ? n2[i2 - 1] : void 0, s2 = i2 > 2 ? n2[2] : void 0;
              for (r2 = t3.length > 3 && "function" == typeof r2 ? (i2--, r2) : void 0, s2 && wt(n2[0], n2[1], s2) && (r2 = i2 < 3 ? void 0 : r2, i2 = 1), e3 = Object(e3); ++o2 < i2; ) {
                var a2 = n2[o2];
                a2 && t3(e3, a2, o2, r2);
              }
              return e3;
            });
          };
          const At = function(t3, e3) {
            for (var n2 = -1, o2 = Array(t3); ++n2 < t3; )
              o2[n2] = e3(n2);
            return o2;
          };
          const _t = function(t3) {
            return null != t3 && "object" == typeof t3;
          };
          const vt = function(t3) {
            return _t(t3) && "[object Arguments]" == O(t3);
          };
          var yt = Object.prototype, xt = yt.hasOwnProperty, Et = yt.propertyIsEnumerable, Dt = vt(function() {
            return arguments;
          }()) ? vt : function(t3) {
            return _t(t3) && xt.call(t3, "callee") && !Et.call(t3, "callee");
          };
          const It = Dt;
          const Mt = Array.isArray;
          const St = function() {
            return false;
          };
          var Tt = "object" == typeof exports && exports && !exports.nodeType && exports, Nt = Tt && "object" == typeof module && module && !module.nodeType && module, Bt = Nt && Nt.exports === Tt ? D.Buffer : void 0;
          const zt = (Bt ? Bt.isBuffer : void 0) || St;
          var Pt = {};
          Pt["[object Float32Array]"] = Pt["[object Float64Array]"] = Pt["[object Int8Array]"] = Pt["[object Int16Array]"] = Pt["[object Int32Array]"] = Pt["[object Uint8Array]"] = Pt["[object Uint8ClampedArray]"] = Pt["[object Uint16Array]"] = Pt["[object Uint32Array]"] = true, Pt["[object Arguments]"] = Pt["[object Array]"] = Pt["[object ArrayBuffer]"] = Pt["[object Boolean]"] = Pt["[object DataView]"] = Pt["[object Date]"] = Pt["[object Error]"] = Pt["[object Function]"] = Pt["[object Map]"] = Pt["[object Number]"] = Pt["[object Object]"] = Pt["[object RegExp]"] = Pt["[object Set]"] = Pt["[object String]"] = Pt["[object WeakMap]"] = false;
          const Lt = function(t3) {
            return _t(t3) && pt(t3.length) && !!Pt[O(t3)];
          };
          const Ot = function(t3) {
            return function(e3) {
              return t3(e3);
            };
          };
          var Rt = "object" == typeof exports && exports && !exports.nodeType && exports, jt = Rt && "object" == typeof module && module && !module.nodeType && module, Ft = jt && jt.exports === Rt && x.process;
          const Vt = function() {
            try {
              var t3 = jt && jt.require && jt.require("util").types;
              return t3 || Ft && Ft.binding && Ft.binding("util");
            } catch (t4) {
            }
          }();
          var Ut = Vt && Vt.isTypedArray;
          const Ht = Ut ? Ot(Ut) : Lt;
          var qt = Object.prototype.hasOwnProperty;
          const Wt = function(t3, e3) {
            var n2 = Mt(t3), o2 = !n2 && It(t3), i2 = !n2 && !o2 && zt(t3), r2 = !n2 && !o2 && !i2 && Ht(t3), s2 = n2 || o2 || i2 || r2, a2 = s2 ? At(t3.length, String) : [], c2 = a2.length;
            for (var l2 in t3)
              !e3 && !qt.call(t3, l2) || s2 && ("length" == l2 || i2 && ("offset" == l2 || "parent" == l2) || r2 && ("buffer" == l2 || "byteLength" == l2 || "byteOffset" == l2) || bt(l2, c2)) || a2.push(l2);
            return a2;
          };
          var Gt = Object.prototype;
          const Yt = function(t3) {
            var e3 = t3 && t3.constructor;
            return t3 === ("function" == typeof e3 && e3.prototype || Gt);
          };
          const Qt = function(t3) {
            var e3 = [];
            if (null != t3)
              for (var n2 in Object(t3))
                e3.push(n2);
            return e3;
          };
          var Kt = Object.prototype.hasOwnProperty;
          const $t = function(t3) {
            if (!y(t3))
              return Qt(t3);
            var e3 = Yt(t3), n2 = [];
            for (var o2 in t3)
              ("constructor" != o2 || !e3 && Kt.call(t3, o2)) && n2.push(o2);
            return n2;
          };
          const Zt = function(t3) {
            return ft(t3) ? Wt(t3, true) : $t(t3);
          };
          const Jt = Ct(function(t3, e3) {
            it(e3, Zt(e3), t3);
          }), Xt = Symbol("observableProperties"), te = Symbol("boundObservables"), ee = Symbol("boundProperties"), ne = Symbol("decoratedMethods"), oe = Symbol("decoratedOriginal"), ie = { set(t3, e3) {
            if (y(t3))
              return void Object.keys(t3).forEach((e4) => {
                this.set(e4, t3[e4]);
              }, this);
            se(this);
            const n2 = this[Xt];
            if (t3 in this && !n2.has(t3))
              throw new a("observable-set-cannot-override", this);
            Object.defineProperty(this, t3, { enumerable: true, configurable: true, get: () => n2.get(t3), set(e4) {
              const o2 = n2.get(t3);
              let i2 = this.fire("set:" + t3, t3, e4, o2);
              void 0 === i2 && (i2 = e4), o2 === i2 && n2.has(t3) || (n2.set(t3, i2), this.fire("change:" + t3, t3, i2, o2));
            } }), this[t3] = e3;
          }, bind(...t3) {
            if (!t3.length || !le(t3))
              throw new a("observable-bind-wrong-properties", this);
            if (new Set(t3).size !== t3.length)
              throw new a("observable-bind-duplicate-properties", this);
            se(this);
            const e3 = this[ee];
            t3.forEach((t4) => {
              if (e3.has(t4))
                throw new a("observable-bind-rebind", this);
            });
            const n2 = /* @__PURE__ */ new Map();
            return t3.forEach((t4) => {
              const o2 = { property: t4, to: [] };
              e3.set(t4, o2), n2.set(t4, o2);
            }), { to: ae, toMany: ce, _observable: this, _bindProperties: t3, _to: [], _bindings: n2 };
          }, unbind(...t3) {
            if (!this[Xt])
              return;
            const e3 = this[ee], n2 = this[te];
            if (t3.length) {
              if (!le(t3))
                throw new a("observable-unbind-wrong-properties", this);
              t3.forEach((t4) => {
                const o2 = e3.get(t4);
                if (!o2)
                  return;
                let i2, r2, s2, a2;
                o2.to.forEach((t5) => {
                  i2 = t5[0], r2 = t5[1], s2 = n2.get(i2), a2 = s2[r2], a2.delete(o2), a2.size || delete s2[r2], Object.keys(s2).length || (n2.delete(i2), this.stopListening(i2, "change"));
                }), e3.delete(t4);
              });
            } else
              n2.forEach((t4, e4) => {
                this.stopListening(e4, "change");
              }), n2.clear(), e3.clear();
          }, decorate(t3) {
            const e3 = this[t3];
            if (!e3)
              throw new a("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: t3 });
            this.on(t3, (t4, n2) => {
              t4.return = e3.apply(this, n2);
            }), this[t3] = function(...e4) {
              return this.fire(t3, e4);
            }, this[t3][oe] = e3, this[ne] || (this[ne] = []), this[ne].push(t3);
          } };
          Jt(ie, f), ie.stopListening = function(t3, e3, n2) {
            if (!t3 && this[ne]) {
              for (const t4 of this[ne])
                this[t4] = this[t4][oe];
              delete this[ne];
            }
            f.stopListening.call(this, t3, e3, n2);
          };
          const re = ie;
          function se(t3) {
            t3[Xt] || (Object.defineProperty(t3, Xt, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t3, te, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t3, ee, { value: /* @__PURE__ */ new Map() }));
          }
          function ae(...t3) {
            const e3 = function(...t4) {
              if (!t4.length)
                throw new a("observable-bind-to-parse-error", null);
              const e4 = { to: [] };
              let n3;
              "function" == typeof t4[t4.length - 1] && (e4.callback = t4.pop());
              return t4.forEach((t5) => {
                if ("string" == typeof t5)
                  n3.properties.push(t5);
                else {
                  if ("object" != typeof t5)
                    throw new a("observable-bind-to-parse-error", null);
                  n3 = { observable: t5, properties: [] }, e4.to.push(n3);
                }
              }), e4;
            }(...t3), n2 = Array.from(this._bindings.keys()), o2 = n2.length;
            if (!e3.callback && e3.to.length > 1)
              throw new a("observable-bind-to-no-callback", this);
            if (o2 > 1 && e3.callback)
              throw new a("observable-bind-to-extra-callback", this);
            var i2;
            e3.to.forEach((t4) => {
              if (t4.properties.length && t4.properties.length !== o2)
                throw new a("observable-bind-to-properties-length", this);
              t4.properties.length || (t4.properties = this._bindProperties);
            }), this._to = e3.to, e3.callback && (this._bindings.get(n2[0]).callback = e3.callback), i2 = this._observable, this._to.forEach((t4) => {
              const e4 = i2[te];
              let n3;
              e4.get(t4.observable) || i2.listenTo(t4.observable, "change", (o3, r2) => {
                n3 = e4.get(t4.observable)[r2], n3 && n3.forEach((t5) => {
                  de(i2, t5.property);
                });
              });
            }), function(t4) {
              let e4;
              t4._bindings.forEach((n3, o3) => {
                t4._to.forEach((i3) => {
                  e4 = i3.properties[n3.callback ? 0 : t4._bindProperties.indexOf(o3)], n3.to.push([i3.observable, e4]), function(t5, e5, n4, o4) {
                    const i4 = t5[te], r2 = i4.get(n4), s2 = r2 || {};
                    s2[o4] || (s2[o4] = /* @__PURE__ */ new Set());
                    s2[o4].add(e5), r2 || i4.set(n4, s2);
                  }(t4._observable, n3, i3.observable, e4);
                });
              });
            }(this), this._bindProperties.forEach((t4) => {
              de(this._observable, t4);
            });
          }
          function ce(t3, e3, n2) {
            if (this._bindings.size > 1)
              throw new a("observable-bind-to-many-not-one-binding", this);
            this.to(...function(t4, e4) {
              const n3 = t4.map((t5) => [t5, e4]);
              return Array.prototype.concat.apply([], n3);
            }(t3, e3), n2);
          }
          function le(t3) {
            return t3.every((t4) => "string" == typeof t4);
          }
          function de(t3, e3) {
            const n2 = t3[ee].get(e3);
            let o2;
            n2.callback ? o2 = n2.callback.apply(t3, n2.to.map((t4) => t4[0][t4[1]])) : (o2 = n2.to[0], o2 = o2[0][o2[1]]), Object.prototype.hasOwnProperty.call(t3, e3) ? t3[e3] = o2 : t3.set(e3, o2);
          }
          function he(t3, ...e3) {
            e3.forEach((e4) => {
              Object.getOwnPropertyNames(e4).concat(Object.getOwnPropertySymbols(e4)).forEach((n2) => {
                if (n2 in t3.prototype)
                  return;
                const o2 = Object.getOwnPropertyDescriptor(e4, n2);
                o2.enumerable = false, Object.defineProperty(t3.prototype, n2, o2);
              });
            });
          }
          class ue {
            constructor(t3) {
              this.editor = t3, this.set("isEnabled", true), this._disableStack = /* @__PURE__ */ new Set();
            }
            forceDisabled(t3) {
              this._disableStack.add(t3), 1 == this._disableStack.size && (this.on("set:isEnabled", ge, { priority: "highest" }), this.isEnabled = false);
            }
            clearForceDisabled(t3) {
              this._disableStack.delete(t3), 0 == this._disableStack.size && (this.off("set:isEnabled", ge), this.isEnabled = true);
            }
            destroy() {
              this.stopListening();
            }
            static get isContextPlugin() {
              return false;
            }
          }
          function ge(t3) {
            t3.return = false, t3.stop();
          }
          he(ue, re);
          class me {
            constructor(t3) {
              this.editor = t3, this.set("value", void 0), this.set("isEnabled", false), this.affectsData = true, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
                this.refresh();
              }), this.on("execute", (t4) => {
                this.isEnabled || t4.stop();
              }, { priority: "high" }), this.listenTo(t3, "change:isReadOnly", (t4, e3, n2) => {
                n2 && this.affectsData ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
              });
            }
            refresh() {
              this.isEnabled = true;
            }
            forceDisabled(t3) {
              this._disableStack.add(t3), 1 == this._disableStack.size && (this.on("set:isEnabled", pe, { priority: "highest" }), this.isEnabled = false);
            }
            clearForceDisabled(t3) {
              this._disableStack.delete(t3), 0 == this._disableStack.size && (this.off("set:isEnabled", pe), this.refresh());
            }
            execute() {
            }
            destroy() {
              this.stopListening();
            }
          }
          function pe(t3) {
            t3.return = false, t3.stop();
          }
          he(me, re);
          class fe extends me {
            constructor(t3) {
              super(t3), this._childCommands = [];
            }
            refresh() {
            }
            execute(...t3) {
              const e3 = this._getFirstEnabledCommand();
              return null != e3 && e3.execute(t3);
            }
            registerChildCommand(t3) {
              this._childCommands.push(t3), t3.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
            }
            _checkEnabled() {
              this.isEnabled = !!this._getFirstEnabledCommand();
            }
            _getFirstEnabledCommand() {
              return this._childCommands.find((t3) => t3.isEnabled);
            }
          }
          const ke = function(t3, e3) {
            return function(n2) {
              return t3(e3(n2));
            };
          };
          const be = ke(Object.getPrototypeOf, Object);
          var we = Function.prototype, Ce = Object.prototype, Ae = we.toString, _e = Ce.hasOwnProperty, ve = Ae.call(Object);
          const ye = function(t3) {
            if (!_t(t3) || "[object Object]" != O(t3))
              return false;
            var e3 = be(t3);
            if (null === e3)
              return true;
            var n2 = _e.call(e3, "constructor") && e3.constructor;
            return "function" == typeof n2 && n2 instanceof n2 && Ae.call(n2) == ve;
          };
          const xe = function() {
            this.__data__ = [], this.size = 0;
          };
          const Ee = function(t3, e3) {
            for (var n2 = t3.length; n2--; )
              if (et(t3[n2][0], e3))
                return n2;
            return -1;
          };
          var De = Array.prototype.splice;
          const Ie = function(t3) {
            var e3 = this.__data__, n2 = Ee(e3, t3);
            return !(n2 < 0) && (n2 == e3.length - 1 ? e3.pop() : De.call(e3, n2, 1), --this.size, true);
          };
          const Me = function(t3) {
            var e3 = this.__data__, n2 = Ee(e3, t3);
            return n2 < 0 ? void 0 : e3[n2][1];
          };
          const Se = function(t3) {
            return Ee(this.__data__, t3) > -1;
          };
          const Te = function(t3, e3) {
            var n2 = this.__data__, o2 = Ee(n2, t3);
            return o2 < 0 ? (++this.size, n2.push([t3, e3])) : n2[o2][1] = e3, this;
          };
          function Ne(t3) {
            var e3 = -1, n2 = null == t3 ? 0 : t3.length;
            for (this.clear(); ++e3 < n2; ) {
              var o2 = t3[e3];
              this.set(o2[0], o2[1]);
            }
          }
          Ne.prototype.clear = xe, Ne.prototype.delete = Ie, Ne.prototype.get = Me, Ne.prototype.has = Se, Ne.prototype.set = Te;
          const Be = Ne;
          const ze = function() {
            this.__data__ = new Be(), this.size = 0;
          };
          const Pe = function(t3) {
            var e3 = this.__data__, n2 = e3.delete(t3);
            return this.size = e3.size, n2;
          };
          const Le = function(t3) {
            return this.__data__.get(t3);
          };
          const Oe = function(t3) {
            return this.__data__.has(t3);
          };
          const Re = J(D, "Map");
          const je = J(Object, "create");
          const Fe = function() {
            this.__data__ = je ? je(null) : {}, this.size = 0;
          };
          const Ve = function(t3) {
            var e3 = this.has(t3) && delete this.__data__[t3];
            return this.size -= e3 ? 1 : 0, e3;
          };
          var Ue = Object.prototype.hasOwnProperty;
          const He = function(t3) {
            var e3 = this.__data__;
            if (je) {
              var n2 = e3[t3];
              return "__lodash_hash_undefined__" === n2 ? void 0 : n2;
            }
            return Ue.call(e3, t3) ? e3[t3] : void 0;
          };
          var qe = Object.prototype.hasOwnProperty;
          const We = function(t3) {
            var e3 = this.__data__;
            return je ? void 0 !== e3[t3] : qe.call(e3, t3);
          };
          const Ge = function(t3, e3) {
            var n2 = this.__data__;
            return this.size += this.has(t3) ? 0 : 1, n2[t3] = je && void 0 === e3 ? "__lodash_hash_undefined__" : e3, this;
          };
          function Ye(t3) {
            var e3 = -1, n2 = null == t3 ? 0 : t3.length;
            for (this.clear(); ++e3 < n2; ) {
              var o2 = t3[e3];
              this.set(o2[0], o2[1]);
            }
          }
          Ye.prototype.clear = Fe, Ye.prototype.delete = Ve, Ye.prototype.get = He, Ye.prototype.has = We, Ye.prototype.set = Ge;
          const Qe = Ye;
          const Ke = function() {
            this.size = 0, this.__data__ = { hash: new Qe(), map: new (Re || Be)(), string: new Qe() };
          };
          const $e = function(t3) {
            var e3 = typeof t3;
            return "string" == e3 || "number" == e3 || "symbol" == e3 || "boolean" == e3 ? "__proto__" !== t3 : null === t3;
          };
          const Ze = function(t3, e3) {
            var n2 = t3.__data__;
            return $e(e3) ? n2["string" == typeof e3 ? "string" : "hash"] : n2.map;
          };
          const Je = function(t3) {
            var e3 = Ze(this, t3).delete(t3);
            return this.size -= e3 ? 1 : 0, e3;
          };
          const Xe = function(t3) {
            return Ze(this, t3).get(t3);
          };
          const tn = function(t3) {
            return Ze(this, t3).has(t3);
          };
          const en = function(t3, e3) {
            var n2 = Ze(this, t3), o2 = n2.size;
            return n2.set(t3, e3), this.size += n2.size == o2 ? 0 : 1, this;
          };
          function nn(t3) {
            var e3 = -1, n2 = null == t3 ? 0 : t3.length;
            for (this.clear(); ++e3 < n2; ) {
              var o2 = t3[e3];
              this.set(o2[0], o2[1]);
            }
          }
          nn.prototype.clear = Ke, nn.prototype.delete = Je, nn.prototype.get = Xe, nn.prototype.has = tn, nn.prototype.set = en;
          const on = nn;
          const rn = function(t3, e3) {
            var n2 = this.__data__;
            if (n2 instanceof Be) {
              var o2 = n2.__data__;
              if (!Re || o2.length < 199)
                return o2.push([t3, e3]), this.size = ++n2.size, this;
              n2 = this.__data__ = new on(o2);
            }
            return n2.set(t3, e3), this.size = n2.size, this;
          };
          function sn(t3) {
            var e3 = this.__data__ = new Be(t3);
            this.size = e3.size;
          }
          sn.prototype.clear = ze, sn.prototype.delete = Pe, sn.prototype.get = Le, sn.prototype.has = Oe, sn.prototype.set = rn;
          const an = sn;
          const cn = function(t3, e3) {
            for (var n2 = -1, o2 = null == t3 ? 0 : t3.length; ++n2 < o2 && false !== e3(t3[n2], n2, t3); )
              ;
            return t3;
          };
          const ln = ke(Object.keys, Object);
          var dn = Object.prototype.hasOwnProperty;
          const hn = function(t3) {
            if (!Yt(t3))
              return ln(t3);
            var e3 = [];
            for (var n2 in Object(t3))
              dn.call(t3, n2) && "constructor" != n2 && e3.push(n2);
            return e3;
          };
          const un = function(t3) {
            return ft(t3) ? Wt(t3) : hn(t3);
          };
          const gn = function(t3, e3) {
            return t3 && it(e3, un(e3), t3);
          };
          const mn = function(t3, e3) {
            return t3 && it(e3, Zt(e3), t3);
          };
          var pn = "object" == typeof exports && exports && !exports.nodeType && exports, fn = pn && "object" == typeof module && module && !module.nodeType && module, kn = fn && fn.exports === pn ? D.Buffer : void 0, bn = kn ? kn.allocUnsafe : void 0;
          const wn = function(t3, e3) {
            if (e3)
              return t3.slice();
            var n2 = t3.length, o2 = bn ? bn(n2) : new t3.constructor(n2);
            return t3.copy(o2), o2;
          };
          const Cn = function(t3, e3) {
            var n2 = -1, o2 = t3.length;
            for (e3 || (e3 = Array(o2)); ++n2 < o2; )
              e3[n2] = t3[n2];
            return e3;
          };
          const An = function(t3, e3) {
            for (var n2 = -1, o2 = null == t3 ? 0 : t3.length, i2 = 0, r2 = []; ++n2 < o2; ) {
              var s2 = t3[n2];
              e3(s2, n2, t3) && (r2[i2++] = s2);
            }
            return r2;
          };
          const _n = function() {
            return [];
          };
          var vn = Object.prototype.propertyIsEnumerable, yn = Object.getOwnPropertySymbols;
          const xn = yn ? function(t3) {
            return null == t3 ? [] : (t3 = Object(t3), An(yn(t3), function(e3) {
              return vn.call(t3, e3);
            }));
          } : _n;
          const En = function(t3, e3) {
            return it(t3, xn(t3), e3);
          };
          const Dn = function(t3, e3) {
            for (var n2 = -1, o2 = e3.length, i2 = t3.length; ++n2 < o2; )
              t3[i2 + n2] = e3[n2];
            return t3;
          };
          const In = Object.getOwnPropertySymbols ? function(t3) {
            for (var e3 = []; t3; )
              Dn(e3, xn(t3)), t3 = be(t3);
            return e3;
          } : _n;
          const Mn = function(t3, e3) {
            return it(t3, In(t3), e3);
          };
          const Sn = function(t3, e3, n2) {
            var o2 = e3(t3);
            return Mt(t3) ? o2 : Dn(o2, n2(t3));
          };
          const Tn = function(t3) {
            return Sn(t3, un, xn);
          };
          const Nn = function(t3) {
            return Sn(t3, Zt, In);
          };
          const Bn = J(D, "DataView");
          const zn = J(D, "Promise");
          const Pn = J(D, "Set");
          const Ln = J(D, "WeakMap");
          var On = "[object Map]", Rn = "[object Promise]", jn = "[object Set]", Fn = "[object WeakMap]", Vn = "[object DataView]", Un = H(Bn), Hn = H(Re), qn = H(zn), Wn = H(Pn), Gn = H(Ln), Yn = O;
          (Bn && Yn(new Bn(new ArrayBuffer(1))) != Vn || Re && Yn(new Re()) != On || zn && Yn(zn.resolve()) != Rn || Pn && Yn(new Pn()) != jn || Ln && Yn(new Ln()) != Fn) && (Yn = function(t3) {
            var e3 = O(t3), n2 = "[object Object]" == e3 ? t3.constructor : void 0, o2 = n2 ? H(n2) : "";
            if (o2)
              switch (o2) {
                case Un:
                  return Vn;
                case Hn:
                  return On;
                case qn:
                  return Rn;
                case Wn:
                  return jn;
                case Gn:
                  return Fn;
              }
            return e3;
          });
          const Qn = Yn;
          var Kn = Object.prototype.hasOwnProperty;
          const $n = function(t3) {
            var e3 = t3.length, n2 = new t3.constructor(e3);
            return e3 && "string" == typeof t3[0] && Kn.call(t3, "index") && (n2.index = t3.index, n2.input = t3.input), n2;
          };
          const Zn = D.Uint8Array;
          const Jn = function(t3) {
            var e3 = new t3.constructor(t3.byteLength);
            return new Zn(e3).set(new Zn(t3)), e3;
          };
          const Xn = function(t3, e3) {
            var n2 = e3 ? Jn(t3.buffer) : t3.buffer;
            return new t3.constructor(n2, t3.byteOffset, t3.byteLength);
          };
          var to = /\w*$/;
          const eo = function(t3) {
            var e3 = new t3.constructor(t3.source, to.exec(t3));
            return e3.lastIndex = t3.lastIndex, e3;
          };
          var no = I ? I.prototype : void 0, oo = no ? no.valueOf : void 0;
          const io = function(t3) {
            return oo ? Object(oo.call(t3)) : {};
          };
          const ro = function(t3, e3) {
            var n2 = e3 ? Jn(t3.buffer) : t3.buffer;
            return new t3.constructor(n2, t3.byteOffset, t3.length);
          };
          const so = function(t3, e3, n2) {
            var o2 = t3.constructor;
            switch (e3) {
              case "[object ArrayBuffer]":
                return Jn(t3);
              case "[object Boolean]":
              case "[object Date]":
                return new o2(+t3);
              case "[object DataView]":
                return Xn(t3, n2);
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return ro(t3, n2);
              case "[object Map]":
              case "[object Set]":
                return new o2();
              case "[object Number]":
              case "[object String]":
                return new o2(t3);
              case "[object RegExp]":
                return eo(t3);
              case "[object Symbol]":
                return io(t3);
            }
          };
          var ao = Object.create;
          const co = function() {
            function t3() {
            }
            return function(e3) {
              if (!y(e3))
                return {};
              if (ao)
                return ao(e3);
              t3.prototype = e3;
              var n2 = new t3();
              return t3.prototype = void 0, n2;
            };
          }();
          const lo = function(t3) {
            return "function" != typeof t3.constructor || Yt(t3) ? {} : co(be(t3));
          };
          const ho = function(t3) {
            return _t(t3) && "[object Map]" == Qn(t3);
          };
          var uo = Vt && Vt.isMap;
          const go = uo ? Ot(uo) : ho;
          const mo = function(t3) {
            return _t(t3) && "[object Set]" == Qn(t3);
          };
          var po = Vt && Vt.isSet;
          const fo = po ? Ot(po) : mo;
          var ko = "[object Arguments]", bo = "[object Function]", wo = "[object Object]", Co = {};
          Co[ko] = Co["[object Array]"] = Co["[object ArrayBuffer]"] = Co["[object DataView]"] = Co["[object Boolean]"] = Co["[object Date]"] = Co["[object Float32Array]"] = Co["[object Float64Array]"] = Co["[object Int8Array]"] = Co["[object Int16Array]"] = Co["[object Int32Array]"] = Co["[object Map]"] = Co["[object Number]"] = Co["[object Object]"] = Co["[object RegExp]"] = Co["[object Set]"] = Co["[object String]"] = Co["[object Symbol]"] = Co["[object Uint8Array]"] = Co["[object Uint8ClampedArray]"] = Co["[object Uint16Array]"] = Co["[object Uint32Array]"] = true, Co["[object Error]"] = Co[bo] = Co["[object WeakMap]"] = false;
          const Ao = function t3(e3, n2, o2, i2, r2, s2) {
            var a2, c2 = 1 & n2, l2 = 2 & n2, d2 = 4 & n2;
            if (o2 && (a2 = r2 ? o2(e3, i2, r2, s2) : o2(e3)), void 0 !== a2)
              return a2;
            if (!y(e3))
              return e3;
            var h2 = Mt(e3);
            if (h2) {
              if (a2 = $n(e3), !c2)
                return Cn(e3, a2);
            } else {
              var u2 = Qn(e3), g2 = u2 == bo || "[object GeneratorFunction]" == u2;
              if (zt(e3))
                return wn(e3, c2);
              if (u2 == wo || u2 == ko || g2 && !r2) {
                if (a2 = l2 || g2 ? {} : lo(e3), !c2)
                  return l2 ? Mn(e3, mn(a2, e3)) : En(e3, gn(a2, e3));
              } else {
                if (!Co[u2])
                  return r2 ? e3 : {};
                a2 = so(e3, u2, c2);
              }
            }
            s2 || (s2 = new an());
            var m2 = s2.get(e3);
            if (m2)
              return m2;
            s2.set(e3, a2), fo(e3) ? e3.forEach(function(i3) {
              a2.add(t3(i3, n2, o2, i3, e3, s2));
            }) : go(e3) && e3.forEach(function(i3, r3) {
              a2.set(r3, t3(i3, n2, o2, r3, e3, s2));
            });
            var p2 = h2 ? void 0 : (d2 ? l2 ? Nn : Tn : l2 ? Zt : un)(e3);
            return cn(p2 || e3, function(i3, r3) {
              p2 && (i3 = e3[r3 = i3]), ot(a2, r3, t3(i3, n2, o2, r3, e3, s2));
            }), a2;
          };
          const _o = function(t3, e3) {
            return Ao(t3, 5, e3 = "function" == typeof e3 ? e3 : void 0);
          };
          const vo = function(t3) {
            return _t(t3) && 1 === t3.nodeType && !ye(t3);
          };
          class yo {
            constructor(t3, e3) {
              this._config = {}, e3 && this.define(xo(e3)), t3 && this._setObjectToTarget(this._config, t3);
            }
            set(t3, e3) {
              this._setToTarget(this._config, t3, e3);
            }
            define(t3, e3) {
              this._setToTarget(this._config, t3, e3, true);
            }
            get(t3) {
              return this._getFromSource(this._config, t3);
            }
            *names() {
              for (const t3 of Object.keys(this._config))
                yield t3;
            }
            _setToTarget(t3, e3, n2, o2 = false) {
              if (ye(e3))
                return void this._setObjectToTarget(t3, e3, o2);
              const i2 = e3.split(".");
              e3 = i2.pop();
              for (const e4 of i2)
                ye(t3[e4]) || (t3[e4] = {}), t3 = t3[e4];
              if (ye(n2))
                return ye(t3[e3]) || (t3[e3] = {}), t3 = t3[e3], void this._setObjectToTarget(t3, n2, o2);
              o2 && void 0 !== t3[e3] || (t3[e3] = n2);
            }
            _getFromSource(t3, e3) {
              const n2 = e3.split(".");
              e3 = n2.pop();
              for (const e4 of n2) {
                if (!ye(t3[e4])) {
                  t3 = null;
                  break;
                }
                t3 = t3[e4];
              }
              return t3 ? xo(t3[e3]) : void 0;
            }
            _setObjectToTarget(t3, e3, n2) {
              Object.keys(e3).forEach((o2) => {
                this._setToTarget(t3, o2, e3[o2], n2);
              });
            }
          }
          function xo(t3) {
            return _o(t3, Eo);
          }
          function Eo(t3) {
            return vo(t3) ? t3 : void 0;
          }
          function Do(t3) {
            return !(!t3 || !t3[Symbol.iterator]);
          }
          class Io {
            constructor(t3 = {}, e3 = {}) {
              const n2 = Do(t3);
              if (n2 || (e3 = t3), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = e3.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n2)
                for (const e4 of t3)
                  this._items.push(e4), this._itemMap.set(this._getItemIdBeforeAdding(e4), e4);
            }
            get length() {
              return this._items.length;
            }
            get first() {
              return this._items[0] || null;
            }
            get last() {
              return this._items[this.length - 1] || null;
            }
            add(t3, e3) {
              return this.addMany([t3], e3);
            }
            addMany(t3, e3) {
              if (void 0 === e3)
                e3 = this._items.length;
              else if (e3 > this._items.length || e3 < 0)
                throw new a("collection-add-item-invalid-index", this);
              for (let n2 = 0; n2 < t3.length; n2++) {
                const o2 = t3[n2], i2 = this._getItemIdBeforeAdding(o2), r2 = e3 + n2;
                this._items.splice(r2, 0, o2), this._itemMap.set(i2, o2), this.fire("add", o2, r2);
              }
              return this.fire("change", { added: t3, removed: [], index: e3 }), this;
            }
            get(t3) {
              let e3;
              if ("string" == typeof t3)
                e3 = this._itemMap.get(t3);
              else {
                if ("number" != typeof t3)
                  throw new a("collection-get-invalid-arg", this);
                e3 = this._items[t3];
              }
              return e3 || null;
            }
            has(t3) {
              if ("string" == typeof t3)
                return this._itemMap.has(t3);
              {
                const e3 = t3[this._idProperty];
                return this._itemMap.has(e3);
              }
            }
            getIndex(t3) {
              let e3;
              return e3 = "string" == typeof t3 ? this._itemMap.get(t3) : t3, this._items.indexOf(e3);
            }
            remove(t3) {
              const [e3, n2] = this._remove(t3);
              return this.fire("change", { added: [], removed: [e3], index: n2 }), e3;
            }
            map(t3, e3) {
              return this._items.map(t3, e3);
            }
            find(t3, e3) {
              return this._items.find(t3, e3);
            }
            filter(t3, e3) {
              return this._items.filter(t3, e3);
            }
            clear() {
              this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
              const t3 = Array.from(this._items);
              for (; this.length; )
                this._remove(0);
              this.fire("change", { added: [], removed: t3, index: 0 });
            }
            bindTo(t3) {
              if (this._bindToCollection)
                throw new a("collection-bind-to-rebind", this);
              return this._bindToCollection = t3, { as: (t4) => {
                this._setUpBindToBinding((e3) => new t4(e3));
              }, using: (t4) => {
                "function" == typeof t4 ? this._setUpBindToBinding((e3) => t4(e3)) : this._setUpBindToBinding((e3) => e3[t4]);
              } };
            }
            _setUpBindToBinding(t3) {
              const e3 = this._bindToCollection, n2 = (n3, o2, i2) => {
                const r2 = e3._bindToCollection == this, s2 = e3._bindToInternalToExternalMap.get(o2);
                if (r2 && s2)
                  this._bindToExternalToInternalMap.set(o2, s2), this._bindToInternalToExternalMap.set(s2, o2);
                else {
                  const n4 = t3(o2);
                  if (!n4)
                    return void this._skippedIndexesFromExternal.push(i2);
                  let r3 = i2;
                  for (const t4 of this._skippedIndexesFromExternal)
                    i2 > t4 && r3--;
                  for (const t4 of e3._skippedIndexesFromExternal)
                    r3 >= t4 && r3++;
                  this._bindToExternalToInternalMap.set(o2, n4), this._bindToInternalToExternalMap.set(n4, o2), this.add(n4, r3);
                  for (let t4 = 0; t4 < e3._skippedIndexesFromExternal.length; t4++)
                    r3 <= e3._skippedIndexesFromExternal[t4] && e3._skippedIndexesFromExternal[t4]++;
                }
              };
              for (const t4 of e3)
                n2(0, t4, e3.getIndex(t4));
              this.listenTo(e3, "add", n2), this.listenTo(e3, "remove", (t4, e4, n3) => {
                const o2 = this._bindToExternalToInternalMap.get(e4);
                o2 && this.remove(o2), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t5, e5) => (n3 < e5 && t5.push(e5 - 1), n3 > e5 && t5.push(e5), t5), []);
              });
            }
            _getItemIdBeforeAdding(t3) {
              const e3 = this._idProperty;
              let n2;
              if (e3 in t3) {
                if (n2 = t3[e3], "string" != typeof n2)
                  throw new a("collection-add-invalid-id", this);
                if (this.get(n2))
                  throw new a("collection-add-item-already-exists", this);
              } else
                t3[e3] = n2 = r();
              return n2;
            }
            _remove(t3) {
              let e3, n2, o2, i2 = false;
              const r2 = this._idProperty;
              if ("string" == typeof t3 ? (n2 = t3, o2 = this._itemMap.get(n2), i2 = !o2, o2 && (e3 = this._items.indexOf(o2))) : "number" == typeof t3 ? (e3 = t3, o2 = this._items[e3], i2 = !o2, o2 && (n2 = o2[r2])) : (o2 = t3, n2 = o2[r2], e3 = this._items.indexOf(o2), i2 = -1 == e3 || !this._itemMap.get(n2)), i2)
                throw new a("collection-remove-404", this);
              this._items.splice(e3, 1), this._itemMap.delete(n2);
              const s2 = this._bindToInternalToExternalMap.get(o2);
              return this._bindToInternalToExternalMap.delete(o2), this._bindToExternalToInternalMap.delete(s2), this.fire("remove", o2, e3), [o2, e3];
            }
            [Symbol.iterator]() {
              return this._items[Symbol.iterator]();
            }
          }
          he(Io, f);
          class Mo {
            constructor(t3, e3 = [], n2 = []) {
              this._context = t3, this._plugins = /* @__PURE__ */ new Map(), this._availablePlugins = /* @__PURE__ */ new Map();
              for (const t4 of e3)
                t4.pluginName && this._availablePlugins.set(t4.pluginName, t4);
              this._contextPlugins = /* @__PURE__ */ new Map();
              for (const [t4, e4] of n2)
                this._contextPlugins.set(t4, e4), this._contextPlugins.set(e4, t4), t4.pluginName && this._availablePlugins.set(t4.pluginName, t4);
            }
            *[Symbol.iterator]() {
              for (const t3 of this._plugins)
                "function" == typeof t3[0] && (yield t3);
            }
            get(t3) {
              const e3 = this._plugins.get(t3);
              if (!e3) {
                let e4 = t3;
                throw "function" == typeof t3 && (e4 = t3.pluginName || t3.name), new a("plugincollection-plugin-not-loaded", this._context, { plugin: e4 });
              }
              return e3;
            }
            has(t3) {
              return this._plugins.has(t3);
            }
            init(t3, e3 = [], n2 = []) {
              const o2 = this, i2 = this._context;
              !function t4(e4, n3 = /* @__PURE__ */ new Set()) {
                e4.forEach((e5) => {
                  c2(e5) && (n3.has(e5) || (n3.add(e5), e5.pluginName && !o2._availablePlugins.has(e5.pluginName) && o2._availablePlugins.set(e5.pluginName, e5), e5.requires && t4(e5.requires, n3)));
                });
              }(t3), u2(t3);
              const r2 = [...function t4(e4, n3 = /* @__PURE__ */ new Set()) {
                return e4.map((t5) => c2(t5) ? t5 : o2._availablePlugins.get(t5)).reduce((e5, o3) => n3.has(o3) ? e5 : (n3.add(o3), o3.requires && (u2(o3.requires, o3), t4(o3.requires, n3).forEach((t5) => e5.add(t5))), e5.add(o3)), /* @__PURE__ */ new Set());
              }(t3.filter((t4) => !d2(t4, e3)))];
              !function(t4, e4) {
                for (const n3 of e4) {
                  if ("function" != typeof n3)
                    throw new a("plugincollection-replace-plugin-invalid-type", null, { pluginItem: n3 });
                  const e5 = n3.pluginName;
                  if (!e5)
                    throw new a("plugincollection-replace-plugin-missing-name", null, { pluginItem: n3 });
                  if (n3.requires && n3.requires.length)
                    throw new a("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: e5 });
                  const i3 = o2._availablePlugins.get(e5);
                  if (!i3)
                    throw new a("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: e5 });
                  const r3 = t4.indexOf(i3);
                  if (-1 === r3) {
                    if (o2._contextPlugins.has(i3))
                      return;
                    throw new a("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: e5 });
                  }
                  if (i3.requires && i3.requires.length)
                    throw new a("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: e5 });
                  t4.splice(r3, 1, n3), o2._availablePlugins.set(e5, n3);
                }
              }(r2, n2);
              const s2 = function(t4) {
                return t4.map((t5) => {
                  const e4 = o2._contextPlugins.get(t5) || new t5(i2);
                  return o2._add(t5, e4), e4;
                });
              }(r2);
              return g2(s2, "init").then(() => g2(s2, "afterInit")).then(() => s2);
              function c2(t4) {
                return "function" == typeof t4;
              }
              function l2(t4) {
                return c2(t4) && t4.isContextPlugin;
              }
              function d2(t4, e4) {
                return e4.some((e5) => e5 === t4 || (h2(t4) === e5 || h2(e5) === t4));
              }
              function h2(t4) {
                return c2(t4) ? t4.pluginName || t4.name : t4;
              }
              function u2(t4, n3 = null) {
                t4.map((t5) => c2(t5) ? t5 : o2._availablePlugins.get(t5) || t5).forEach((t5) => {
                  !function(t6, e4) {
                    if (c2(t6))
                      return;
                    if (e4)
                      throw new a("plugincollection-soft-required", i2, { missingPlugin: t6, requiredBy: h2(e4) });
                    throw new a("plugincollection-plugin-not-found", i2, { plugin: t6 });
                  }(t5, n3), function(t6, e4) {
                    if (!l2(e4))
                      return;
                    if (l2(t6))
                      return;
                    throw new a("plugincollection-context-required", i2, { plugin: h2(t6), requiredBy: h2(e4) });
                  }(t5, n3), function(t6, n4) {
                    if (!n4)
                      return;
                    if (!d2(t6, e3))
                      return;
                    throw new a("plugincollection-required", i2, { plugin: h2(t6), requiredBy: h2(n4) });
                  }(t5, n3);
                });
              }
              function g2(t4, e4) {
                return t4.reduce((t5, n3) => n3[e4] ? o2._contextPlugins.has(n3) ? t5 : t5.then(n3[e4].bind(n3)) : t5, Promise.resolve());
              }
            }
            destroy() {
              const t3 = [];
              for (const [, e3] of this)
                "function" != typeof e3.destroy || this._contextPlugins.has(e3) || t3.push(e3.destroy());
              return Promise.all(t3);
            }
            _add(t3, e3) {
              this._plugins.set(t3, e3);
              const n2 = t3.pluginName;
              if (n2) {
                if (this._plugins.has(n2))
                  throw new a("plugincollection-plugin-name-conflict", null, { pluginName: n2, plugin1: this._plugins.get(n2).constructor, plugin2: t3 });
                this._plugins.set(n2, e3);
              }
            }
          }
          function So(t3) {
            return Array.isArray(t3) ? t3 : [t3];
          }
          function To(t3, e3, n2 = 1) {
            if ("number" != typeof n2)
              throw new a("translation-service-quantity-not-a-number", null, { quantity: n2 });
            const o2 = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
            1 === o2 && (t3 = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
            const i2 = e3.id || e3.string;
            if (0 === o2 || !function(t4, e4) {
              return !!window.CKEDITOR_TRANSLATIONS[t4] && !!window.CKEDITOR_TRANSLATIONS[t4].dictionary[e4];
            }(t3, i2))
              return 1 !== n2 ? e3.plural : e3.string;
            const r2 = window.CKEDITOR_TRANSLATIONS[t3].dictionary, s2 = window.CKEDITOR_TRANSLATIONS[t3].getPluralForm || ((t4) => 1 === t4 ? 0 : 1);
            if ("string" == typeof r2[i2])
              return r2[i2];
            const c2 = Number(s2(n2));
            return r2[i2][c2];
          }
          he(Mo, f), window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
          const No = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
          function Bo(t3) {
            return No.includes(t3) ? "rtl" : "ltr";
          }
          class zo {
            constructor(t3 = {}) {
              this.uiLanguage = t3.uiLanguage || "en", this.contentLanguage = t3.contentLanguage || this.uiLanguage, this.uiLanguageDirection = Bo(this.uiLanguage), this.contentLanguageDirection = Bo(this.contentLanguage), this.t = (t4, e3) => this._t(t4, e3);
            }
            get language() {
              return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
            }
            _t(t3, e3 = []) {
              e3 = So(e3), "string" == typeof t3 && (t3 = { string: t3 });
              const n2 = !!t3.plural ? e3[0] : 1;
              return function(t4, e4) {
                return t4.replace(/%(\d+)/g, (t5, n3) => n3 < e4.length ? e4[n3] : t5);
              }(To(this.uiLanguage, t3, n2), e3);
            }
          }
          class Po {
            constructor(t3) {
              this.config = new yo(t3, this.constructor.defaultConfig);
              const e3 = this.constructor.builtinPlugins;
              this.config.define("plugins", e3), this.plugins = new Mo(this, e3);
              const n2 = this.config.get("language") || {};
              this.locale = new zo({ uiLanguage: "string" == typeof n2 ? n2 : n2.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new Io(), this._contextOwner = null;
            }
            initPlugins() {
              const t3 = this.config.get("plugins") || [], e3 = this.config.get("substitutePlugins") || [];
              for (const n2 of t3.concat(e3)) {
                if ("function" != typeof n2)
                  throw new a("context-initplugins-constructor-only", null, { Plugin: n2 });
                if (true !== n2.isContextPlugin)
                  throw new a("context-initplugins-invalid-plugin", null, { Plugin: n2 });
              }
              return this.plugins.init(t3, [], e3);
            }
            destroy() {
              return Promise.all(Array.from(this.editors, (t3) => t3.destroy())).then(() => this.plugins.destroy());
            }
            _addEditor(t3, e3) {
              if (this._contextOwner)
                throw new a("context-addeditor-private-context");
              this.editors.add(t3), e3 && (this._contextOwner = t3);
            }
            _removeEditor(t3) {
              return this.editors.has(t3) && this.editors.remove(t3), this._contextOwner === t3 ? this.destroy() : Promise.resolve();
            }
            _getEditorConfig() {
              const t3 = {};
              for (const e3 of this.config.names())
                ["plugins", "removePlugins", "extraPlugins"].includes(e3) || (t3[e3] = this.config.get(e3));
              return t3;
            }
            static create(t3) {
              return new Promise((e3) => {
                const n2 = new this(t3);
                e3(n2.initPlugins().then(() => n2));
              });
            }
          }
          class Lo {
            constructor(t3) {
              this.context = t3;
            }
            destroy() {
              this.stopListening();
            }
            static get isContextPlugin() {
              return true;
            }
          }
          function Oo(t3, e3) {
            const n2 = Math.min(t3.length, e3.length);
            for (let o2 = 0; o2 < n2; o2++)
              if (t3[o2] != e3[o2])
                return o2;
            return t3.length == e3.length ? "same" : t3.length < e3.length ? "prefix" : "extension";
          }
          he(Lo, re);
          const Ro = function(t3) {
            return Ao(t3, 4);
          };
          class jo {
            constructor(t3) {
              this.document = t3, this.parent = null;
            }
            get index() {
              let t3;
              if (!this.parent)
                return null;
              if (-1 == (t3 = this.parent.getChildIndex(this)))
                throw new a("view-node-not-found-in-parent", this);
              return t3;
            }
            get nextSibling() {
              const t3 = this.index;
              return null !== t3 && this.parent.getChild(t3 + 1) || null;
            }
            get previousSibling() {
              const t3 = this.index;
              return null !== t3 && this.parent.getChild(t3 - 1) || null;
            }
            get root() {
              let t3 = this;
              for (; t3.parent; )
                t3 = t3.parent;
              return t3;
            }
            isAttached() {
              return this.root.is("rootElement");
            }
            getPath() {
              const t3 = [];
              let e3 = this;
              for (; e3.parent; )
                t3.unshift(e3.index), e3 = e3.parent;
              return t3;
            }
            getAncestors(t3 = { includeSelf: false, parentFirst: false }) {
              const e3 = [];
              let n2 = t3.includeSelf ? this : this.parent;
              for (; n2; )
                e3[t3.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
              return e3;
            }
            getCommonAncestor(t3, e3 = {}) {
              const n2 = this.getAncestors(e3), o2 = t3.getAncestors(e3);
              let i2 = 0;
              for (; n2[i2] == o2[i2] && n2[i2]; )
                i2++;
              return 0 === i2 ? null : n2[i2 - 1];
            }
            isBefore(t3) {
              if (this == t3)
                return false;
              if (this.root !== t3.root)
                return false;
              const e3 = this.getPath(), n2 = t3.getPath(), o2 = Oo(e3, n2);
              switch (o2) {
                case "prefix":
                  return true;
                case "extension":
                  return false;
                default:
                  return e3[o2] < n2[o2];
              }
            }
            isAfter(t3) {
              return this != t3 && (this.root === t3.root && !this.isBefore(t3));
            }
            _remove() {
              this.parent._removeChildren(this.index);
            }
            _fireChange(t3, e3) {
              this.fire("change:" + t3, e3), this.parent && this.parent._fireChange(t3, e3);
            }
            toJSON() {
              const t3 = Ro(this);
              return delete t3.parent, t3;
            }
            is(t3) {
              return "node" === t3 || "view:node" === t3;
            }
          }
          he(jo, f);
          class Fo extends jo {
            constructor(t3, e3) {
              super(t3), this._textData = e3;
            }
            is(t3) {
              return "$text" === t3 || "view:$text" === t3 || "text" === t3 || "view:text" === t3 || "node" === t3 || "view:node" === t3;
            }
            get data() {
              return this._textData;
            }
            get _data() {
              return this.data;
            }
            set _data(t3) {
              this._fireChange("text", this), this._textData = t3;
            }
            isSimilar(t3) {
              return t3 instanceof Fo && (this === t3 || this.data === t3.data);
            }
            _clone() {
              return new Fo(this.document, this.data);
            }
          }
          class Vo {
            constructor(t3, e3, n2) {
              if (this.textNode = t3, e3 < 0 || e3 > t3.data.length)
                throw new a("view-textproxy-wrong-offsetintext", this);
              if (n2 < 0 || e3 + n2 > t3.data.length)
                throw new a("view-textproxy-wrong-length", this);
              this.data = t3.data.substring(e3, e3 + n2), this.offsetInText = e3;
            }
            get offsetSize() {
              return this.data.length;
            }
            get isPartial() {
              return this.data.length !== this.textNode.data.length;
            }
            get parent() {
              return this.textNode.parent;
            }
            get root() {
              return this.textNode.root;
            }
            get document() {
              return this.textNode.document;
            }
            is(t3) {
              return "$textProxy" === t3 || "view:$textProxy" === t3 || "textProxy" === t3 || "view:textProxy" === t3;
            }
            getAncestors(t3 = { includeSelf: false, parentFirst: false }) {
              const e3 = [];
              let n2 = t3.includeSelf ? this.textNode : this.parent;
              for (; null !== n2; )
                e3[t3.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
              return e3;
            }
          }
          function Uo(t3) {
            return Do(t3) ? new Map(t3) : function(t4) {
              const e3 = /* @__PURE__ */ new Map();
              for (const n2 in t4)
                e3.set(n2, t4[n2]);
              return e3;
            }(t3);
          }
          class Ho {
            constructor(...t3) {
              this._patterns = [], this.add(...t3);
            }
            add(...t3) {
              for (let e3 of t3)
                ("string" == typeof e3 || e3 instanceof RegExp) && (e3 = { name: e3 }), this._patterns.push(e3);
            }
            match(...t3) {
              for (const e3 of t3)
                for (const t4 of this._patterns) {
                  const n2 = qo(e3, t4);
                  if (n2)
                    return { element: e3, pattern: t4, match: n2 };
                }
              return null;
            }
            matchAll(...t3) {
              const e3 = [];
              for (const n2 of t3)
                for (const t4 of this._patterns) {
                  const o2 = qo(n2, t4);
                  o2 && e3.push({ element: n2, pattern: t4, match: o2 });
                }
              return e3.length > 0 ? e3 : null;
            }
            getElementName() {
              if (1 !== this._patterns.length)
                return null;
              const t3 = this._patterns[0], e3 = t3.name;
              return "function" == typeof t3 || !e3 || e3 instanceof RegExp ? null : e3;
            }
          }
          function qo(t3, e3) {
            if ("function" == typeof e3)
              return e3(t3);
            const n2 = {};
            return e3.name && (n2.name = function(t4, e4) {
              if (t4 instanceof RegExp)
                return !!e4.match(t4);
              return t4 === e4;
            }(e3.name, t3.name), !n2.name) || e3.attributes && (n2.attributes = function(t4, e4) {
              const n3 = new Set(e4.getAttributeKeys());
              ye(t4) ? (void 0 !== t4.style && c("matcher-pattern-deprecated-attributes-style-key", t4), void 0 !== t4.class && c("matcher-pattern-deprecated-attributes-class-key", t4)) : (n3.delete("style"), n3.delete("class"));
              return Wo(t4, n3, (t5) => e4.getAttribute(t5));
            }(e3.attributes, t3), !n2.attributes) ? null : !(e3.classes && (n2.classes = function(t4, e4) {
              return Wo(t4, e4.getClassNames());
            }(e3.classes, t3), !n2.classes)) && (!(e3.styles && (n2.styles = function(t4, e4) {
              return Wo(t4, e4.getStyleNames(true), (t5) => e4.getStyle(t5));
            }(e3.styles, t3), !n2.styles)) && n2);
          }
          function Wo(t3, e3, n2) {
            const o2 = function(t4) {
              if (Array.isArray(t4))
                return t4.map((t5) => ye(t5) ? (void 0 !== t5.key && void 0 !== t5.value || c("matcher-pattern-missing-key-or-value", t5), [t5.key, t5.value]) : [t5, true]);
              if (ye(t4))
                return Object.entries(t4);
              return [[t4, true]];
            }(t3), i2 = Array.from(e3), r2 = [];
            return o2.forEach(([t4, e4]) => {
              i2.forEach((o3) => {
                (function(t5, e5) {
                  return true === t5 || t5 === e5 || t5 instanceof RegExp && e5.match(t5);
                })(t4, o3) && function(t5, e5, n3) {
                  if (true === t5)
                    return true;
                  const o4 = n3(e5);
                  return t5 === o4 || t5 instanceof RegExp && !!String(o4).match(t5);
                }(e4, o3, n2) && r2.push(o3);
              });
            }), !o2.length || r2.length < o2.length ? null : r2;
          }
          const Go = function(t3) {
            return "symbol" == typeof t3 || _t(t3) && "[object Symbol]" == O(t3);
          };
          var Yo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Qo = /^\w*$/;
          const Ko = function(t3, e3) {
            if (Mt(t3))
              return false;
            var n2 = typeof t3;
            return !("number" != n2 && "symbol" != n2 && "boolean" != n2 && null != t3 && !Go(t3)) || (Qo.test(t3) || !Yo.test(t3) || null != e3 && t3 in Object(e3));
          };
          function $o(t3, e3) {
            if ("function" != typeof t3 || null != e3 && "function" != typeof e3)
              throw new TypeError("Expected a function");
            var n2 = function() {
              var o2 = arguments, i2 = e3 ? e3.apply(this, o2) : o2[0], r2 = n2.cache;
              if (r2.has(i2))
                return r2.get(i2);
              var s2 = t3.apply(this, o2);
              return n2.cache = r2.set(i2, s2) || r2, s2;
            };
            return n2.cache = new ($o.Cache || on)(), n2;
          }
          $o.Cache = on;
          const Zo = $o;
          var Jo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Xo = /\\(\\)?/g, ti = function(t3) {
            var e3 = Zo(t3, function(t4) {
              return 500 === n2.size && n2.clear(), t4;
            }), n2 = e3.cache;
            return e3;
          }(function(t3) {
            var e3 = [];
            return 46 === t3.charCodeAt(0) && e3.push(""), t3.replace(Jo, function(t4, n2, o2, i2) {
              e3.push(o2 ? i2.replace(Xo, "$1") : n2 || t4);
            }), e3;
          });
          const ei = ti;
          const ni = function(t3, e3) {
            for (var n2 = -1, o2 = null == t3 ? 0 : t3.length, i2 = Array(o2); ++n2 < o2; )
              i2[n2] = e3(t3[n2], n2, t3);
            return i2;
          };
          var oi = I ? I.prototype : void 0, ii = oi ? oi.toString : void 0;
          const ri = function t3(e3) {
            if ("string" == typeof e3)
              return e3;
            if (Mt(e3))
              return ni(e3, t3) + "";
            if (Go(e3))
              return ii ? ii.call(e3) : "";
            var n2 = e3 + "";
            return "0" == n2 && 1 / e3 == -Infinity ? "-0" : n2;
          };
          const si = function(t3) {
            return null == t3 ? "" : ri(t3);
          };
          const ai = function(t3, e3) {
            return Mt(t3) ? t3 : Ko(t3, e3) ? [t3] : ei(si(t3));
          };
          const ci = function(t3) {
            var e3 = null == t3 ? 0 : t3.length;
            return e3 ? t3[e3 - 1] : void 0;
          };
          const li = function(t3) {
            if ("string" == typeof t3 || Go(t3))
              return t3;
            var e3 = t3 + "";
            return "0" == e3 && 1 / t3 == -Infinity ? "-0" : e3;
          };
          const di = function(t3, e3) {
            for (var n2 = 0, o2 = (e3 = ai(e3, t3)).length; null != t3 && n2 < o2; )
              t3 = t3[li(e3[n2++])];
            return n2 && n2 == o2 ? t3 : void 0;
          };
          const hi = function(t3, e3, n2) {
            var o2 = -1, i2 = t3.length;
            e3 < 0 && (e3 = -e3 > i2 ? 0 : i2 + e3), (n2 = n2 > i2 ? i2 : n2) < 0 && (n2 += i2), i2 = e3 > n2 ? 0 : n2 - e3 >>> 0, e3 >>>= 0;
            for (var r2 = Array(i2); ++o2 < i2; )
              r2[o2] = t3[o2 + e3];
            return r2;
          };
          const ui = function(t3, e3) {
            return e3.length < 2 ? t3 : di(t3, hi(e3, 0, -1));
          };
          const gi = function(t3, e3) {
            return e3 = ai(e3, t3), null == (t3 = ui(t3, e3)) || delete t3[li(ci(e3))];
          };
          const mi = function(t3, e3) {
            return null == t3 || gi(t3, e3);
          };
          const pi = function(t3, e3, n2) {
            var o2 = null == t3 ? void 0 : di(t3, e3);
            return void 0 === o2 ? n2 : o2;
          };
          const fi = function(t3, e3, n2) {
            (void 0 !== n2 && !et(t3[e3], n2) || void 0 === n2 && !(e3 in t3)) && tt(t3, e3, n2);
          };
          const ki = function(t3) {
            return function(e3, n2, o2) {
              for (var i2 = -1, r2 = Object(e3), s2 = o2(e3), a2 = s2.length; a2--; ) {
                var c2 = s2[t3 ? a2 : ++i2];
                if (false === n2(r2[c2], c2, r2))
                  break;
              }
              return e3;
            };
          }();
          const bi = function(t3) {
            return _t(t3) && ft(t3);
          };
          const wi = function(t3, e3) {
            if (("constructor" !== e3 || "function" != typeof t3[e3]) && "__proto__" != e3)
              return t3[e3];
          };
          const Ci = function(t3) {
            return it(t3, Zt(t3));
          };
          const Ai = function(t3, e3, n2, o2, i2, r2, s2) {
            var a2 = wi(t3, n2), c2 = wi(e3, n2), l2 = s2.get(c2);
            if (l2)
              fi(t3, n2, l2);
            else {
              var d2 = r2 ? r2(a2, c2, n2 + "", t3, e3, s2) : void 0, h2 = void 0 === d2;
              if (h2) {
                var u2 = Mt(c2), g2 = !u2 && zt(c2), m2 = !u2 && !g2 && Ht(c2);
                d2 = c2, u2 || g2 || m2 ? Mt(a2) ? d2 = a2 : bi(a2) ? d2 = Cn(a2) : g2 ? (h2 = false, d2 = wn(c2, true)) : m2 ? (h2 = false, d2 = ro(c2, true)) : d2 = [] : ye(c2) || It(c2) ? (d2 = a2, It(a2) ? d2 = Ci(a2) : y(a2) && !R(a2) || (d2 = lo(c2))) : h2 = false;
              }
              h2 && (s2.set(c2, d2), i2(d2, c2, o2, r2, s2), s2.delete(c2)), fi(t3, n2, d2);
            }
          };
          const _i = function t3(e3, n2, o2, i2, r2) {
            e3 !== n2 && ki(n2, function(s2, a2) {
              if (r2 || (r2 = new an()), y(s2))
                Ai(e3, n2, a2, o2, t3, i2, r2);
              else {
                var c2 = i2 ? i2(wi(e3, a2), s2, a2 + "", e3, n2, r2) : void 0;
                void 0 === c2 && (c2 = s2), fi(e3, a2, c2);
              }
            }, Zt);
          };
          const vi = Ct(function(t3, e3, n2) {
            _i(t3, e3, n2);
          });
          const yi = function(t3, e3, n2, o2) {
            if (!y(t3))
              return t3;
            for (var i2 = -1, r2 = (e3 = ai(e3, t3)).length, s2 = r2 - 1, a2 = t3; null != a2 && ++i2 < r2; ) {
              var c2 = li(e3[i2]), l2 = n2;
              if ("__proto__" === c2 || "constructor" === c2 || "prototype" === c2)
                return t3;
              if (i2 != s2) {
                var d2 = a2[c2];
                void 0 === (l2 = o2 ? o2(d2, c2, a2) : void 0) && (l2 = y(d2) ? d2 : bt(e3[i2 + 1]) ? [] : {});
              }
              ot(a2, c2, l2), a2 = a2[c2];
            }
            return t3;
          };
          const xi = function(t3, e3, n2) {
            return null == t3 ? t3 : yi(t3, e3, n2);
          };
          class Ei {
            constructor(t3) {
              this._styles = {}, this._styleProcessor = t3;
            }
            get isEmpty() {
              const t3 = Object.entries(this._styles);
              return !Array.from(t3).length;
            }
            get size() {
              return this.isEmpty ? 0 : this.getStyleNames().length;
            }
            setTo(t3) {
              this.clear();
              const e3 = Array.from(function(t4) {
                let e4 = null, n2 = 0, o2 = 0, i2 = null;
                const r2 = /* @__PURE__ */ new Map();
                if ("" === t4)
                  return r2;
                ";" != t4.charAt(t4.length - 1) && (t4 += ";");
                for (let s2 = 0; s2 < t4.length; s2++) {
                  const a2 = t4.charAt(s2);
                  if (null === e4)
                    switch (a2) {
                      case ":":
                        i2 || (i2 = t4.substr(n2, s2 - n2), o2 = s2 + 1);
                        break;
                      case '"':
                      case "'":
                        e4 = a2;
                        break;
                      case ";": {
                        const e5 = t4.substr(o2, s2 - o2);
                        i2 && r2.set(i2.trim(), e5.trim()), i2 = null, n2 = s2 + 1;
                        break;
                      }
                    }
                  else
                    a2 === e4 && (e4 = null);
                }
                return r2;
              }(t3).entries());
              for (const [t4, n2] of e3)
                this._styleProcessor.toNormalizedForm(t4, n2, this._styles);
            }
            has(t3) {
              if (this.isEmpty)
                return false;
              const e3 = this._styleProcessor.getReducedForm(t3, this._styles).find(([e4]) => e4 === t3);
              return Array.isArray(e3);
            }
            set(t3, e3) {
              if (y(t3))
                for (const [e4, n2] of Object.entries(t3))
                  this._styleProcessor.toNormalizedForm(e4, n2, this._styles);
              else
                this._styleProcessor.toNormalizedForm(t3, e3, this._styles);
            }
            remove(t3) {
              const e3 = Ii(t3);
              mi(this._styles, e3), delete this._styles[t3], this._cleanEmptyObjectsOnPath(e3);
            }
            getNormalized(t3) {
              return this._styleProcessor.getNormalized(t3, this._styles);
            }
            toString() {
              return this.isEmpty ? "" : this._getStylesEntries().map((t3) => t3.join(":")).sort().join(";") + ";";
            }
            getAsString(t3) {
              if (this.isEmpty)
                return;
              if (this._styles[t3] && !y(this._styles[t3]))
                return this._styles[t3];
              const e3 = this._styleProcessor.getReducedForm(t3, this._styles).find(([e4]) => e4 === t3);
              return Array.isArray(e3) ? e3[1] : void 0;
            }
            getStyleNames(t3 = false) {
              if (this.isEmpty)
                return [];
              if (t3)
                return this._styleProcessor.getStyleNames(this._styles);
              return this._getStylesEntries().map(([t4]) => t4);
            }
            clear() {
              this._styles = {};
            }
            _getStylesEntries() {
              const t3 = [], e3 = Object.keys(this._styles);
              for (const n2 of e3)
                t3.push(...this._styleProcessor.getReducedForm(n2, this._styles));
              return t3;
            }
            _cleanEmptyObjectsOnPath(t3) {
              const e3 = t3.split(".");
              if (!(e3.length > 1))
                return;
              const n2 = e3.splice(0, e3.length - 1).join("."), o2 = pi(this._styles, n2);
              if (!o2)
                return;
              !Array.from(Object.keys(o2)).length && this.remove(n2);
            }
          }
          class Di {
            constructor() {
              this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
            }
            toNormalizedForm(t3, e3, n2) {
              if (y(e3))
                Mi(n2, Ii(t3), e3);
              else if (this._normalizers.has(t3)) {
                const o2 = this._normalizers.get(t3), { path: i2, value: r2 } = o2(e3);
                Mi(n2, i2, r2);
              } else
                Mi(n2, t3, e3);
            }
            getNormalized(t3, e3) {
              if (!t3)
                return vi({}, e3);
              if (void 0 !== e3[t3])
                return e3[t3];
              if (this._extractors.has(t3)) {
                const n2 = this._extractors.get(t3);
                if ("string" == typeof n2)
                  return pi(e3, n2);
                const o2 = n2(t3, e3);
                if (o2)
                  return o2;
              }
              return pi(e3, Ii(t3));
            }
            getReducedForm(t3, e3) {
              const n2 = this.getNormalized(t3, e3);
              if (void 0 === n2)
                return [];
              if (this._reducers.has(t3)) {
                return this._reducers.get(t3)(n2);
              }
              return [[t3, n2]];
            }
            getStyleNames(t3) {
              const e3 = Array.from(this._consumables.keys()).filter((e4) => {
                const n3 = this.getNormalized(e4, t3);
                return n3 && "object" == typeof n3 ? Object.keys(n3).length : n3;
              }), n2 = /* @__PURE__ */ new Set([...e3, ...Object.keys(t3)]);
              return Array.from(n2.values());
            }
            getRelatedStyles(t3) {
              return this._consumables.get(t3) || [];
            }
            setNormalizer(t3, e3) {
              this._normalizers.set(t3, e3);
            }
            setExtractor(t3, e3) {
              this._extractors.set(t3, e3);
            }
            setReducer(t3, e3) {
              this._reducers.set(t3, e3);
            }
            setStyleRelation(t3, e3) {
              this._mapStyleNames(t3, e3);
              for (const n2 of e3)
                this._mapStyleNames(n2, [t3]);
            }
            _mapStyleNames(t3, e3) {
              this._consumables.has(t3) || this._consumables.set(t3, []), this._consumables.get(t3).push(...e3);
            }
          }
          function Ii(t3) {
            return t3.replace("-", ".");
          }
          function Mi(t3, e3, n2) {
            let o2 = n2;
            y(n2) && (o2 = vi({}, pi(t3, e3), n2)), xi(t3, e3, o2);
          }
          class Si extends jo {
            constructor(t3, e3, n2, o2) {
              if (super(t3), this.name = e3, this._attrs = function(t4) {
                t4 = Uo(t4);
                for (const [e4, n3] of t4)
                  null === n3 ? t4.delete(e4) : "string" != typeof n3 && t4.set(e4, String(n3));
                return t4;
              }(n2), this._children = [], o2 && this._insertChild(0, o2), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
                const t4 = this._attrs.get("class");
                Ti(this._classes, t4), this._attrs.delete("class");
              }
              this._styles = new Ei(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style")), this._customProperties = /* @__PURE__ */ new Map(), this._isAllowedInsideAttributeElement = false, this._unsafeAttributesToRender = [];
            }
            get childCount() {
              return this._children.length;
            }
            get isEmpty() {
              return 0 === this._children.length;
            }
            get isAllowedInsideAttributeElement() {
              return this._isAllowedInsideAttributeElement;
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("element" === t3 || "view:element" === t3) : "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            getChild(t3) {
              return this._children[t3];
            }
            getChildIndex(t3) {
              return this._children.indexOf(t3);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            *getAttributeKeys() {
              this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
            }
            *getAttributes() {
              yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
            }
            getAttribute(t3) {
              if ("class" == t3)
                return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
              if ("style" == t3) {
                const t4 = this._styles.toString();
                return "" == t4 ? void 0 : t4;
              }
              return this._attrs.get(t3);
            }
            hasAttribute(t3) {
              return "class" == t3 ? this._classes.size > 0 : "style" == t3 ? !this._styles.isEmpty : this._attrs.has(t3);
            }
            isSimilar(t3) {
              if (!(t3 instanceof Si))
                return false;
              if (this === t3)
                return true;
              if (this.name != t3.name)
                return false;
              if (this.isAllowedInsideAttributeElement != t3.isAllowedInsideAttributeElement)
                return false;
              if (this._attrs.size !== t3._attrs.size || this._classes.size !== t3._classes.size || this._styles.size !== t3._styles.size)
                return false;
              for (const [e3, n2] of this._attrs)
                if (!t3._attrs.has(e3) || t3._attrs.get(e3) !== n2)
                  return false;
              for (const e3 of this._classes)
                if (!t3._classes.has(e3))
                  return false;
              for (const e3 of this._styles.getStyleNames())
                if (!t3._styles.has(e3) || t3._styles.getAsString(e3) !== this._styles.getAsString(e3))
                  return false;
              return true;
            }
            hasClass(...t3) {
              for (const e3 of t3)
                if (!this._classes.has(e3))
                  return false;
              return true;
            }
            getClassNames() {
              return this._classes.keys();
            }
            getStyle(t3) {
              return this._styles.getAsString(t3);
            }
            getNormalizedStyle(t3) {
              return this._styles.getNormalized(t3);
            }
            getStyleNames(t3 = false) {
              return this._styles.getStyleNames(t3);
            }
            hasStyle(...t3) {
              for (const e3 of t3)
                if (!this._styles.has(e3))
                  return false;
              return true;
            }
            findAncestor(...t3) {
              const e3 = new Ho(...t3);
              let n2 = this.parent;
              for (; n2; ) {
                if (e3.match(n2))
                  return n2;
                n2 = n2.parent;
              }
              return null;
            }
            getCustomProperty(t3) {
              return this._customProperties.get(t3);
            }
            *getCustomProperties() {
              yield* this._customProperties.entries();
            }
            getIdentity() {
              const t3 = Array.from(this._classes).sort().join(","), e3 = this._styles.toString(), n2 = Array.from(this._attrs).map((t4) => `${t4[0]}="${t4[1]}"`).sort().join(" ");
              return this.name + ("" == t3 ? "" : ` class="${t3}"`) + (e3 ? ` style="${e3}"` : "") + ("" == n2 ? "" : ` ${n2}`);
            }
            shouldRenderUnsafeAttribute(t3) {
              return this._unsafeAttributesToRender.includes(t3);
            }
            _clone(t3 = false) {
              const e3 = [];
              if (t3)
                for (const n3 of this.getChildren())
                  e3.push(n3._clone(t3));
              const n2 = new this.constructor(this.document, this.name, this._attrs, e3);
              return n2._classes = new Set(this._classes), n2._styles.set(this._styles.getNormalized()), n2._customProperties = new Map(this._customProperties), n2.getFillerOffset = this.getFillerOffset, n2._isAllowedInsideAttributeElement = this.isAllowedInsideAttributeElement, n2;
            }
            _appendChild(t3) {
              return this._insertChild(this.childCount, t3);
            }
            _insertChild(t3, e3) {
              this._fireChange("children", this);
              let n2 = 0;
              const o2 = function(t4, e4) {
                if ("string" == typeof e4)
                  return [new Fo(t4, e4)];
                Do(e4) || (e4 = [e4]);
                return Array.from(e4).map((e5) => "string" == typeof e5 ? new Fo(t4, e5) : e5 instanceof Vo ? new Fo(t4, e5.data) : e5);
              }(this.document, e3);
              for (const e4 of o2)
                null !== e4.parent && e4._remove(), e4.parent = this, e4.document = this.document, this._children.splice(t3, 0, e4), t3++, n2++;
              return n2;
            }
            _removeChildren(t3, e3 = 1) {
              this._fireChange("children", this);
              for (let n2 = t3; n2 < t3 + e3; n2++)
                this._children[n2].parent = null;
              return this._children.splice(t3, e3);
            }
            _setAttribute(t3, e3) {
              e3 = String(e3), this._fireChange("attributes", this), "class" == t3 ? Ti(this._classes, e3) : "style" == t3 ? this._styles.setTo(e3) : this._attrs.set(t3, e3);
            }
            _removeAttribute(t3) {
              return this._fireChange("attributes", this), "class" == t3 ? this._classes.size > 0 && (this._classes.clear(), true) : "style" == t3 ? !this._styles.isEmpty && (this._styles.clear(), true) : this._attrs.delete(t3);
            }
            _addClass(t3) {
              this._fireChange("attributes", this);
              for (const e3 of So(t3))
                this._classes.add(e3);
            }
            _removeClass(t3) {
              this._fireChange("attributes", this);
              for (const e3 of So(t3))
                this._classes.delete(e3);
            }
            _setStyle(t3, e3) {
              this._fireChange("attributes", this), this._styles.set(t3, e3);
            }
            _removeStyle(t3) {
              this._fireChange("attributes", this);
              for (const e3 of So(t3))
                this._styles.remove(e3);
            }
            _setCustomProperty(t3, e3) {
              this._customProperties.set(t3, e3);
            }
            _removeCustomProperty(t3) {
              return this._customProperties.delete(t3);
            }
          }
          function Ti(t3, e3) {
            const n2 = e3.split(/\s+/);
            t3.clear(), n2.forEach((e4) => t3.add(e4));
          }
          class Ni extends Si {
            constructor(t3, e3, n2, o2) {
              super(t3, e3, n2, o2), this.getFillerOffset = Bi;
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("containerElement" === t3 || "view:containerElement" === t3 || "element" === t3 || "view:element" === t3) : "containerElement" === t3 || "view:containerElement" === t3 || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
          }
          function Bi() {
            const t3 = [...this.getChildren()], e3 = t3[this.childCount - 1];
            if (e3 && e3.is("element", "br"))
              return this.childCount;
            for (const e4 of t3)
              if (!e4.is("uiElement"))
                return null;
            return this.childCount;
          }
          class zi extends Ni {
            constructor(t3, e3, n2, o2) {
              super(t3, e3, n2, o2), this.set("isReadOnly", false), this.set("isFocused", false), this.bind("isReadOnly").to(t3), this.bind("isFocused").to(t3, "isFocused", (e4) => e4 && t3.selection.editableElement == this), this.listenTo(t3.selection, "change", () => {
                this.isFocused = t3.isFocused && t3.selection.editableElement == this;
              });
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("editableElement" === t3 || "view:editableElement" === t3 || "containerElement" === t3 || "view:containerElement" === t3 || "element" === t3 || "view:element" === t3) : "editableElement" === t3 || "view:editableElement" === t3 || "containerElement" === t3 || "view:containerElement" === t3 || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            destroy() {
              this.stopListening();
            }
          }
          he(zi, re);
          const Pi = Symbol("rootName");
          class Li extends zi {
            constructor(t3, e3) {
              super(t3, e3), this.rootName = "main";
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("rootElement" === t3 || "view:rootElement" === t3 || "editableElement" === t3 || "view:editableElement" === t3 || "containerElement" === t3 || "view:containerElement" === t3 || "element" === t3 || "view:element" === t3) : "rootElement" === t3 || "view:rootElement" === t3 || "editableElement" === t3 || "view:editableElement" === t3 || "containerElement" === t3 || "view:containerElement" === t3 || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            get rootName() {
              return this.getCustomProperty(Pi);
            }
            set rootName(t3) {
              this._setCustomProperty(Pi, t3);
            }
            set _name(t3) {
              this.name = t3;
            }
          }
          class Oi {
            constructor(t3 = {}) {
              if (!t3.boundaries && !t3.startPosition)
                throw new a("view-tree-walker-no-start-position", null);
              if (t3.direction && "forward" != t3.direction && "backward" != t3.direction)
                throw new a("view-tree-walker-unknown-direction", t3.startPosition, { direction: t3.direction });
              this.boundaries = t3.boundaries || null, t3.startPosition ? this.position = Ri._createAt(t3.startPosition) : this.position = Ri._createAt(t3.boundaries["backward" == t3.direction ? "end" : "start"]), this.direction = t3.direction || "forward", this.singleCharacters = !!t3.singleCharacters, this.shallow = !!t3.shallow, this.ignoreElementEnd = !!t3.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
            }
            [Symbol.iterator]() {
              return this;
            }
            skip(t3) {
              let e3, n2, o2;
              do {
                o2 = this.position, { done: e3, value: n2 } = this.next();
              } while (!e3 && t3(n2));
              e3 || (this.position = o2);
            }
            next() {
              return "forward" == this.direction ? this._next() : this._previous();
            }
            _next() {
              let t3 = this.position.clone();
              const e3 = this.position, n2 = t3.parent;
              if (null === n2.parent && t3.offset === n2.childCount)
                return { done: true };
              if (n2 === this._boundaryEndParent && t3.offset == this.boundaries.end.offset)
                return { done: true };
              let o2;
              if (n2 instanceof Fo) {
                if (t3.isAtEnd)
                  return this.position = Ri._createAfter(n2), this._next();
                o2 = n2.data[t3.offset];
              } else
                o2 = n2.getChild(t3.offset);
              if (o2 instanceof Si)
                return this.shallow ? t3.offset++ : t3 = new Ri(o2, 0), this.position = t3, this._formatReturnValue("elementStart", o2, e3, t3, 1);
              if (o2 instanceof Fo) {
                if (this.singleCharacters)
                  return t3 = new Ri(o2, 0), this.position = t3, this._next();
                {
                  let n3, i2 = o2.data.length;
                  return o2 == this._boundaryEndParent ? (i2 = this.boundaries.end.offset, n3 = new Vo(o2, 0, i2), t3 = Ri._createAfter(n3)) : (n3 = new Vo(o2, 0, o2.data.length), t3.offset++), this.position = t3, this._formatReturnValue("text", n3, e3, t3, i2);
                }
              }
              if ("string" == typeof o2) {
                let o3;
                if (this.singleCharacters)
                  o3 = 1;
                else {
                  o3 = (n2 === this._boundaryEndParent ? this.boundaries.end.offset : n2.data.length) - t3.offset;
                }
                const i2 = new Vo(n2, t3.offset, o3);
                return t3.offset += o3, this.position = t3, this._formatReturnValue("text", i2, e3, t3, o3);
              }
              return t3 = Ri._createAfter(n2), this.position = t3, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n2, e3, t3);
            }
            _previous() {
              let t3 = this.position.clone();
              const e3 = this.position, n2 = t3.parent;
              if (null === n2.parent && 0 === t3.offset)
                return { done: true };
              if (n2 == this._boundaryStartParent && t3.offset == this.boundaries.start.offset)
                return { done: true };
              let o2;
              if (n2 instanceof Fo) {
                if (t3.isAtStart)
                  return this.position = Ri._createBefore(n2), this._previous();
                o2 = n2.data[t3.offset - 1];
              } else
                o2 = n2.getChild(t3.offset - 1);
              if (o2 instanceof Si)
                return this.shallow ? (t3.offset--, this.position = t3, this._formatReturnValue("elementStart", o2, e3, t3, 1)) : (t3 = new Ri(o2, o2.childCount), this.position = t3, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", o2, e3, t3));
              if (o2 instanceof Fo) {
                if (this.singleCharacters)
                  return t3 = new Ri(o2, o2.data.length), this.position = t3, this._previous();
                {
                  let n3, i2 = o2.data.length;
                  if (o2 == this._boundaryStartParent) {
                    const e4 = this.boundaries.start.offset;
                    n3 = new Vo(o2, e4, o2.data.length - e4), i2 = n3.data.length, t3 = Ri._createBefore(n3);
                  } else
                    n3 = new Vo(o2, 0, o2.data.length), t3.offset--;
                  return this.position = t3, this._formatReturnValue("text", n3, e3, t3, i2);
                }
              }
              if ("string" == typeof o2) {
                let o3;
                if (this.singleCharacters)
                  o3 = 1;
                else {
                  const e4 = n2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                  o3 = t3.offset - e4;
                }
                t3.offset -= o3;
                const i2 = new Vo(n2, t3.offset, o3);
                return this.position = t3, this._formatReturnValue("text", i2, e3, t3, o3);
              }
              return t3 = Ri._createBefore(n2), this.position = t3, this._formatReturnValue("elementStart", n2, e3, t3, 1);
            }
            _formatReturnValue(t3, e3, n2, o2, i2) {
              return e3 instanceof Vo && (e3.offsetInText + e3.data.length == e3.textNode.data.length && ("forward" != this.direction || this.boundaries && this.boundaries.end.isEqual(this.position) ? n2 = Ri._createAfter(e3.textNode) : (o2 = Ri._createAfter(e3.textNode), this.position = o2)), 0 === e3.offsetInText && ("backward" != this.direction || this.boundaries && this.boundaries.start.isEqual(this.position) ? n2 = Ri._createBefore(e3.textNode) : (o2 = Ri._createBefore(e3.textNode), this.position = o2))), { done: false, value: { type: t3, item: e3, previousPosition: n2, nextPosition: o2, length: i2 } };
            }
          }
          class Ri {
            constructor(t3, e3) {
              this.parent = t3, this.offset = e3;
            }
            get nodeAfter() {
              return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
            }
            get nodeBefore() {
              return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
            }
            get isAtStart() {
              return 0 === this.offset;
            }
            get isAtEnd() {
              const t3 = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
              return this.offset === t3;
            }
            get root() {
              return this.parent.root;
            }
            get editableElement() {
              let t3 = this.parent;
              for (; !(t3 instanceof zi); ) {
                if (!t3.parent)
                  return null;
                t3 = t3.parent;
              }
              return t3;
            }
            getShiftedBy(t3) {
              const e3 = Ri._createAt(this), n2 = e3.offset + t3;
              return e3.offset = n2 < 0 ? 0 : n2, e3;
            }
            getLastMatchingPosition(t3, e3 = {}) {
              e3.startPosition = this;
              const n2 = new Oi(e3);
              return n2.skip(t3), n2.position;
            }
            getAncestors() {
              return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: true });
            }
            getCommonAncestor(t3) {
              const e3 = this.getAncestors(), n2 = t3.getAncestors();
              let o2 = 0;
              for (; e3[o2] == n2[o2] && e3[o2]; )
                o2++;
              return 0 === o2 ? null : e3[o2 - 1];
            }
            is(t3) {
              return "position" === t3 || "view:position" === t3;
            }
            isEqual(t3) {
              return this.parent == t3.parent && this.offset == t3.offset;
            }
            isBefore(t3) {
              return "before" == this.compareWith(t3);
            }
            isAfter(t3) {
              return "after" == this.compareWith(t3);
            }
            compareWith(t3) {
              if (this.root !== t3.root)
                return "different";
              if (this.isEqual(t3))
                return "same";
              const e3 = this.parent.is("node") ? this.parent.getPath() : [], n2 = t3.parent.is("node") ? t3.parent.getPath() : [];
              e3.push(this.offset), n2.push(t3.offset);
              const o2 = Oo(e3, n2);
              switch (o2) {
                case "prefix":
                  return "before";
                case "extension":
                  return "after";
                default:
                  return e3[o2] < n2[o2] ? "before" : "after";
              }
            }
            getWalker(t3 = {}) {
              return t3.startPosition = this, new Oi(t3);
            }
            clone() {
              return new Ri(this.parent, this.offset);
            }
            static _createAt(t3, e3) {
              if (t3 instanceof Ri)
                return new this(t3.parent, t3.offset);
              {
                const n2 = t3;
                if ("end" == e3)
                  e3 = n2.is("$text") ? n2.data.length : n2.childCount;
                else {
                  if ("before" == e3)
                    return this._createBefore(n2);
                  if ("after" == e3)
                    return this._createAfter(n2);
                  if (0 !== e3 && !e3)
                    throw new a("view-createpositionat-offset-required", n2);
                }
                return new Ri(n2, e3);
              }
            }
            static _createAfter(t3) {
              if (t3.is("$textProxy"))
                return new Ri(t3.textNode, t3.offsetInText + t3.data.length);
              if (!t3.parent)
                throw new a("view-position-after-root", t3, { root: t3 });
              return new Ri(t3.parent, t3.index + 1);
            }
            static _createBefore(t3) {
              if (t3.is("$textProxy"))
                return new Ri(t3.textNode, t3.offsetInText);
              if (!t3.parent)
                throw new a("view-position-before-root", t3, { root: t3 });
              return new Ri(t3.parent, t3.index);
            }
          }
          class ji {
            constructor(t3, e3 = null) {
              this.start = t3.clone(), this.end = e3 ? e3.clone() : t3.clone();
            }
            *[Symbol.iterator]() {
              yield* new Oi({ boundaries: this, ignoreElementEnd: true });
            }
            get isCollapsed() {
              return this.start.isEqual(this.end);
            }
            get isFlat() {
              return this.start.parent === this.end.parent;
            }
            get root() {
              return this.start.root;
            }
            getEnlarged() {
              let t3 = this.start.getLastMatchingPosition(Fi, { direction: "backward" }), e3 = this.end.getLastMatchingPosition(Fi);
              return t3.parent.is("$text") && t3.isAtStart && (t3 = Ri._createBefore(t3.parent)), e3.parent.is("$text") && e3.isAtEnd && (e3 = Ri._createAfter(e3.parent)), new ji(t3, e3);
            }
            getTrimmed() {
              let t3 = this.start.getLastMatchingPosition(Fi);
              if (t3.isAfter(this.end) || t3.isEqual(this.end))
                return new ji(t3, t3);
              let e3 = this.end.getLastMatchingPosition(Fi, { direction: "backward" });
              const n2 = t3.nodeAfter, o2 = e3.nodeBefore;
              return n2 && n2.is("$text") && (t3 = new Ri(n2, 0)), o2 && o2.is("$text") && (e3 = new Ri(o2, o2.data.length)), new ji(t3, e3);
            }
            isEqual(t3) {
              return this == t3 || this.start.isEqual(t3.start) && this.end.isEqual(t3.end);
            }
            containsPosition(t3) {
              return t3.isAfter(this.start) && t3.isBefore(this.end);
            }
            containsRange(t3, e3 = false) {
              t3.isCollapsed && (e3 = false);
              const n2 = this.containsPosition(t3.start) || e3 && this.start.isEqual(t3.start), o2 = this.containsPosition(t3.end) || e3 && this.end.isEqual(t3.end);
              return n2 && o2;
            }
            getDifference(t3) {
              const e3 = [];
              return this.isIntersecting(t3) ? (this.containsPosition(t3.start) && e3.push(new ji(this.start, t3.start)), this.containsPosition(t3.end) && e3.push(new ji(t3.end, this.end))) : e3.push(this.clone()), e3;
            }
            getIntersection(t3) {
              if (this.isIntersecting(t3)) {
                let e3 = this.start, n2 = this.end;
                return this.containsPosition(t3.start) && (e3 = t3.start), this.containsPosition(t3.end) && (n2 = t3.end), new ji(e3, n2);
              }
              return null;
            }
            getWalker(t3 = {}) {
              return t3.boundaries = this, new Oi(t3);
            }
            getCommonAncestor() {
              return this.start.getCommonAncestor(this.end);
            }
            getContainedElement() {
              if (this.isCollapsed)
                return null;
              let t3 = this.start.nodeAfter, e3 = this.end.nodeBefore;
              return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (t3 = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (e3 = this.end.parent.previousSibling), t3 && t3.is("element") && t3 === e3 ? t3 : null;
            }
            clone() {
              return new ji(this.start, this.end);
            }
            *getItems(t3 = {}) {
              t3.boundaries = this, t3.ignoreElementEnd = true;
              const e3 = new Oi(t3);
              for (const t4 of e3)
                yield t4.item;
            }
            *getPositions(t3 = {}) {
              t3.boundaries = this;
              const e3 = new Oi(t3);
              yield e3.position;
              for (const t4 of e3)
                yield t4.nextPosition;
            }
            is(t3) {
              return "range" === t3 || "view:range" === t3;
            }
            isIntersecting(t3) {
              return this.start.isBefore(t3.end) && this.end.isAfter(t3.start);
            }
            static _createFromParentsAndOffsets(t3, e3, n2, o2) {
              return new this(new Ri(t3, e3), new Ri(n2, o2));
            }
            static _createFromPositionAndShift(t3, e3) {
              const n2 = t3, o2 = t3.getShiftedBy(e3);
              return e3 > 0 ? new this(n2, o2) : new this(o2, n2);
            }
            static _createIn(t3) {
              return this._createFromParentsAndOffsets(t3, 0, t3, t3.childCount);
            }
            static _createOn(t3) {
              const e3 = t3.is("$textProxy") ? t3.offsetSize : 1;
              return this._createFromPositionAndShift(Ri._createBefore(t3), e3);
            }
          }
          function Fi(t3) {
            return !(!t3.item.is("attributeElement") && !t3.item.is("uiElement"));
          }
          function Vi(t3) {
            let e3 = 0;
            for (const n2 of t3)
              e3++;
            return e3;
          }
          class Ui {
            constructor(t3 = null, e3, n2) {
              this._ranges = [], this._lastRangeBackward = false, this._isFake = false, this._fakeSelectionLabel = "", this.setTo(t3, e3, n2);
            }
            get isFake() {
              return this._isFake;
            }
            get fakeSelectionLabel() {
              return this._fakeSelectionLabel;
            }
            get anchor() {
              if (!this._ranges.length)
                return null;
              const t3 = this._ranges[this._ranges.length - 1];
              return (this._lastRangeBackward ? t3.end : t3.start).clone();
            }
            get focus() {
              if (!this._ranges.length)
                return null;
              const t3 = this._ranges[this._ranges.length - 1];
              return (this._lastRangeBackward ? t3.start : t3.end).clone();
            }
            get isCollapsed() {
              return 1 === this.rangeCount && this._ranges[0].isCollapsed;
            }
            get rangeCount() {
              return this._ranges.length;
            }
            get isBackward() {
              return !this.isCollapsed && this._lastRangeBackward;
            }
            get editableElement() {
              return this.anchor ? this.anchor.editableElement : null;
            }
            *getRanges() {
              for (const t3 of this._ranges)
                yield t3.clone();
            }
            getFirstRange() {
              let t3 = null;
              for (const e3 of this._ranges)
                t3 && !e3.start.isBefore(t3.start) || (t3 = e3);
              return t3 ? t3.clone() : null;
            }
            getLastRange() {
              let t3 = null;
              for (const e3 of this._ranges)
                t3 && !e3.end.isAfter(t3.end) || (t3 = e3);
              return t3 ? t3.clone() : null;
            }
            getFirstPosition() {
              const t3 = this.getFirstRange();
              return t3 ? t3.start.clone() : null;
            }
            getLastPosition() {
              const t3 = this.getLastRange();
              return t3 ? t3.end.clone() : null;
            }
            isEqual(t3) {
              if (this.isFake != t3.isFake)
                return false;
              if (this.isFake && this.fakeSelectionLabel != t3.fakeSelectionLabel)
                return false;
              if (this.rangeCount != t3.rangeCount)
                return false;
              if (0 === this.rangeCount)
                return true;
              if (!this.anchor.isEqual(t3.anchor) || !this.focus.isEqual(t3.focus))
                return false;
              for (const e3 of this._ranges) {
                let n2 = false;
                for (const o2 of t3._ranges)
                  if (e3.isEqual(o2)) {
                    n2 = true;
                    break;
                  }
                if (!n2)
                  return false;
              }
              return true;
            }
            isSimilar(t3) {
              if (this.isBackward != t3.isBackward)
                return false;
              const e3 = Vi(this.getRanges());
              if (e3 != Vi(t3.getRanges()))
                return false;
              if (0 == e3)
                return true;
              for (let e4 of this.getRanges()) {
                e4 = e4.getTrimmed();
                let n2 = false;
                for (let o2 of t3.getRanges())
                  if (o2 = o2.getTrimmed(), e4.start.isEqual(o2.start) && e4.end.isEqual(o2.end)) {
                    n2 = true;
                    break;
                  }
                if (!n2)
                  return false;
              }
              return true;
            }
            getSelectedElement() {
              return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
            }
            setTo(t3, e3, n2) {
              if (null === t3)
                this._setRanges([]), this._setFakeOptions(e3);
              else if (t3 instanceof Ui || t3 instanceof Hi)
                this._setRanges(t3.getRanges(), t3.isBackward), this._setFakeOptions({ fake: t3.isFake, label: t3.fakeSelectionLabel });
              else if (t3 instanceof ji)
                this._setRanges([t3], e3 && e3.backward), this._setFakeOptions(e3);
              else if (t3 instanceof Ri)
                this._setRanges([new ji(t3)]), this._setFakeOptions(e3);
              else if (t3 instanceof jo) {
                const o2 = !!n2 && !!n2.backward;
                let i2;
                if (void 0 === e3)
                  throw new a("view-selection-setto-required-second-parameter", this);
                i2 = "in" == e3 ? ji._createIn(t3) : "on" == e3 ? ji._createOn(t3) : new ji(Ri._createAt(t3, e3)), this._setRanges([i2], o2), this._setFakeOptions(n2);
              } else {
                if (!Do(t3))
                  throw new a("view-selection-setto-not-selectable", this);
                this._setRanges(t3, e3 && e3.backward), this._setFakeOptions(e3);
              }
              this.fire("change");
            }
            setFocus(t3, e3) {
              if (null === this.anchor)
                throw new a("view-selection-setfocus-no-ranges", this);
              const n2 = Ri._createAt(t3, e3);
              if ("same" == n2.compareWith(this.focus))
                return;
              const o2 = this.anchor;
              this._ranges.pop(), "before" == n2.compareWith(o2) ? this._addRange(new ji(n2, o2), true) : this._addRange(new ji(o2, n2)), this.fire("change");
            }
            is(t3) {
              return "selection" === t3 || "view:selection" === t3;
            }
            _setRanges(t3, e3 = false) {
              t3 = Array.from(t3), this._ranges = [];
              for (const e4 of t3)
                this._addRange(e4);
              this._lastRangeBackward = !!e3;
            }
            _setFakeOptions(t3 = {}) {
              this._isFake = !!t3.fake, this._fakeSelectionLabel = t3.fake && t3.label || "";
            }
            _addRange(t3, e3 = false) {
              if (!(t3 instanceof ji))
                throw new a("view-selection-add-range-not-range", this);
              this._pushRange(t3), this._lastRangeBackward = !!e3;
            }
            _pushRange(t3) {
              for (const e3 of this._ranges)
                if (t3.isIntersecting(e3))
                  throw new a("view-selection-range-intersects", this, { addedRange: t3, intersectingRange: e3 });
              this._ranges.push(new ji(t3.start, t3.end));
            }
          }
          he(Ui, f);
          class Hi {
            constructor(t3 = null, e3, n2) {
              this._selection = new Ui(), this._selection.delegate("change").to(this), this._selection.setTo(t3, e3, n2);
            }
            get isFake() {
              return this._selection.isFake;
            }
            get fakeSelectionLabel() {
              return this._selection.fakeSelectionLabel;
            }
            get anchor() {
              return this._selection.anchor;
            }
            get focus() {
              return this._selection.focus;
            }
            get isCollapsed() {
              return this._selection.isCollapsed;
            }
            get rangeCount() {
              return this._selection.rangeCount;
            }
            get isBackward() {
              return this._selection.isBackward;
            }
            get editableElement() {
              return this._selection.editableElement;
            }
            get _ranges() {
              return this._selection._ranges;
            }
            *getRanges() {
              yield* this._selection.getRanges();
            }
            getFirstRange() {
              return this._selection.getFirstRange();
            }
            getLastRange() {
              return this._selection.getLastRange();
            }
            getFirstPosition() {
              return this._selection.getFirstPosition();
            }
            getLastPosition() {
              return this._selection.getLastPosition();
            }
            getSelectedElement() {
              return this._selection.getSelectedElement();
            }
            isEqual(t3) {
              return this._selection.isEqual(t3);
            }
            isSimilar(t3) {
              return this._selection.isSimilar(t3);
            }
            is(t3) {
              return "selection" === t3 || "documentSelection" == t3 || "view:selection" == t3 || "view:documentSelection" == t3;
            }
            _setTo(t3, e3, n2) {
              this._selection.setTo(t3, e3, n2);
            }
            _setFocus(t3, e3) {
              this._selection.setFocus(t3, e3);
            }
          }
          he(Hi, f);
          class qi extends e2 {
            constructor(t3, e3, n2) {
              super(t3, e3), this.startRange = n2, this._eventPhase = "none", this._currentTarget = null;
            }
            get eventPhase() {
              return this._eventPhase;
            }
            get currentTarget() {
              return this._currentTarget;
            }
          }
          const Wi = Symbol("bubbling contexts"), Gi = { fire(t3, ...n2) {
            try {
              const o2 = t3 instanceof e2 ? t3 : new e2(this, t3), i2 = Zi(this);
              if (!i2.size)
                return;
              if (Qi(o2, "capturing", this), Ki(i2, "$capture", o2, ...n2))
                return o2.return;
              const r2 = o2.startRange || this.selection.getFirstRange(), s2 = r2 ? r2.getContainedElement() : null, a2 = !!s2 && Boolean($i(i2, s2));
              let c2 = s2 || function(t4) {
                if (!t4)
                  return null;
                const e3 = t4.start.parent, n3 = t4.end.parent, o3 = e3.getPath(), i3 = n3.getPath();
                return o3.length > i3.length ? e3 : n3;
              }(r2);
              if (Qi(o2, "atTarget", c2), !a2) {
                if (Ki(i2, "$text", o2, ...n2))
                  return o2.return;
                Qi(o2, "bubbling", c2);
              }
              for (; c2; ) {
                if (c2.is("rootElement")) {
                  if (Ki(i2, "$root", o2, ...n2))
                    return o2.return;
                } else if (c2.is("element") && Ki(i2, c2.name, o2, ...n2))
                  return o2.return;
                if (Ki(i2, c2, o2, ...n2))
                  return o2.return;
                c2 = c2.parent, Qi(o2, "bubbling", c2);
              }
              return Qi(o2, "bubbling", this), Ki(i2, "$document", o2, ...n2), o2.return;
            } catch (t4) {
              a.rethrowUnexpectedError(t4, this);
            }
          }, _addEventListener(t3, e3, n2) {
            const o2 = So(n2.context || "$document"), i2 = Zi(this);
            for (const r2 of o2) {
              let o3 = i2.get(r2);
              o3 || (o3 = Object.create(f), i2.set(r2, o3)), this.listenTo(o3, t3, e3, n2);
            }
          }, _removeEventListener(t3, e3) {
            const n2 = Zi(this);
            for (const o2 of n2.values())
              this.stopListening(o2, t3, e3);
          } }, Yi = Gi;
          function Qi(t3, e3, n2) {
            t3 instanceof qi && (t3._eventPhase = e3, t3._currentTarget = n2);
          }
          function Ki(t3, e3, n2, ...o2) {
            const i2 = "string" == typeof e3 ? t3.get(e3) : $i(t3, e3);
            return !!i2 && (i2.fire(n2, ...o2), n2.stop.called);
          }
          function $i(t3, e3) {
            for (const [n2, o2] of t3)
              if ("function" == typeof n2 && n2(e3))
                return o2;
            return null;
          }
          function Zi(t3) {
            return t3[Wi] || (t3[Wi] = /* @__PURE__ */ new Map()), t3[Wi];
          }
          class Ji {
            constructor(t3) {
              this.selection = new Hi(), this.roots = new Io({ idProperty: "rootName" }), this.stylesProcessor = t3, this.set("isReadOnly", false), this.set("isFocused", false), this.set("isSelecting", false), this.set("isComposing", false), this._postFixers = /* @__PURE__ */ new Set();
            }
            getRoot(t3 = "main") {
              return this.roots.get(t3);
            }
            registerPostFixer(t3) {
              this._postFixers.add(t3);
            }
            destroy() {
              this.roots.map((t3) => t3.destroy()), this.stopListening();
            }
            _callPostFixers(t3) {
              let e3 = false;
              do {
                for (const n2 of this._postFixers)
                  if (e3 = n2(t3), e3)
                    break;
              } while (e3);
            }
          }
          he(Ji, Yi), he(Ji, re);
          class Xi extends Si {
            constructor(t3, e3, n2, o2) {
              super(t3, e3, n2, o2), this.getFillerOffset = tr, this._priority = 10, this._id = null, this._clonesGroup = null;
            }
            get priority() {
              return this._priority;
            }
            get id() {
              return this._id;
            }
            getElementsWithSameId() {
              if (null === this.id)
                throw new a("attribute-element-get-elements-with-same-id-no-id", this);
              return new Set(this._clonesGroup);
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("attributeElement" === t3 || "view:attributeElement" === t3 || "element" === t3 || "view:element" === t3) : "attributeElement" === t3 || "view:attributeElement" === t3 || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            isSimilar(t3) {
              return null !== this.id || null !== t3.id ? this.id === t3.id : super.isSimilar(t3) && this.priority == t3.priority;
            }
            _clone(t3) {
              const e3 = super._clone(t3);
              return e3._priority = this._priority, e3._id = this._id, e3;
            }
          }
          function tr() {
            if (er(this))
              return null;
            let t3 = this.parent;
            for (; t3 && t3.is("attributeElement"); ) {
              if (er(t3) > 1)
                return null;
              t3 = t3.parent;
            }
            return !t3 || er(t3) > 1 ? null : this.childCount;
          }
          function er(t3) {
            return Array.from(t3.getChildren()).filter((t4) => !t4.is("uiElement")).length;
          }
          Xi.DEFAULT_PRIORITY = 10;
          class nr extends Si {
            constructor(t3, e3, n2, o2) {
              super(t3, e3, n2, o2), this._isAllowedInsideAttributeElement = true, this.getFillerOffset = or;
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("emptyElement" === t3 || "view:emptyElement" === t3 || "element" === t3 || "view:element" === t3) : "emptyElement" === t3 || "view:emptyElement" === t3 || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            _insertChild(t3, e3) {
              if (e3 && (e3 instanceof jo || Array.from(e3).length > 0))
                throw new a("view-emptyelement-cannot-add", [this, e3]);
            }
          }
          function or() {
            return null;
          }
          const ir = navigator.userAgent.toLowerCase(), rr = { isMac: ar(ir), isWindows: function(t3) {
            return t3.indexOf("windows") > -1;
          }(ir), isGecko: function(t3) {
            return !!t3.match(/gecko\/\d+/);
          }(ir), isSafari: function(t3) {
            return t3.indexOf(" applewebkit/") > -1 && -1 === t3.indexOf("chrome");
          }(ir), isiOS: function(t3) {
            return !!t3.match(/iphone|ipad/i) || ar(t3) && navigator.maxTouchPoints > 0;
          }(ir), isAndroid: function(t3) {
            return t3.indexOf("android") > -1;
          }(ir), isBlink: function(t3) {
            return t3.indexOf("chrome/") > -1 && t3.indexOf("edge/") < 0;
          }(ir), features: { isRegExpUnicodePropertySupported: function() {
            let t3 = false;
            try {
              t3 = 0 === "\u0107".search(new RegExp("[\\p{L}]", "u"));
            } catch (t4) {
            }
            return t3;
          }() } }, sr = rr;
          function ar(t3) {
            return t3.indexOf("macintosh") > -1;
          }
          const cr = { ctrl: "\u2303", cmd: "\u2318", alt: "\u2325", shift: "\u21E7" }, lr = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, dr = function() {
            const t3 = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
            for (let e3 = 65; e3 <= 90; e3++) {
              const n2 = String.fromCharCode(e3);
              t3[n2.toLowerCase()] = e3;
            }
            for (let e3 = 48; e3 <= 57; e3++)
              t3[e3 - 48] = e3;
            for (let e3 = 112; e3 <= 123; e3++)
              t3["f" + (e3 - 111)] = e3;
            for (const e3 of "`-=[];',./\\")
              t3[e3] = e3.charCodeAt(0);
            return t3;
          }(), hr = Object.fromEntries(Object.entries(dr).map(([t3, e3]) => [e3, t3.charAt(0).toUpperCase() + t3.slice(1)]));
          function ur(t3) {
            let e3;
            if ("string" == typeof t3) {
              if (e3 = dr[t3.toLowerCase()], !e3)
                throw new a("keyboard-unknown-key", null, { key: t3 });
            } else
              e3 = t3.keyCode + (t3.altKey ? dr.alt : 0) + (t3.ctrlKey ? dr.ctrl : 0) + (t3.shiftKey ? dr.shift : 0) + (t3.metaKey ? dr.cmd : 0);
            return e3;
          }
          function gr(t3) {
            return "string" == typeof t3 && (t3 = function(t4) {
              return t4.split("+").map((t5) => t5.trim());
            }(t3)), t3.map((t4) => "string" == typeof t4 ? function(t5) {
              if (t5.endsWith("!"))
                return ur(t5.slice(0, -1));
              const e3 = ur(t5);
              return sr.isMac && e3 == dr.ctrl ? dr.cmd : e3;
            }(t4) : t4).reduce((t4, e3) => e3 + t4, 0);
          }
          function mr(t3) {
            let e3 = gr(t3);
            return Object.entries(sr.isMac ? cr : lr).reduce((t4, [n2, o2]) => (0 != (e3 & dr[n2]) && (e3 &= ~dr[n2], t4 += o2), t4), "") + (e3 ? hr[e3] : "");
          }
          function pr(t3, e3) {
            const n2 = "ltr" === e3;
            switch (t3) {
              case dr.arrowleft:
                return n2 ? "left" : "right";
              case dr.arrowright:
                return n2 ? "right" : "left";
              case dr.arrowup:
                return "up";
              case dr.arrowdown:
                return "down";
            }
          }
          class fr extends Si {
            constructor(t3, e3, n2, o2) {
              super(t3, e3, n2, o2), this._isAllowedInsideAttributeElement = true, this.getFillerOffset = br;
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("uiElement" === t3 || "view:uiElement" === t3 || "element" === t3 || "view:element" === t3) : "uiElement" === t3 || "view:uiElement" === t3 || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            _insertChild(t3, e3) {
              if (e3 && (e3 instanceof jo || Array.from(e3).length > 0))
                throw new a("view-uielement-cannot-add", this);
            }
            render(t3) {
              return this.toDomElement(t3);
            }
            toDomElement(t3) {
              const e3 = t3.createElement(this.name);
              for (const t4 of this.getAttributeKeys())
                e3.setAttribute(t4, this.getAttribute(t4));
              return e3;
            }
          }
          function kr(t3) {
            t3.document.on("arrowKey", (e3, n2) => function(t4, e4, n3) {
              if (e4.keyCode == dr.arrowright) {
                const t5 = e4.domTarget.ownerDocument.defaultView.getSelection(), o2 = 1 == t5.rangeCount && t5.getRangeAt(0).collapsed;
                if (o2 || e4.shiftKey) {
                  const e5 = t5.focusNode, i2 = t5.focusOffset, r2 = n3.domPositionToView(e5, i2);
                  if (null === r2)
                    return;
                  let s2 = false;
                  const a2 = r2.getLastMatchingPosition((t6) => (t6.item.is("uiElement") && (s2 = true), !(!t6.item.is("uiElement") && !t6.item.is("attributeElement"))));
                  if (s2) {
                    const e6 = n3.viewPositionToDom(a2);
                    o2 ? t5.collapse(e6.parent, e6.offset) : t5.extend(e6.parent, e6.offset);
                  }
                }
              }
            }(0, n2, t3.domConverter), { priority: "low" });
          }
          function br() {
            return null;
          }
          class wr extends Si {
            constructor(t3, e3, n2, o2) {
              super(t3, e3, n2, o2), this._isAllowedInsideAttributeElement = true, this.getFillerOffset = Cr;
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("rawElement" === t3 || "view:rawElement" === t3 || "element" === t3 || "view:element" === t3) : "rawElement" === t3 || "view:rawElement" === t3 || t3 === this.name || t3 === "view:" + this.name || "element" === t3 || "view:element" === t3 || "node" === t3 || "view:node" === t3;
            }
            _insertChild(t3, e3) {
              if (e3 && (e3 instanceof jo || Array.from(e3).length > 0))
                throw new a("view-rawelement-cannot-add", [this, e3]);
            }
          }
          function Cr() {
            return null;
          }
          class Ar {
            constructor(t3, e3) {
              this.document = t3, this._children = [], e3 && this._insertChild(0, e3);
            }
            [Symbol.iterator]() {
              return this._children[Symbol.iterator]();
            }
            get childCount() {
              return this._children.length;
            }
            get isEmpty() {
              return 0 === this.childCount;
            }
            get root() {
              return this;
            }
            get parent() {
              return null;
            }
            is(t3) {
              return "documentFragment" === t3 || "view:documentFragment" === t3;
            }
            _appendChild(t3) {
              return this._insertChild(this.childCount, t3);
            }
            getChild(t3) {
              return this._children[t3];
            }
            getChildIndex(t3) {
              return this._children.indexOf(t3);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            _insertChild(t3, e3) {
              this._fireChange("children", this);
              let n2 = 0;
              const o2 = function(t4, e4) {
                if ("string" == typeof e4)
                  return [new Fo(t4, e4)];
                Do(e4) || (e4 = [e4]);
                return Array.from(e4).map((e5) => "string" == typeof e5 ? new Fo(t4, e5) : e5 instanceof Vo ? new Fo(t4, e5.data) : e5);
              }(this.document, e3);
              for (const e4 of o2)
                null !== e4.parent && e4._remove(), e4.parent = this, this._children.splice(t3, 0, e4), t3++, n2++;
              return n2;
            }
            _removeChildren(t3, e3 = 1) {
              this._fireChange("children", this);
              for (let n2 = t3; n2 < t3 + e3; n2++)
                this._children[n2].parent = null;
              return this._children.splice(t3, e3);
            }
            _fireChange(t3, e3) {
              this.fire("change:" + t3, e3);
            }
          }
          he(Ar, f);
          class _r {
            constructor(t3) {
              this.document = t3, this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null;
            }
            setSelection(t3, e3, n2) {
              this.document.selection._setTo(t3, e3, n2);
            }
            setSelectionFocus(t3, e3) {
              this.document.selection._setFocus(t3, e3);
            }
            createDocumentFragment(t3) {
              return new Ar(this.document, t3);
            }
            createText(t3) {
              return new Fo(this.document, t3);
            }
            createAttributeElement(t3, e3, n2 = {}) {
              const o2 = new Xi(this.document, t3, e3);
              return "number" == typeof n2.priority && (o2._priority = n2.priority), n2.id && (o2._id = n2.id), n2.renderUnsafeAttributes && o2._unsafeAttributesToRender.push(...n2.renderUnsafeAttributes), o2;
            }
            createContainerElement(t3, e3, n2 = {}, o2 = {}) {
              let i2 = null;
              ye(n2) ? o2 = n2 : i2 = n2;
              const r2 = new Ni(this.document, t3, e3, i2);
              return void 0 !== o2.isAllowedInsideAttributeElement && (r2._isAllowedInsideAttributeElement = o2.isAllowedInsideAttributeElement), o2.renderUnsafeAttributes && r2._unsafeAttributesToRender.push(...o2.renderUnsafeAttributes), r2;
            }
            createEditableElement(t3, e3, n2 = {}) {
              const o2 = new zi(this.document, t3, e3);
              return o2._document = this.document, n2.renderUnsafeAttributes && o2._unsafeAttributesToRender.push(...n2.renderUnsafeAttributes), o2;
            }
            createEmptyElement(t3, e3, n2 = {}) {
              const o2 = new nr(this.document, t3, e3);
              return void 0 !== n2.isAllowedInsideAttributeElement && (o2._isAllowedInsideAttributeElement = n2.isAllowedInsideAttributeElement), n2.renderUnsafeAttributes && o2._unsafeAttributesToRender.push(...n2.renderUnsafeAttributes), o2;
            }
            createUIElement(t3, e3, n2, o2 = {}) {
              const i2 = new fr(this.document, t3, e3);
              return n2 && (i2.render = n2), void 0 !== o2.isAllowedInsideAttributeElement && (i2._isAllowedInsideAttributeElement = o2.isAllowedInsideAttributeElement), i2;
            }
            createRawElement(t3, e3, n2, o2 = {}) {
              const i2 = new wr(this.document, t3, e3);
              return i2.render = n2 || (() => {
              }), void 0 !== o2.isAllowedInsideAttributeElement && (i2._isAllowedInsideAttributeElement = o2.isAllowedInsideAttributeElement), o2.renderUnsafeAttributes && i2._unsafeAttributesToRender.push(...o2.renderUnsafeAttributes), i2;
            }
            setAttribute(t3, e3, n2) {
              n2._setAttribute(t3, e3);
            }
            removeAttribute(t3, e3) {
              e3._removeAttribute(t3);
            }
            addClass(t3, e3) {
              e3._addClass(t3);
            }
            removeClass(t3, e3) {
              e3._removeClass(t3);
            }
            setStyle(t3, e3, n2) {
              ye(t3) && void 0 === n2 && (n2 = e3), n2._setStyle(t3, e3);
            }
            removeStyle(t3, e3) {
              e3._removeStyle(t3);
            }
            setCustomProperty(t3, e3, n2) {
              n2._setCustomProperty(t3, e3);
            }
            removeCustomProperty(t3, e3) {
              return e3._removeCustomProperty(t3);
            }
            breakAttributes(t3) {
              return t3 instanceof Ri ? this._breakAttributes(t3) : this._breakAttributesRange(t3);
            }
            breakContainer(t3) {
              const e3 = t3.parent;
              if (!e3.is("containerElement"))
                throw new a("view-writer-break-non-container-element", this.document);
              if (!e3.parent)
                throw new a("view-writer-break-root", this.document);
              if (t3.isAtStart)
                return Ri._createBefore(e3);
              if (!t3.isAtEnd) {
                const n2 = e3._clone(false);
                this.insert(Ri._createAfter(e3), n2);
                const o2 = new ji(t3, Ri._createAt(e3, "end")), i2 = new Ri(n2, 0);
                this.move(o2, i2);
              }
              return Ri._createAfter(e3);
            }
            mergeAttributes(t3) {
              const e3 = t3.offset, n2 = t3.parent;
              if (n2.is("$text"))
                return t3;
              if (n2.is("attributeElement") && 0 === n2.childCount) {
                const t4 = n2.parent, e4 = n2.index;
                return n2._remove(), this._removeFromClonedElementsGroup(n2), this.mergeAttributes(new Ri(t4, e4));
              }
              const o2 = n2.getChild(e3 - 1), i2 = n2.getChild(e3);
              if (!o2 || !i2)
                return t3;
              if (o2.is("$text") && i2.is("$text"))
                return Dr(o2, i2);
              if (o2.is("attributeElement") && i2.is("attributeElement") && o2.isSimilar(i2)) {
                const t4 = o2.childCount;
                return o2._appendChild(i2.getChildren()), i2._remove(), this._removeFromClonedElementsGroup(i2), this.mergeAttributes(new Ri(o2, t4));
              }
              return t3;
            }
            mergeContainers(t3) {
              const e3 = t3.nodeBefore, n2 = t3.nodeAfter;
              if (!(e3 && n2 && e3.is("containerElement") && n2.is("containerElement")))
                throw new a("view-writer-merge-containers-invalid-position", this.document);
              const o2 = e3.getChild(e3.childCount - 1), i2 = o2 instanceof Fo ? Ri._createAt(o2, "end") : Ri._createAt(e3, "end");
              return this.move(ji._createIn(n2), Ri._createAt(e3, "end")), this.remove(ji._createOn(n2)), i2;
            }
            insert(t3, e3) {
              Ir(e3 = Do(e3) ? [...e3] : [e3], this.document);
              const n2 = e3.reduce((t4, e4) => {
                const n3 = t4[t4.length - 1], o3 = !(e4.is("uiElement") && e4.isAllowedInsideAttributeElement);
                return n3 && n3.breakAttributes == o3 ? n3.nodes.push(e4) : t4.push({ breakAttributes: o3, nodes: [e4] }), t4;
              }, []);
              let o2 = null, i2 = t3;
              for (const { nodes: t4, breakAttributes: e4 } of n2) {
                const n3 = this._insertNodes(i2, t4, e4);
                o2 || (o2 = n3.start), i2 = n3.end;
              }
              return o2 ? new ji(o2, i2) : new ji(t3);
            }
            remove(t3) {
              const e3 = t3 instanceof ji ? t3 : ji._createOn(t3);
              if (Tr(e3, this.document), e3.isCollapsed)
                return new Ar(this.document);
              const { start: n2, end: o2 } = this._breakAttributesRange(e3, true), i2 = n2.parent, r2 = o2.offset - n2.offset, s2 = i2._removeChildren(n2.offset, r2);
              for (const t4 of s2)
                this._removeFromClonedElementsGroup(t4);
              const a2 = this.mergeAttributes(n2);
              return e3.start = a2, e3.end = a2.clone(), new Ar(this.document, s2);
            }
            clear(t3, e3) {
              Tr(t3, this.document);
              const n2 = t3.getWalker({ direction: "backward", ignoreElementEnd: true });
              for (const o2 of n2) {
                const n3 = o2.item;
                let i2;
                if (n3.is("element") && e3.isSimilar(n3))
                  i2 = ji._createOn(n3);
                else if (!o2.nextPosition.isAfter(t3.start) && n3.is("$textProxy")) {
                  const t4 = n3.getAncestors().find((t5) => t5.is("element") && e3.isSimilar(t5));
                  t4 && (i2 = ji._createIn(t4));
                }
                i2 && (i2.end.isAfter(t3.end) && (i2.end = t3.end), i2.start.isBefore(t3.start) && (i2.start = t3.start), this.remove(i2));
              }
            }
            move(t3, e3) {
              let n2;
              if (e3.isAfter(t3.end)) {
                const o2 = (e3 = this._breakAttributes(e3, true)).parent, i2 = o2.childCount;
                t3 = this._breakAttributesRange(t3, true), n2 = this.remove(t3), e3.offset += o2.childCount - i2;
              } else
                n2 = this.remove(t3);
              return this.insert(e3, n2);
            }
            wrap(t3, e3) {
              if (!(e3 instanceof Xi))
                throw new a("view-writer-wrap-invalid-attribute", this.document);
              if (Tr(t3, this.document), t3.isCollapsed) {
                let o2 = t3.start;
                o2.parent.is("element") && (n2 = o2.parent, !Array.from(n2.getChildren()).some((t4) => !t4.is("uiElement"))) && (o2 = o2.getLastMatchingPosition((t4) => t4.item.is("uiElement"))), o2 = this._wrapPosition(o2, e3);
                const i2 = this.document.selection;
                return i2.isCollapsed && i2.getFirstPosition().isEqual(t3.start) && this.setSelection(o2), new ji(o2);
              }
              return this._wrapRange(t3, e3);
              var n2;
            }
            unwrap(t3, e3) {
              if (!(e3 instanceof Xi))
                throw new a("view-writer-unwrap-invalid-attribute", this.document);
              if (Tr(t3, this.document), t3.isCollapsed)
                return t3;
              const { start: n2, end: o2 } = this._breakAttributesRange(t3, true), i2 = n2.parent, r2 = this._unwrapChildren(i2, n2.offset, o2.offset, e3), s2 = this.mergeAttributes(r2.start);
              s2.isEqual(r2.start) || r2.end.offset--;
              const c2 = this.mergeAttributes(r2.end);
              return new ji(s2, c2);
            }
            rename(t3, e3) {
              const n2 = new Ni(this.document, t3, e3.getAttributes());
              return this.insert(Ri._createAfter(e3), n2), this.move(ji._createIn(e3), Ri._createAt(n2, 0)), this.remove(ji._createOn(e3)), n2;
            }
            clearClonedElementsGroup(t3) {
              this._cloneGroups.delete(t3);
            }
            createPositionAt(t3, e3) {
              return Ri._createAt(t3, e3);
            }
            createPositionAfter(t3) {
              return Ri._createAfter(t3);
            }
            createPositionBefore(t3) {
              return Ri._createBefore(t3);
            }
            createRange(t3, e3) {
              return new ji(t3, e3);
            }
            createRangeOn(t3) {
              return ji._createOn(t3);
            }
            createRangeIn(t3) {
              return ji._createIn(t3);
            }
            createSelection(t3, e3, n2) {
              return new Ui(t3, e3, n2);
            }
            createSlot(t3) {
              if (!this._slotFactory)
                throw new a("view-writer-invalid-create-slot-context", this.document);
              return this._slotFactory(this, t3);
            }
            _registerSlotFactory(t3) {
              this._slotFactory = t3;
            }
            _clearSlotFactory() {
              this._slotFactory = null;
            }
            _insertNodes(t3, e3, n2) {
              let o2, i2;
              if (o2 = n2 ? vr(t3) : t3.parent.is("$text") ? t3.parent.parent : t3.parent, !o2)
                throw new a("view-writer-invalid-position-container", this.document);
              i2 = n2 ? this._breakAttributes(t3, true) : t3.parent.is("$text") ? Er(t3) : t3;
              const r2 = o2._insertChild(i2.offset, e3);
              for (const t4 of e3)
                this._addToClonedElementsGroup(t4);
              const s2 = i2.getShiftedBy(r2), c2 = this.mergeAttributes(i2);
              c2.isEqual(i2) || s2.offset--;
              const l2 = this.mergeAttributes(s2);
              return new ji(c2, l2);
            }
            _wrapChildren(t3, e3, n2, o2) {
              let i2 = e3;
              const r2 = [];
              for (; i2 < n2; ) {
                const e4 = t3.getChild(i2), n3 = e4.is("$text"), s3 = e4.is("attributeElement"), a2 = e4.isAllowedInsideAttributeElement;
                if (s3 && this._wrapAttributeElement(o2, e4))
                  r2.push(new Ri(t3, i2));
                else if (n3 || a2 || s3 && yr(o2, e4)) {
                  const n4 = o2._clone();
                  e4._remove(), n4._appendChild(e4), t3._insertChild(i2, n4), this._addToClonedElementsGroup(n4), r2.push(new Ri(t3, i2));
                } else
                  s3 && this._wrapChildren(e4, 0, e4.childCount, o2);
                i2++;
              }
              let s2 = 0;
              for (const t4 of r2) {
                if (t4.offset -= s2, t4.offset == e3)
                  continue;
                this.mergeAttributes(t4).isEqual(t4) || (s2++, n2--);
              }
              return ji._createFromParentsAndOffsets(t3, e3, t3, n2);
            }
            _unwrapChildren(t3, e3, n2, o2) {
              let i2 = e3;
              const r2 = [];
              for (; i2 < n2; ) {
                const e4 = t3.getChild(i2);
                if (e4.is("attributeElement"))
                  if (e4.isSimilar(o2)) {
                    const o3 = e4.getChildren(), s3 = e4.childCount;
                    e4._remove(), t3._insertChild(i2, o3), this._removeFromClonedElementsGroup(e4), r2.push(new Ri(t3, i2), new Ri(t3, i2 + s3)), i2 += s3, n2 += s3 - 1;
                  } else
                    this._unwrapAttributeElement(o2, e4) ? (r2.push(new Ri(t3, i2), new Ri(t3, i2 + 1)), i2++) : (this._unwrapChildren(e4, 0, e4.childCount, o2), i2++);
                else
                  i2++;
              }
              let s2 = 0;
              for (const t4 of r2) {
                if (t4.offset -= s2, t4.offset == e3 || t4.offset == n2)
                  continue;
                this.mergeAttributes(t4).isEqual(t4) || (s2++, n2--);
              }
              return ji._createFromParentsAndOffsets(t3, e3, t3, n2);
            }
            _wrapRange(t3, e3) {
              const { start: n2, end: o2 } = this._breakAttributesRange(t3, true), i2 = n2.parent, r2 = this._wrapChildren(i2, n2.offset, o2.offset, e3), s2 = this.mergeAttributes(r2.start);
              s2.isEqual(r2.start) || r2.end.offset--;
              const a2 = this.mergeAttributes(r2.end);
              return new ji(s2, a2);
            }
            _wrapPosition(t3, e3) {
              if (e3.isSimilar(t3.parent))
                return xr(t3.clone());
              t3.parent.is("$text") && (t3 = Er(t3));
              const n2 = this.createAttributeElement();
              n2._priority = Number.POSITIVE_INFINITY, n2.isSimilar = () => false, t3.parent._insertChild(t3.offset, n2);
              const o2 = new ji(t3, t3.getShiftedBy(1));
              this.wrap(o2, e3);
              const i2 = new Ri(n2.parent, n2.index);
              n2._remove();
              const r2 = i2.nodeBefore, s2 = i2.nodeAfter;
              return r2 instanceof Fo && s2 instanceof Fo ? Dr(r2, s2) : xr(i2);
            }
            _wrapAttributeElement(t3, e3) {
              if (!Nr(t3, e3))
                return false;
              if (t3.name !== e3.name || t3.priority !== e3.priority)
                return false;
              for (const n2 of t3.getAttributeKeys())
                if ("class" !== n2 && "style" !== n2 && e3.hasAttribute(n2) && e3.getAttribute(n2) !== t3.getAttribute(n2))
                  return false;
              for (const n2 of t3.getStyleNames())
                if (e3.hasStyle(n2) && e3.getStyle(n2) !== t3.getStyle(n2))
                  return false;
              for (const n2 of t3.getAttributeKeys())
                "class" !== n2 && "style" !== n2 && (e3.hasAttribute(n2) || this.setAttribute(n2, t3.getAttribute(n2), e3));
              for (const n2 of t3.getStyleNames())
                e3.hasStyle(n2) || this.setStyle(n2, t3.getStyle(n2), e3);
              for (const n2 of t3.getClassNames())
                e3.hasClass(n2) || this.addClass(n2, e3);
              return true;
            }
            _unwrapAttributeElement(t3, e3) {
              if (!Nr(t3, e3))
                return false;
              if (t3.name !== e3.name || t3.priority !== e3.priority)
                return false;
              for (const n2 of t3.getAttributeKeys())
                if ("class" !== n2 && "style" !== n2 && (!e3.hasAttribute(n2) || e3.getAttribute(n2) !== t3.getAttribute(n2)))
                  return false;
              if (!e3.hasClass(...t3.getClassNames()))
                return false;
              for (const n2 of t3.getStyleNames())
                if (!e3.hasStyle(n2) || e3.getStyle(n2) !== t3.getStyle(n2))
                  return false;
              for (const n2 of t3.getAttributeKeys())
                "class" !== n2 && "style" !== n2 && this.removeAttribute(n2, e3);
              return this.removeClass(Array.from(t3.getClassNames()), e3), this.removeStyle(Array.from(t3.getStyleNames()), e3), true;
            }
            _breakAttributesRange(t3, e3 = false) {
              const n2 = t3.start, o2 = t3.end;
              if (Tr(t3, this.document), t3.isCollapsed) {
                const n3 = this._breakAttributes(t3.start, e3);
                return new ji(n3, n3);
              }
              const i2 = this._breakAttributes(o2, e3), r2 = i2.parent.childCount, s2 = this._breakAttributes(n2, e3);
              return i2.offset += i2.parent.childCount - r2, new ji(s2, i2);
            }
            _breakAttributes(t3, e3 = false) {
              const n2 = t3.offset, o2 = t3.parent;
              if (t3.parent.is("emptyElement"))
                throw new a("view-writer-cannot-break-empty-element", this.document);
              if (t3.parent.is("uiElement"))
                throw new a("view-writer-cannot-break-ui-element", this.document);
              if (t3.parent.is("rawElement"))
                throw new a("view-writer-cannot-break-raw-element", this.document);
              if (!e3 && o2.is("$text") && Sr(o2.parent))
                return t3.clone();
              if (Sr(o2))
                return t3.clone();
              if (o2.is("$text"))
                return this._breakAttributes(Er(t3), e3);
              if (n2 == o2.childCount) {
                const t4 = new Ri(o2.parent, o2.index + 1);
                return this._breakAttributes(t4, e3);
              }
              if (0 === n2) {
                const t4 = new Ri(o2.parent, o2.index);
                return this._breakAttributes(t4, e3);
              }
              {
                const t4 = o2.index + 1, i2 = o2._clone();
                o2.parent._insertChild(t4, i2), this._addToClonedElementsGroup(i2);
                const r2 = o2.childCount - n2, s2 = o2._removeChildren(n2, r2);
                i2._appendChild(s2);
                const a2 = new Ri(o2.parent, t4);
                return this._breakAttributes(a2, e3);
              }
            }
            _addToClonedElementsGroup(t3) {
              if (!t3.root.is("rootElement"))
                return;
              if (t3.is("element"))
                for (const e4 of t3.getChildren())
                  this._addToClonedElementsGroup(e4);
              const e3 = t3.id;
              if (!e3)
                return;
              let n2 = this._cloneGroups.get(e3);
              n2 || (n2 = /* @__PURE__ */ new Set(), this._cloneGroups.set(e3, n2)), n2.add(t3), t3._clonesGroup = n2;
            }
            _removeFromClonedElementsGroup(t3) {
              if (t3.is("element"))
                for (const e4 of t3.getChildren())
                  this._removeFromClonedElementsGroup(e4);
              const e3 = t3.id;
              if (!e3)
                return;
              const n2 = this._cloneGroups.get(e3);
              n2 && n2.delete(t3);
            }
          }
          function vr(t3) {
            let e3 = t3.parent;
            for (; !Sr(e3); ) {
              if (!e3)
                return;
              e3 = e3.parent;
            }
            return e3;
          }
          function yr(t3, e3) {
            return t3.priority < e3.priority || !(t3.priority > e3.priority) && t3.getIdentity() < e3.getIdentity();
          }
          function xr(t3) {
            const e3 = t3.nodeBefore;
            if (e3 && e3.is("$text"))
              return new Ri(e3, e3.data.length);
            const n2 = t3.nodeAfter;
            return n2 && n2.is("$text") ? new Ri(n2, 0) : t3;
          }
          function Er(t3) {
            if (t3.offset == t3.parent.data.length)
              return new Ri(t3.parent.parent, t3.parent.index + 1);
            if (0 === t3.offset)
              return new Ri(t3.parent.parent, t3.parent.index);
            const e3 = t3.parent.data.slice(t3.offset);
            return t3.parent._data = t3.parent.data.slice(0, t3.offset), t3.parent.parent._insertChild(t3.parent.index + 1, new Fo(t3.root.document, e3)), new Ri(t3.parent.parent, t3.parent.index + 1);
          }
          function Dr(t3, e3) {
            const n2 = t3.data.length;
            return t3._data += e3.data, e3._remove(), new Ri(t3, n2);
          }
          function Ir(t3, e3) {
            for (const n2 of t3) {
              if (!Mr.some((t4) => n2 instanceof t4))
                throw new a("view-writer-insert-invalid-node-type", e3);
              n2.is("$text") || Ir(n2.getChildren(), e3);
            }
          }
          const Mr = [Fo, Xi, Ni, nr, wr, fr];
          function Sr(t3) {
            return t3 && (t3.is("containerElement") || t3.is("documentFragment"));
          }
          function Tr(t3, e3) {
            const n2 = vr(t3.start), o2 = vr(t3.end);
            if (!n2 || !o2 || n2 !== o2)
              throw new a("view-writer-invalid-range-container", e3);
          }
          function Nr(t3, e3) {
            return null === t3.id && null === e3.id;
          }
          function Br(t3) {
            return "[object Text]" == Object.prototype.toString.call(t3);
          }
          const zr = (t3) => t3.createTextNode("\xA0"), Pr = (t3) => {
            const e3 = t3.createElement("span");
            return e3.dataset.ckeFiller = true, e3.innerHTML = "\xA0", e3;
          }, Lr = (t3) => {
            const e3 = t3.createElement("br");
            return e3.dataset.ckeFiller = true, e3;
          }, Or = "\u2060".repeat(7);
          function Rr(t3) {
            return Br(t3) && t3.data.substr(0, 7) === Or;
          }
          function jr(t3) {
            return 7 == t3.data.length && Rr(t3);
          }
          function Fr(t3) {
            return Rr(t3) ? t3.data.slice(7) : t3.data;
          }
          function Vr(t3, e3) {
            if (e3.keyCode == dr.arrowleft) {
              const t4 = e3.domTarget.ownerDocument.defaultView.getSelection();
              if (1 == t4.rangeCount && t4.getRangeAt(0).collapsed) {
                const e4 = t4.getRangeAt(0).startContainer, n2 = t4.getRangeAt(0).startOffset;
                Rr(e4) && n2 <= 7 && t4.collapse(e4, 0);
              }
            }
          }
          function Ur(t3, e3, n2, o2 = false) {
            n2 = n2 || function(t4, e4) {
              return t4 === e4;
            }, Array.isArray(t3) || (t3 = Array.prototype.slice.call(t3)), Array.isArray(e3) || (e3 = Array.prototype.slice.call(e3));
            const i2 = function(t4, e4, n3) {
              const o3 = Hr(t4, e4, n3);
              if (-1 === o3)
                return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
              const i3 = qr(t4, o3), r2 = qr(e4, o3), s2 = Hr(i3, r2, n3), a2 = t4.length - s2, c2 = e4.length - s2;
              return { firstIndex: o3, lastIndexOld: a2, lastIndexNew: c2 };
            }(t3, e3, n2);
            return o2 ? function(t4, e4) {
              const { firstIndex: n3, lastIndexOld: o3, lastIndexNew: i3 } = t4;
              if (-1 === n3)
                return Array(e4).fill("equal");
              let r2 = [];
              n3 > 0 && (r2 = r2.concat(Array(n3).fill("equal")));
              i3 - n3 > 0 && (r2 = r2.concat(Array(i3 - n3).fill("insert")));
              o3 - n3 > 0 && (r2 = r2.concat(Array(o3 - n3).fill("delete")));
              i3 < e4 && (r2 = r2.concat(Array(e4 - i3).fill("equal")));
              return r2;
            }(i2, e3.length) : function(t4, e4) {
              const n3 = [], { firstIndex: o3, lastIndexOld: i3, lastIndexNew: r2 } = e4;
              r2 - o3 > 0 && n3.push({ index: o3, type: "insert", values: t4.slice(o3, r2) });
              i3 - o3 > 0 && n3.push({ index: o3 + (r2 - o3), type: "delete", howMany: i3 - o3 });
              return n3;
            }(e3, i2);
          }
          function Hr(t3, e3, n2) {
            for (let o2 = 0; o2 < Math.max(t3.length, e3.length); o2++)
              if (void 0 === t3[o2] || void 0 === e3[o2] || !n2(t3[o2], e3[o2]))
                return o2;
            return -1;
          }
          function qr(t3, e3) {
            return t3.slice(e3).reverse();
          }
          function Wr(t3, e3, n2) {
            n2 = n2 || function(t4, e4) {
              return t4 === e4;
            };
            const o2 = t3.length, i2 = e3.length;
            if (o2 > 200 || i2 > 200 || o2 + i2 > 300)
              return Wr.fastDiff(t3, e3, n2, true);
            let r2, s2;
            if (i2 < o2) {
              const n3 = t3;
              t3 = e3, e3 = n3, r2 = "delete", s2 = "insert";
            } else
              r2 = "insert", s2 = "delete";
            const a2 = t3.length, c2 = e3.length, l2 = c2 - a2, d2 = {}, h2 = {};
            function u2(o3) {
              const i3 = (void 0 !== h2[o3 - 1] ? h2[o3 - 1] : -1) + 1, l3 = void 0 !== h2[o3 + 1] ? h2[o3 + 1] : -1, u3 = i3 > l3 ? -1 : 1;
              d2[o3 + u3] && (d2[o3] = d2[o3 + u3].slice(0)), d2[o3] || (d2[o3] = []), d2[o3].push(i3 > l3 ? r2 : s2);
              let g3 = Math.max(i3, l3), m3 = g3 - o3;
              for (; m3 < a2 && g3 < c2 && n2(t3[m3], e3[g3]); )
                m3++, g3++, d2[o3].push("equal");
              return g3;
            }
            let g2, m2 = 0;
            do {
              for (g2 = -m2; g2 < l2; g2++)
                h2[g2] = u2(g2);
              for (g2 = l2 + m2; g2 > l2; g2--)
                h2[g2] = u2(g2);
              h2[l2] = u2(l2), m2++;
            } while (h2[l2] !== c2);
            return d2[l2].slice(1);
          }
          function Gr(t3, e3, n2) {
            t3.insertBefore(n2, t3.childNodes[e3] || null);
          }
          function Yr(t3) {
            const e3 = t3.parentNode;
            e3 && e3.removeChild(t3);
          }
          function Qr(t3) {
            return t3 && t3.nodeType === Node.COMMENT_NODE;
          }
          function Kr(t3) {
            if (t3) {
              if (t3.defaultView)
                return t3 instanceof t3.defaultView.Document;
              if (t3.ownerDocument && t3.ownerDocument.defaultView)
                return t3 instanceof t3.ownerDocument.defaultView.Node;
            }
            return false;
          }
          Wr.fastDiff = Ur;
          var $r = n(6062), Zr = n.n($r), Jr = n(9315), Xr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Jr.Z, Xr);
          Jr.Z.locals;
          class ts {
            constructor(t3, e3) {
              this.domDocuments = /* @__PURE__ */ new Set(), this.domConverter = t3, this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this.selection = e3, this.set("isFocused", false), this.set("isSelecting", false), sr.isBlink && !sr.isAndroid && this.on("change:isSelecting", () => {
                this.isSelecting || this.render();
              }), this._inlineFiller = null, this._fakeSelectionContainer = null;
            }
            markToSync(t3, e3) {
              if ("text" === t3)
                this.domConverter.mapViewToDom(e3.parent) && this.markedTexts.add(e3);
              else {
                if (!this.domConverter.mapViewToDom(e3))
                  return;
                if ("attributes" === t3)
                  this.markedAttributes.add(e3);
                else {
                  if ("children" !== t3)
                    throw new a("view-renderer-unknown-type", this);
                  this.markedChildren.add(e3);
                }
              }
            }
            render() {
              let t3;
              const e3 = !(sr.isBlink && !sr.isAndroid) || !this.isSelecting;
              for (const t4 of this.markedChildren)
                this._updateChildrenMappings(t4);
              e3 ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? t3 = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (t3 = this.selection.getFirstPosition(), this.markedChildren.add(t3.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (t3 = this.domConverter.domPositionToView(this._inlineFiller));
              for (const t4 of this.markedAttributes)
                this._updateAttrs(t4);
              for (const e4 of this.markedChildren)
                this._updateChildren(e4, { inlineFillerPosition: t3 });
              for (const e4 of this.markedTexts)
                !this.markedChildren.has(e4.parent) && this.domConverter.mapViewToDom(e4.parent) && this._updateText(e4, { inlineFillerPosition: t3 });
              if (e3)
                if (t3) {
                  const e4 = this.domConverter.viewPositionToDom(t3), n2 = e4.parent.ownerDocument;
                  Rr(e4.parent) ? this._inlineFiller = e4.parent : this._inlineFiller = es(n2, e4.parent, e4.offset);
                } else
                  this._inlineFiller = null;
              this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
            }
            _updateChildrenMappings(t3) {
              const e3 = this.domConverter.mapViewToDom(t3);
              if (!e3)
                return;
              const n2 = Array.from(this.domConverter.mapViewToDom(t3).childNodes), o2 = Array.from(this.domConverter.viewChildrenToDom(t3, e3.ownerDocument, { withChildren: false })), i2 = this._diffNodeLists(n2, o2), r2 = this._findReplaceActions(i2, n2, o2);
              if (-1 !== r2.indexOf("replace")) {
                const e4 = { equal: 0, insert: 0, delete: 0 };
                for (const i3 of r2)
                  if ("replace" === i3) {
                    const i4 = e4.equal + e4.insert, r3 = e4.equal + e4.delete, s2 = t3.getChild(i4);
                    !s2 || s2.is("uiElement") || s2.is("rawElement") || this._updateElementMappings(s2, n2[r3]), Yr(o2[i4]), e4.equal++;
                  } else
                    e4[i3]++;
              }
            }
            _updateElementMappings(t3, e3) {
              this.domConverter.unbindDomElement(e3), this.domConverter.bindElements(e3, t3), this.markedChildren.add(t3), this.markedAttributes.add(t3);
            }
            _getInlineFillerPosition() {
              const t3 = this.selection.getFirstPosition();
              return t3.parent.is("$text") ? Ri._createBefore(this.selection.getFirstPosition().parent) : t3;
            }
            _isSelectionInInlineFiller() {
              if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
                return false;
              const t3 = this.selection.getFirstPosition(), e3 = this.domConverter.viewPositionToDom(t3);
              return !!(e3 && Br(e3.parent) && Rr(e3.parent));
            }
            _removeInlineFiller() {
              const t3 = this._inlineFiller;
              if (!Rr(t3))
                throw new a("view-renderer-filler-was-lost", this);
              jr(t3) ? t3.remove() : t3.data = t3.data.substr(7), this._inlineFiller = null;
            }
            _needsInlineFillerAtSelection() {
              if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
                return false;
              const t3 = this.selection.getFirstPosition(), e3 = t3.parent, n2 = t3.offset;
              if (!this.domConverter.mapViewToDom(e3.root))
                return false;
              if (!e3.is("element"))
                return false;
              if (!function(t4) {
                if ("false" == t4.getAttribute("contenteditable"))
                  return false;
                const e4 = t4.findAncestor((t5) => t5.hasAttribute("contenteditable"));
                return !e4 || "true" == e4.getAttribute("contenteditable");
              }(e3))
                return false;
              if (n2 === e3.getFillerOffset())
                return false;
              const o2 = t3.nodeBefore, i2 = t3.nodeAfter;
              return !(o2 instanceof Fo || i2 instanceof Fo);
            }
            _updateText(t3, e3) {
              const n2 = this.domConverter.findCorrespondingDomText(t3), o2 = this.domConverter.viewToDom(t3, n2.ownerDocument), i2 = n2.data;
              let r2 = o2.data;
              const s2 = e3.inlineFillerPosition;
              if (s2 && s2.parent == t3.parent && s2.offset == t3.index && (r2 = Or + r2), i2 != r2) {
                const t4 = Ur(i2, r2);
                for (const e4 of t4)
                  "insert" === e4.type ? n2.insertData(e4.index, e4.values.join("")) : n2.deleteData(e4.index, e4.howMany);
              }
            }
            _updateAttrs(t3) {
              const e3 = this.domConverter.mapViewToDom(t3);
              if (!e3)
                return;
              const n2 = Array.from(e3.attributes).map((t4) => t4.name), o2 = t3.getAttributeKeys();
              for (const n3 of o2)
                this.domConverter.setDomElementAttribute(e3, n3, t3.getAttribute(n3), t3);
              for (const o3 of n2)
                t3.hasAttribute(o3) || this.domConverter.removeDomElementAttribute(e3, o3);
            }
            _updateChildren(t3, e3) {
              const n2 = this.domConverter.mapViewToDom(t3);
              if (!n2)
                return;
              const o2 = e3.inlineFillerPosition, i2 = this.domConverter.mapViewToDom(t3).childNodes, r2 = Array.from(this.domConverter.viewChildrenToDom(t3, n2.ownerDocument, { bind: true }));
              o2 && o2.parent === t3 && es(n2.ownerDocument, r2, o2.offset);
              const s2 = this._diffNodeLists(i2, r2);
              let a2 = 0;
              const c2 = /* @__PURE__ */ new Set();
              for (const t4 of s2)
                "delete" === t4 ? (c2.add(i2[a2]), Yr(i2[a2])) : "equal" === t4 && a2++;
              a2 = 0;
              for (const t4 of s2)
                "insert" === t4 ? (Gr(n2, a2, r2[a2]), a2++) : "equal" === t4 && (this._markDescendantTextToSync(this.domConverter.domToView(r2[a2])), a2++);
              for (const t4 of c2)
                t4.parentNode || this.domConverter.unbindDomElement(t4);
            }
            _diffNodeLists(t3, e3) {
              return Wr(t3 = function(t4, e4) {
                const n2 = Array.from(t4);
                if (0 == n2.length || !e4)
                  return n2;
                n2[n2.length - 1] == e4 && n2.pop();
                return n2;
              }(t3, this._fakeSelectionContainer), e3, os.bind(null, this.domConverter));
            }
            _findReplaceActions(t3, e3, n2) {
              if (-1 === t3.indexOf("insert") || -1 === t3.indexOf("delete"))
                return t3;
              let o2 = [], i2 = [], r2 = [];
              const s2 = { equal: 0, insert: 0, delete: 0 };
              for (const a2 of t3)
                "insert" === a2 ? r2.push(n2[s2.equal + s2.insert]) : "delete" === a2 ? i2.push(e3[s2.equal + s2.delete]) : (o2 = o2.concat(Wr(i2, r2, ns).map((t4) => "equal" === t4 ? "replace" : t4)), o2.push("equal"), i2 = [], r2 = []), s2[a2]++;
              return o2.concat(Wr(i2, r2, ns).map((t4) => "equal" === t4 ? "replace" : t4));
            }
            _markDescendantTextToSync(t3) {
              if (t3) {
                if (t3.is("$text"))
                  this.markedTexts.add(t3);
                else if (t3.is("element"))
                  for (const e3 of t3.getChildren())
                    this._markDescendantTextToSync(e3);
              }
            }
            _updateSelection() {
              if (sr.isBlink && !sr.isAndroid && this.isSelecting && !this.markedChildren.size)
                return;
              if (0 === this.selection.rangeCount)
                return this._removeDomSelection(), void this._removeFakeSelection();
              const t3 = this.domConverter.mapViewToDom(this.selection.editableElement);
              this.isFocused && t3 && (this.selection.isFake ? this._updateFakeSelection(t3) : (this._removeFakeSelection(), this._updateDomSelection(t3)));
            }
            _updateFakeSelection(t3) {
              const e3 = t3.ownerDocument;
              this._fakeSelectionContainer || (this._fakeSelectionContainer = function(t4) {
                const e4 = t4.createElement("div");
                return e4.className = "ck-fake-selection-container", Object.assign(e4.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), e4.textContent = "\xA0", e4;
              }(e3));
              const n2 = this._fakeSelectionContainer;
              if (this.domConverter.bindFakeSelection(n2, this.selection), !this._fakeSelectionNeedsUpdate(t3))
                return;
              n2.parentElement && n2.parentElement == t3 || t3.appendChild(n2), n2.textContent = this.selection.fakeSelectionLabel || "\xA0";
              const o2 = e3.getSelection(), i2 = e3.createRange();
              o2.removeAllRanges(), i2.selectNodeContents(n2), o2.addRange(i2);
            }
            _updateDomSelection(t3) {
              const e3 = t3.ownerDocument.defaultView.getSelection();
              if (!this._domSelectionNeedsUpdate(e3))
                return;
              const n2 = this.domConverter.viewPositionToDom(this.selection.anchor), o2 = this.domConverter.viewPositionToDom(this.selection.focus);
              e3.collapse(n2.parent, n2.offset), e3.extend(o2.parent, o2.offset), sr.isGecko && function(t4, e4) {
                const n3 = t4.parent;
                if (n3.nodeType != Node.ELEMENT_NODE || t4.offset != n3.childNodes.length - 1)
                  return;
                const o3 = n3.childNodes[t4.offset];
                o3 && "BR" == o3.tagName && e4.addRange(e4.getRangeAt(0));
              }(o2, e3);
            }
            _domSelectionNeedsUpdate(t3) {
              if (!this.domConverter.isDomSelectionCorrect(t3))
                return true;
              const e3 = t3 && this.domConverter.domSelectionToView(t3);
              return (!e3 || !this.selection.isEqual(e3)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e3));
            }
            _fakeSelectionNeedsUpdate(t3) {
              const e3 = this._fakeSelectionContainer, n2 = t3.ownerDocument.getSelection();
              return !e3 || e3.parentElement !== t3 || (n2.anchorNode !== e3 && !e3.contains(n2.anchorNode) || e3.textContent !== this.selection.fakeSelectionLabel);
            }
            _removeDomSelection() {
              for (const t3 of this.domDocuments) {
                if (t3.getSelection().rangeCount) {
                  const e3 = t3.activeElement, n2 = this.domConverter.mapDomToView(e3);
                  e3 && n2 && t3.getSelection().removeAllRanges();
                }
              }
            }
            _removeFakeSelection() {
              const t3 = this._fakeSelectionContainer;
              t3 && t3.remove();
            }
            _updateFocus() {
              if (this.isFocused) {
                const t3 = this.selection.editableElement;
                t3 && this.domConverter.focus(t3);
              }
            }
          }
          function es(t3, e3, n2) {
            const o2 = e3 instanceof Array ? e3 : e3.childNodes, i2 = o2[n2];
            if (Br(i2))
              return i2.data = Or + i2.data, i2;
            {
              const i3 = t3.createTextNode(Or);
              return Array.isArray(e3) ? o2.splice(n2, 0, i3) : Gr(e3, n2, i3), i3;
            }
          }
          function ns(t3, e3) {
            return Kr(t3) && Kr(e3) && !Br(t3) && !Br(e3) && !Qr(t3) && !Qr(e3) && t3.tagName.toLowerCase() === e3.tagName.toLowerCase();
          }
          function os(t3, e3, n2) {
            return e3 === n2 || (Br(e3) && Br(n2) ? e3.data === n2.data : !(!t3.isBlockFiller(e3) || !t3.isBlockFiller(n2)));
          }
          he(ts, re);
          const is = { window, document };
          function rs(t3) {
            let e3 = 0;
            for (; t3.previousSibling; )
              t3 = t3.previousSibling, e3++;
            return e3;
          }
          function ss(t3) {
            const e3 = [];
            for (; t3 && t3.nodeType != Node.DOCUMENT_NODE; )
              e3.unshift(t3), t3 = t3.parentNode;
            return e3;
          }
          const as = Lr(document), cs = zr(document), ls = Pr(document), ds = "data-ck-unsafe-attribute-", hs = "data-ck-unsafe-element", us = ["script", "style"];
          class gs {
            constructor(t3, e3 = {}) {
              this.document = t3, this.renderingMode = e3.renderingMode || "editing", this.blockFillerMode = e3.blockFillerMode || ("editing" === this.renderingMode ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new Ho(), this._encounteredRawContentDomNodes = /* @__PURE__ */ new WeakSet();
            }
            bindFakeSelection(t3, e3) {
              this._fakeSelectionMapping.set(t3, new Ui(e3));
            }
            fakeSelectionToView(t3) {
              return this._fakeSelectionMapping.get(t3);
            }
            bindElements(t3, e3) {
              this._domToViewMapping.set(t3, e3), this._viewToDomMapping.set(e3, t3);
            }
            unbindDomElement(t3) {
              const e3 = this._domToViewMapping.get(t3);
              if (e3) {
                this._domToViewMapping.delete(t3), this._viewToDomMapping.delete(e3);
                for (const e4 of t3.childNodes)
                  this.unbindDomElement(e4);
              }
            }
            bindDocumentFragments(t3, e3) {
              this._domToViewMapping.set(t3, e3), this._viewToDomMapping.set(e3, t3);
            }
            shouldRenderAttribute(t3, e3, n2) {
              return "data" === this.renderingMode || !(t3 = t3.toLowerCase()).startsWith("on") && (("srcdoc" !== t3 || !e3.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && ("img" === n2 && ("src" === t3 || "srcset" === t3) || ("source" === n2 && "srcset" === t3 || !e3.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))));
            }
            setContentOf(t3, e3) {
              if ("data" === this.renderingMode)
                return void (t3.innerHTML = e3);
              const n2 = new DOMParser().parseFromString(e3, "text/html"), o2 = n2.createDocumentFragment(), i2 = n2.body.childNodes;
              for (; i2.length > 0; )
                o2.appendChild(i2[0]);
              const r2 = n2.createTreeWalker(o2, NodeFilter.SHOW_ELEMENT), s2 = [];
              let a2;
              for (; a2 = r2.nextNode(); )
                s2.push(a2);
              for (const t4 of s2) {
                for (const e5 of t4.getAttributeNames())
                  this.setDomElementAttribute(t4, e5, t4.getAttribute(e5));
                const e4 = t4.tagName.toLowerCase();
                this._shouldRenameElement(e4) && (fs(e4), t4.replaceWith(this._createReplacementDomElement(e4, t4)));
              }
              for (; t3.firstChild; )
                t3.firstChild.remove();
              t3.append(o2);
            }
            viewToDom(t3, e3, n2 = {}) {
              if (t3.is("$text")) {
                const n3 = this._processDataFromViewText(t3);
                return e3.createTextNode(n3);
              }
              {
                if (this.mapViewToDom(t3))
                  return this.mapViewToDom(t3);
                let o2;
                if (t3.is("documentFragment"))
                  o2 = e3.createDocumentFragment(), n2.bind && this.bindDocumentFragments(o2, t3);
                else {
                  if (t3.is("uiElement"))
                    return o2 = "$comment" === t3.name ? e3.createComment(t3.getCustomProperty("$rawContent")) : t3.render(e3, this), n2.bind && this.bindElements(o2, t3), o2;
                  this._shouldRenameElement(t3.name) ? (fs(t3.name), o2 = this._createReplacementDomElement(t3.name)) : o2 = t3.hasAttribute("xmlns") ? e3.createElementNS(t3.getAttribute("xmlns"), t3.name) : e3.createElement(t3.name), t3.is("rawElement") && t3.render(o2, this), n2.bind && this.bindElements(o2, t3);
                  for (const e4 of t3.getAttributeKeys())
                    this.setDomElementAttribute(o2, e4, t3.getAttribute(e4), t3);
                }
                if (false !== n2.withChildren)
                  for (const i2 of this.viewChildrenToDom(t3, e3, n2))
                    o2.appendChild(i2);
                return o2;
              }
            }
            setDomElementAttribute(t3, e3, n2, o2 = null) {
              const i2 = this.shouldRenderAttribute(e3, n2, t3.tagName.toLowerCase()) || o2 && o2.shouldRenderUnsafeAttribute(e3);
              i2 || c("domconverter-unsafe-attribute-detected", { domElement: t3, key: e3, value: n2 }), t3.hasAttribute(e3) && !i2 ? t3.removeAttribute(e3) : t3.hasAttribute(ds + e3) && i2 && t3.removeAttribute(ds + e3), t3.setAttribute(i2 ? e3 : ds + e3, n2);
            }
            removeDomElementAttribute(t3, e3) {
              e3 != hs && (t3.removeAttribute(e3), t3.removeAttribute(ds + e3));
            }
            *viewChildrenToDom(t3, e3, n2 = {}) {
              const o2 = t3.getFillerOffset && t3.getFillerOffset();
              let i2 = 0;
              for (const r2 of t3.getChildren())
                o2 === i2 && (yield this._getBlockFiller(e3)), yield this.viewToDom(r2, e3, n2), i2++;
              o2 === i2 && (yield this._getBlockFiller(e3));
            }
            viewRangeToDom(t3) {
              const e3 = this.viewPositionToDom(t3.start), n2 = this.viewPositionToDom(t3.end), o2 = document.createRange();
              return o2.setStart(e3.parent, e3.offset), o2.setEnd(n2.parent, n2.offset), o2;
            }
            viewPositionToDom(t3) {
              const e3 = t3.parent;
              if (e3.is("$text")) {
                const n2 = this.findCorrespondingDomText(e3);
                if (!n2)
                  return null;
                let o2 = t3.offset;
                return Rr(n2) && (o2 += 7), { parent: n2, offset: o2 };
              }
              {
                let n2, o2, i2;
                if (0 === t3.offset) {
                  if (n2 = this.mapViewToDom(e3), !n2)
                    return null;
                  i2 = n2.childNodes[0];
                } else {
                  const e4 = t3.nodeBefore;
                  if (o2 = e4.is("$text") ? this.findCorrespondingDomText(e4) : this.mapViewToDom(t3.nodeBefore), !o2)
                    return null;
                  n2 = o2.parentNode, i2 = o2.nextSibling;
                }
                if (Br(i2) && Rr(i2))
                  return { parent: i2, offset: 7 };
                return { parent: n2, offset: o2 ? rs(o2) + 1 : 0 };
              }
            }
            domToView(t3, e3 = {}) {
              if (this.isBlockFiller(t3))
                return null;
              const n2 = this.getHostViewElement(t3);
              if (n2)
                return n2;
              if (Qr(t3) && e3.skipComments)
                return null;
              if (Br(t3)) {
                if (jr(t3))
                  return null;
                {
                  const e4 = this._processDataFromDomText(t3);
                  return "" === e4 ? null : new Fo(this.document, e4);
                }
              }
              {
                if (this.mapDomToView(t3))
                  return this.mapDomToView(t3);
                let n3;
                if (this.isDocumentFragment(t3))
                  n3 = new Ar(this.document), e3.bind && this.bindDocumentFragments(t3, n3);
                else {
                  n3 = this._createViewElement(t3, e3), e3.bind && this.bindElements(t3, n3);
                  const o2 = t3.attributes;
                  if (o2)
                    for (let t4 = o2.length - 1; t4 >= 0; t4--)
                      n3._setAttribute(o2[t4].name, o2[t4].value);
                  if (this._isViewElementWithRawContent(n3, e3) || Qr(t3)) {
                    const e4 = Qr(t3) ? t3.data : t3.innerHTML;
                    return n3._setCustomProperty("$rawContent", e4), this._encounteredRawContentDomNodes.add(t3), n3;
                  }
                }
                if (false !== e3.withChildren)
                  for (const o2 of this.domChildrenToView(t3, e3))
                    n3._appendChild(o2);
                return n3;
              }
            }
            *domChildrenToView(t3, e3 = {}) {
              for (let n2 = 0; n2 < t3.childNodes.length; n2++) {
                const o2 = t3.childNodes[n2], i2 = this.domToView(o2, e3);
                null !== i2 && (yield i2);
              }
            }
            domSelectionToView(t3) {
              if (1 === t3.rangeCount) {
                let e4 = t3.getRangeAt(0).startContainer;
                Br(e4) && (e4 = e4.parentNode);
                const n3 = this.fakeSelectionToView(e4);
                if (n3)
                  return n3;
              }
              const e3 = this.isDomSelectionBackward(t3), n2 = [];
              for (let e4 = 0; e4 < t3.rangeCount; e4++) {
                const o2 = t3.getRangeAt(e4), i2 = this.domRangeToView(o2);
                i2 && n2.push(i2);
              }
              return new Ui(n2, { backward: e3 });
            }
            domRangeToView(t3) {
              const e3 = this.domPositionToView(t3.startContainer, t3.startOffset), n2 = this.domPositionToView(t3.endContainer, t3.endOffset);
              return e3 && n2 ? new ji(e3, n2) : null;
            }
            domPositionToView(t3, e3 = 0) {
              if (this.isBlockFiller(t3))
                return this.domPositionToView(t3.parentNode, rs(t3));
              const n2 = this.mapDomToView(t3);
              if (n2 && (n2.is("uiElement") || n2.is("rawElement")))
                return Ri._createBefore(n2);
              if (Br(t3)) {
                if (jr(t3))
                  return this.domPositionToView(t3.parentNode, rs(t3));
                const n3 = this.findCorrespondingViewText(t3);
                let o2 = e3;
                return n3 ? (Rr(t3) && (o2 -= 7, o2 = o2 < 0 ? 0 : o2), new Ri(n3, o2)) : null;
              }
              if (0 === e3) {
                const e4 = this.mapDomToView(t3);
                if (e4)
                  return new Ri(e4, 0);
              } else {
                const n3 = t3.childNodes[e3 - 1], o2 = Br(n3) ? this.findCorrespondingViewText(n3) : this.mapDomToView(n3);
                if (o2 && o2.parent)
                  return new Ri(o2.parent, o2.index + 1);
              }
              return null;
            }
            mapDomToView(t3) {
              return this.getHostViewElement(t3) || this._domToViewMapping.get(t3);
            }
            findCorrespondingViewText(t3) {
              if (jr(t3))
                return null;
              const e3 = this.getHostViewElement(t3);
              if (e3)
                return e3;
              const n2 = t3.previousSibling;
              if (n2) {
                if (!this.isElement(n2))
                  return null;
                const t4 = this.mapDomToView(n2);
                if (t4) {
                  return t4.nextSibling instanceof Fo ? t4.nextSibling : null;
                }
              } else {
                const e4 = this.mapDomToView(t3.parentNode);
                if (e4) {
                  const t4 = e4.getChild(0);
                  return t4 instanceof Fo ? t4 : null;
                }
              }
              return null;
            }
            mapViewToDom(t3) {
              return this._viewToDomMapping.get(t3);
            }
            findCorrespondingDomText(t3) {
              const e3 = t3.previousSibling;
              return e3 && this.mapViewToDom(e3) ? this.mapViewToDom(e3).nextSibling : !e3 && t3.parent && this.mapViewToDom(t3.parent) ? this.mapViewToDom(t3.parent).childNodes[0] : null;
            }
            focus(t3) {
              const e3 = this.mapViewToDom(t3);
              if (e3 && e3.ownerDocument.activeElement !== e3) {
                const { scrollX: t4, scrollY: n2 } = is.window, o2 = [];
                ms(e3, (t5) => {
                  const { scrollLeft: e4, scrollTop: n3 } = t5;
                  o2.push([e4, n3]);
                }), e3.focus(), ms(e3, (t5) => {
                  const [e4, n3] = o2.shift();
                  t5.scrollLeft = e4, t5.scrollTop = n3;
                }), is.window.scrollTo(t4, n2);
              }
            }
            isElement(t3) {
              return t3 && t3.nodeType == Node.ELEMENT_NODE;
            }
            isDocumentFragment(t3) {
              return t3 && t3.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
            }
            isBlockFiller(t3) {
              return "br" == this.blockFillerMode ? t3.isEqualNode(as) : !("BR" !== t3.tagName || !ps(t3, this.blockElements) || 1 !== t3.parentNode.childNodes.length) || (t3.isEqualNode(ls) || function(t4, e3) {
                return t4.isEqualNode(cs) && ps(t4, e3) && 1 === t4.parentNode.childNodes.length;
              }(t3, this.blockElements));
            }
            isDomSelectionBackward(t3) {
              if (t3.isCollapsed)
                return false;
              const e3 = document.createRange();
              e3.setStart(t3.anchorNode, t3.anchorOffset), e3.setEnd(t3.focusNode, t3.focusOffset);
              const n2 = e3.collapsed;
              return e3.detach(), n2;
            }
            getHostViewElement(t3) {
              const e3 = ss(t3);
              for (e3.pop(); e3.length; ) {
                const t4 = e3.pop(), n2 = this._domToViewMapping.get(t4);
                if (n2 && (n2.is("uiElement") || n2.is("rawElement")))
                  return n2;
              }
              return null;
            }
            isDomSelectionCorrect(t3) {
              return this._isDomSelectionPositionCorrect(t3.anchorNode, t3.anchorOffset) && this._isDomSelectionPositionCorrect(t3.focusNode, t3.focusOffset);
            }
            registerRawContentMatcher(t3) {
              this._rawContentElementMatcher.add(t3);
            }
            _getBlockFiller(t3) {
              switch (this.blockFillerMode) {
                case "nbsp":
                  return zr(t3);
                case "markedNbsp":
                  return Pr(t3);
                case "br":
                  return Lr(t3);
              }
            }
            _isDomSelectionPositionCorrect(t3, e3) {
              if (Br(t3) && Rr(t3) && e3 < 7)
                return false;
              if (this.isElement(t3) && Rr(t3.childNodes[e3]))
                return false;
              const n2 = this.mapDomToView(t3);
              return !n2 || !n2.is("uiElement") && !n2.is("rawElement");
            }
            _processDataFromViewText(t3) {
              let e3 = t3.data;
              if (t3.getAncestors().some((t4) => this.preElements.includes(t4.name)))
                return e3;
              if (" " == e3.charAt(0)) {
                const n2 = this._getTouchingInlineViewNode(t3, false);
                !(n2 && n2.is("$textProxy") && this._nodeEndsWithSpace(n2)) && n2 || (e3 = "\xA0" + e3.substr(1));
              }
              if (" " == e3.charAt(e3.length - 1)) {
                const n2 = this._getTouchingInlineViewNode(t3, true), o2 = n2 && n2.is("$textProxy") && " " == n2.data.charAt(0);
                " " != e3.charAt(e3.length - 2) && n2 && !o2 || (e3 = e3.substr(0, e3.length - 1) + "\xA0");
              }
              return e3.replace(/ {2}/g, " \xA0");
            }
            _nodeEndsWithSpace(t3) {
              if (t3.getAncestors().some((t4) => this.preElements.includes(t4.name)))
                return false;
              const e3 = this._processDataFromViewText(t3);
              return " " == e3.charAt(e3.length - 1);
            }
            _processDataFromDomText(t3) {
              let e3 = t3.data;
              if (function(t4, e4) {
                return ss(t4).some((t5) => t5.tagName && e4.includes(t5.tagName.toLowerCase()));
              }(t3, this.preElements))
                return Fr(t3);
              e3 = e3.replace(/[ \n\t\r]{1,}/g, " ");
              const n2 = this._getTouchingInlineDomNode(t3, false), o2 = this._getTouchingInlineDomNode(t3, true), i2 = this._checkShouldLeftTrimDomText(t3, n2), r2 = this._checkShouldRightTrimDomText(t3, o2);
              i2 && (e3 = e3.replace(/^ /, "")), r2 && (e3 = e3.replace(/ $/, "")), e3 = Fr(new Text(e3)), e3 = e3.replace(/ \u00A0/g, "  ");
              const s2 = o2 && this.isElement(o2) && "BR" != o2.tagName, a2 = o2 && Br(o2) && " " == o2.data.charAt(0);
              return (/( |\u00A0)\u00A0$/.test(e3) || !o2 || s2 || a2) && (e3 = e3.replace(/\u00A0$/, " ")), (i2 || n2 && this.isElement(n2) && "BR" != n2.tagName) && (e3 = e3.replace(/^\u00A0/, " ")), e3;
            }
            _checkShouldLeftTrimDomText(t3, e3) {
              return !e3 || (this.isElement(e3) ? "BR" === e3.tagName : !this._encounteredRawContentDomNodes.has(t3.previousSibling) && /[^\S\u00A0]/.test(e3.data.charAt(e3.data.length - 1)));
            }
            _checkShouldRightTrimDomText(t3, e3) {
              return !e3 && !Rr(t3);
            }
            _getTouchingInlineViewNode(t3, e3) {
              const n2 = new Oi({ startPosition: e3 ? Ri._createAfter(t3) : Ri._createBefore(t3), direction: e3 ? "forward" : "backward" });
              for (const t4 of n2) {
                if (t4.item.is("element") && this.inlineObjectElements.includes(t4.item.name))
                  return t4.item;
                if (t4.item.is("containerElement"))
                  return null;
                if (t4.item.is("element", "br"))
                  return null;
                if (t4.item.is("$textProxy"))
                  return t4.item;
              }
              return null;
            }
            _getTouchingInlineDomNode(t3, e3) {
              if (!t3.parentNode)
                return null;
              const n2 = e3 ? "firstChild" : "lastChild", o2 = e3 ? "nextSibling" : "previousSibling";
              let i2 = true;
              do {
                if (!i2 && t3[n2] ? t3 = t3[n2] : t3[o2] ? (t3 = t3[o2], i2 = false) : (t3 = t3.parentNode, i2 = true), !t3 || this._isBlockElement(t3))
                  return null;
              } while (!Br(t3) && "BR" != t3.tagName && !this._isInlineObjectElement(t3));
              return t3;
            }
            _isBlockElement(t3) {
              return this.isElement(t3) && this.blockElements.includes(t3.tagName.toLowerCase());
            }
            _isInlineObjectElement(t3) {
              return this.isElement(t3) && this.inlineObjectElements.includes(t3.tagName.toLowerCase());
            }
            _createViewElement(t3, e3) {
              if (Qr(t3))
                return new fr(this.document, "$comment");
              const n2 = e3.keepOriginalCase ? t3.tagName : t3.tagName.toLowerCase();
              return new Si(this.document, n2);
            }
            _isViewElementWithRawContent(t3, e3) {
              return false !== e3.withChildren && this._rawContentElementMatcher.match(t3);
            }
            _shouldRenameElement(t3) {
              const e3 = t3.toLowerCase();
              return "editing" === this.renderingMode && us.includes(e3);
            }
            _createReplacementDomElement(t3, e3 = null) {
              const n2 = document.createElement("span");
              if (n2.setAttribute(hs, t3), e3) {
                for (; e3.firstChild; )
                  n2.appendChild(e3.firstChild);
                for (const t4 of e3.getAttributeNames())
                  n2.setAttribute(t4, e3.getAttribute(t4));
              }
              return n2;
            }
          }
          function ms(t3, e3) {
            for (; t3 && t3 != is.document; )
              e3(t3), t3 = t3.parentNode;
          }
          function ps(t3, e3) {
            const n2 = t3.parentNode;
            return n2 && n2.tagName && e3.includes(n2.tagName.toLowerCase());
          }
          function fs(t3) {
            "script" === t3 && c("domconverter-unsafe-script-element-detected"), "style" === t3 && c("domconverter-unsafe-style-element-detected");
          }
          function ks(t3) {
            const e3 = Object.prototype.toString.apply(t3);
            return "[object Window]" == e3 || "[object global]" == e3;
          }
          const bs = Jt({}, f, { listenTo(t3, e3, n2, o2 = {}) {
            if (Kr(t3) || ks(t3)) {
              const i2 = { capture: !!o2.useCapture, passive: !!o2.usePassive }, r2 = this._getProxyEmitter(t3, i2) || new Cs(t3, i2);
              this.listenTo(r2, e3, n2, o2);
            } else
              f.listenTo.call(this, t3, e3, n2, o2);
          }, stopListening(t3, e3, n2) {
            if (Kr(t3) || ks(t3)) {
              const o2 = this._getAllProxyEmitters(t3);
              for (const t4 of o2)
                this.stopListening(t4, e3, n2);
            } else
              f.stopListening.call(this, t3, e3, n2);
          }, _getProxyEmitter(t3, e3) {
            return n2 = this, o2 = As(t3, e3), n2[g] && n2[g][o2] ? n2[g][o2].emitter : null;
            var n2, o2;
          }, _getAllProxyEmitters(t3) {
            return [{ capture: false, passive: false }, { capture: false, passive: true }, { capture: true, passive: false }, { capture: true, passive: true }].map((e3) => this._getProxyEmitter(t3, e3)).filter((t4) => !!t4);
          } }), ws = bs;
          class Cs {
            constructor(t3, e3) {
              k(this, As(t3, e3)), this._domNode = t3, this._options = e3;
            }
          }
          function As(t3, e3) {
            let n2 = function(t4) {
              return t4["data-ck-expando"] || (t4["data-ck-expando"] = r());
            }(t3);
            for (const t4 of Object.keys(e3).sort())
              e3[t4] && (n2 += "-" + t4);
            return n2;
          }
          Jt(Cs.prototype, f, { attach(t3) {
            if (this._domListeners && this._domListeners[t3])
              return;
            const e3 = this._createDomListener(t3);
            this._domNode.addEventListener(t3, e3, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[t3] = e3;
          }, detach(t3) {
            let e3;
            !this._domListeners[t3] || (e3 = this._events[t3]) && e3.callbacks.length || this._domListeners[t3].removeListener();
          }, _addEventListener(t3, e3, n2) {
            this.attach(t3), f._addEventListener.call(this, t3, e3, n2);
          }, _removeEventListener(t3, e3) {
            f._removeEventListener.call(this, t3, e3), this.detach(t3);
          }, _createDomListener(t3) {
            const e3 = (e4) => {
              this.fire(t3, e4);
            };
            return e3.removeListener = () => {
              this._domNode.removeEventListener(t3, e3, this._options), delete this._domListeners[t3];
            }, e3;
          } });
          class _s {
            constructor(t3) {
              this.view = t3, this.document = t3.document, this.isEnabled = false;
            }
            enable() {
              this.isEnabled = true;
            }
            disable() {
              this.isEnabled = false;
            }
            destroy() {
              this.disable(), this.stopListening();
            }
            checkShouldIgnoreEventFromTarget(t3) {
              return t3 && 3 === t3.nodeType && (t3 = t3.parentNode), !(!t3 || 1 !== t3.nodeType) && t3.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
            }
          }
          he(_s, ws);
          const vs = function(t3) {
            return this.__data__.set(t3, "__lodash_hash_undefined__"), this;
          };
          const ys = function(t3) {
            return this.__data__.has(t3);
          };
          function xs(t3) {
            var e3 = -1, n2 = null == t3 ? 0 : t3.length;
            for (this.__data__ = new on(); ++e3 < n2; )
              this.add(t3[e3]);
          }
          xs.prototype.add = xs.prototype.push = vs, xs.prototype.has = ys;
          const Es = xs;
          const Ds = function(t3, e3) {
            for (var n2 = -1, o2 = null == t3 ? 0 : t3.length; ++n2 < o2; )
              if (e3(t3[n2], n2, t3))
                return true;
            return false;
          };
          const Is = function(t3, e3) {
            return t3.has(e3);
          };
          const Ms = function(t3, e3, n2, o2, i2, r2) {
            var s2 = 1 & n2, a2 = t3.length, c2 = e3.length;
            if (a2 != c2 && !(s2 && c2 > a2))
              return false;
            var l2 = r2.get(t3), d2 = r2.get(e3);
            if (l2 && d2)
              return l2 == e3 && d2 == t3;
            var h2 = -1, u2 = true, g2 = 2 & n2 ? new Es() : void 0;
            for (r2.set(t3, e3), r2.set(e3, t3); ++h2 < a2; ) {
              var m2 = t3[h2], p2 = e3[h2];
              if (o2)
                var f2 = s2 ? o2(p2, m2, h2, e3, t3, r2) : o2(m2, p2, h2, t3, e3, r2);
              if (void 0 !== f2) {
                if (f2)
                  continue;
                u2 = false;
                break;
              }
              if (g2) {
                if (!Ds(e3, function(t4, e4) {
                  if (!Is(g2, e4) && (m2 === t4 || i2(m2, t4, n2, o2, r2)))
                    return g2.push(e4);
                })) {
                  u2 = false;
                  break;
                }
              } else if (m2 !== p2 && !i2(m2, p2, n2, o2, r2)) {
                u2 = false;
                break;
              }
            }
            return r2.delete(t3), r2.delete(e3), u2;
          };
          const Ss = function(t3) {
            var e3 = -1, n2 = Array(t3.size);
            return t3.forEach(function(t4, o2) {
              n2[++e3] = [o2, t4];
            }), n2;
          };
          const Ts = function(t3) {
            var e3 = -1, n2 = Array(t3.size);
            return t3.forEach(function(t4) {
              n2[++e3] = t4;
            }), n2;
          };
          var Ns = I ? I.prototype : void 0, Bs = Ns ? Ns.valueOf : void 0;
          const zs = function(t3, e3, n2, o2, i2, r2, s2) {
            switch (n2) {
              case "[object DataView]":
                if (t3.byteLength != e3.byteLength || t3.byteOffset != e3.byteOffset)
                  return false;
                t3 = t3.buffer, e3 = e3.buffer;
              case "[object ArrayBuffer]":
                return !(t3.byteLength != e3.byteLength || !r2(new Zn(t3), new Zn(e3)));
              case "[object Boolean]":
              case "[object Date]":
              case "[object Number]":
                return et(+t3, +e3);
              case "[object Error]":
                return t3.name == e3.name && t3.message == e3.message;
              case "[object RegExp]":
              case "[object String]":
                return t3 == e3 + "";
              case "[object Map]":
                var a2 = Ss;
              case "[object Set]":
                var c2 = 1 & o2;
                if (a2 || (a2 = Ts), t3.size != e3.size && !c2)
                  return false;
                var l2 = s2.get(t3);
                if (l2)
                  return l2 == e3;
                o2 |= 2, s2.set(t3, e3);
                var d2 = Ms(a2(t3), a2(e3), o2, i2, r2, s2);
                return s2.delete(t3), d2;
              case "[object Symbol]":
                if (Bs)
                  return Bs.call(t3) == Bs.call(e3);
            }
            return false;
          };
          var Ps = Object.prototype.hasOwnProperty;
          const Ls = function(t3, e3, n2, o2, i2, r2) {
            var s2 = 1 & n2, a2 = Tn(t3), c2 = a2.length;
            if (c2 != Tn(e3).length && !s2)
              return false;
            for (var l2 = c2; l2--; ) {
              var d2 = a2[l2];
              if (!(s2 ? d2 in e3 : Ps.call(e3, d2)))
                return false;
            }
            var h2 = r2.get(t3), u2 = r2.get(e3);
            if (h2 && u2)
              return h2 == e3 && u2 == t3;
            var g2 = true;
            r2.set(t3, e3), r2.set(e3, t3);
            for (var m2 = s2; ++l2 < c2; ) {
              var p2 = t3[d2 = a2[l2]], f2 = e3[d2];
              if (o2)
                var k2 = s2 ? o2(f2, p2, d2, e3, t3, r2) : o2(p2, f2, d2, t3, e3, r2);
              if (!(void 0 === k2 ? p2 === f2 || i2(p2, f2, n2, o2, r2) : k2)) {
                g2 = false;
                break;
              }
              m2 || (m2 = "constructor" == d2);
            }
            if (g2 && !m2) {
              var b2 = t3.constructor, w2 = e3.constructor;
              b2 == w2 || !("constructor" in t3) || !("constructor" in e3) || "function" == typeof b2 && b2 instanceof b2 && "function" == typeof w2 && w2 instanceof w2 || (g2 = false);
            }
            return r2.delete(t3), r2.delete(e3), g2;
          };
          var Os = "[object Arguments]", Rs = "[object Array]", js = "[object Object]", Fs = Object.prototype.hasOwnProperty;
          const Vs = function(t3, e3, n2, o2, i2, r2) {
            var s2 = Mt(t3), a2 = Mt(e3), c2 = s2 ? Rs : Qn(t3), l2 = a2 ? Rs : Qn(e3), d2 = (c2 = c2 == Os ? js : c2) == js, h2 = (l2 = l2 == Os ? js : l2) == js, u2 = c2 == l2;
            if (u2 && zt(t3)) {
              if (!zt(e3))
                return false;
              s2 = true, d2 = false;
            }
            if (u2 && !d2)
              return r2 || (r2 = new an()), s2 || Ht(t3) ? Ms(t3, e3, n2, o2, i2, r2) : zs(t3, e3, c2, n2, o2, i2, r2);
            if (!(1 & n2)) {
              var g2 = d2 && Fs.call(t3, "__wrapped__"), m2 = h2 && Fs.call(e3, "__wrapped__");
              if (g2 || m2) {
                var p2 = g2 ? t3.value() : t3, f2 = m2 ? e3.value() : e3;
                return r2 || (r2 = new an()), i2(p2, f2, n2, o2, r2);
              }
            }
            return !!u2 && (r2 || (r2 = new an()), Ls(t3, e3, n2, o2, i2, r2));
          };
          const Us = function t3(e3, n2, o2, i2, r2) {
            return e3 === n2 || (null == e3 || null == n2 || !_t(e3) && !_t(n2) ? e3 != e3 && n2 != n2 : Vs(e3, n2, o2, i2, t3, r2));
          };
          const Hs = function(t3, e3, n2) {
            var o2 = (n2 = "function" == typeof n2 ? n2 : void 0) ? n2(t3, e3) : void 0;
            return void 0 === o2 ? Us(t3, e3, void 0, n2) : !!o2;
          };
          class qs extends _s {
            constructor(t3) {
              super(t3), this._config = { childList: true, characterData: true, characterDataOldValue: true, subtree: true }, this.domConverter = t3.domConverter, this.renderer = t3._renderer, this._domElements = [], this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
            }
            flush() {
              this._onMutations(this._mutationObserver.takeRecords());
            }
            observe(t3) {
              this._domElements.push(t3), this.isEnabled && this._mutationObserver.observe(t3, this._config);
            }
            enable() {
              super.enable();
              for (const t3 of this._domElements)
                this._mutationObserver.observe(t3, this._config);
            }
            disable() {
              super.disable(), this._mutationObserver.disconnect();
            }
            destroy() {
              super.destroy(), this._mutationObserver.disconnect();
            }
            _onMutations(t3) {
              if (0 === t3.length)
                return;
              const e3 = this.domConverter, n2 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Set();
              for (const n3 of t3)
                if ("childList" === n3.type) {
                  const t4 = e3.mapDomToView(n3.target);
                  if (t4 && (t4.is("uiElement") || t4.is("rawElement")))
                    continue;
                  t4 && !this._isBogusBrMutation(n3) && o2.add(t4);
                }
              for (const i3 of t3) {
                const t4 = e3.mapDomToView(i3.target);
                if ((!t4 || !t4.is("uiElement") && !t4.is("rawElement")) && "characterData" === i3.type) {
                  const t5 = e3.findCorrespondingViewText(i3.target);
                  t5 && !o2.has(t5.parent) ? n2.set(t5, { type: "text", oldText: t5.data, newText: Fr(i3.target), node: t5 }) : !t5 && Rr(i3.target) && o2.add(e3.mapDomToView(i3.target.parentNode));
                }
              }
              const i2 = [];
              for (const t4 of n2.values())
                this.renderer.markToSync("text", t4.node), i2.push(t4);
              for (const t4 of o2) {
                const n3 = e3.mapViewToDom(t4), o3 = Array.from(t4.getChildren()), r3 = Array.from(e3.domChildrenToView(n3, { withChildren: false }));
                Hs(o3, r3, a2) || (this.renderer.markToSync("children", t4), i2.push({ type: "children", oldChildren: o3, newChildren: r3, node: t4 }));
              }
              const r2 = t3[0].target.ownerDocument.getSelection();
              let s2 = null;
              if (r2 && r2.anchorNode) {
                const t4 = e3.domPositionToView(r2.anchorNode, r2.anchorOffset), n3 = e3.domPositionToView(r2.focusNode, r2.focusOffset);
                t4 && n3 && (s2 = new Ui(t4), s2.setFocus(n3));
              }
              function a2(t4, e4) {
                if (!Array.isArray(t4))
                  return t4 === e4 || !(!t4.is("$text") || !e4.is("$text")) && t4.data === e4.data;
              }
              i2.length && (this.document.fire("mutations", i2, s2), this.view.forceRender());
            }
            _isBogusBrMutation(t3) {
              let e3 = null;
              return null === t3.nextSibling && 0 === t3.removedNodes.length && 1 == t3.addedNodes.length && (e3 = this.domConverter.domToView(t3.addedNodes[0], { withChildren: false })), e3 && e3.is("element", "br");
            }
          }
          class Ws {
            constructor(t3, e3, n2) {
              this.view = t3, this.document = t3.document, this.domEvent = e3, this.domTarget = e3.target, Jt(this, n2);
            }
            get target() {
              return this.view.domConverter.mapDomToView(this.domTarget);
            }
            preventDefault() {
              this.domEvent.preventDefault();
            }
            stopPropagation() {
              this.domEvent.stopPropagation();
            }
          }
          class Gs extends _s {
            constructor(t3) {
              super(t3), this.useCapture = false;
            }
            observe(t3) {
              ("string" == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach((e3) => {
                this.listenTo(t3, e3, (t4, e4) => {
                  this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e4.target) && this.onDomEvent(e4);
                }, { useCapture: this.useCapture });
              });
            }
            fire(t3, e3, n2) {
              this.isEnabled && this.document.fire(t3, new Ws(this.view, e3, n2));
            }
          }
          class Ys extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = ["keydown", "keyup"];
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3, { keyCode: t3.keyCode, altKey: t3.altKey, ctrlKey: t3.ctrlKey, shiftKey: t3.shiftKey, metaKey: t3.metaKey, get keystroke() {
                return ur(this);
              } });
            }
          }
          const Qs = function() {
            return D.Date.now();
          };
          var Ks = /\s/;
          const $s = function(t3) {
            for (var e3 = t3.length; e3-- && Ks.test(t3.charAt(e3)); )
              ;
            return e3;
          };
          var Zs = /^\s+/;
          const Js = function(t3) {
            return t3 ? t3.slice(0, $s(t3) + 1).replace(Zs, "") : t3;
          };
          var Xs = /^[-+]0x[0-9a-f]+$/i, ta = /^0b[01]+$/i, ea = /^0o[0-7]+$/i, na = parseInt;
          const oa = function(t3) {
            if ("number" == typeof t3)
              return t3;
            if (Go(t3))
              return NaN;
            if (y(t3)) {
              var e3 = "function" == typeof t3.valueOf ? t3.valueOf() : t3;
              t3 = y(e3) ? e3 + "" : e3;
            }
            if ("string" != typeof t3)
              return 0 === t3 ? t3 : +t3;
            t3 = Js(t3);
            var n2 = ta.test(t3);
            return n2 || ea.test(t3) ? na(t3.slice(2), n2 ? 2 : 8) : Xs.test(t3) ? NaN : +t3;
          };
          var ia = Math.max, ra = Math.min;
          const sa = function(t3, e3, n2) {
            var o2, i2, r2, s2, a2, c2, l2 = 0, d2 = false, h2 = false, u2 = true;
            if ("function" != typeof t3)
              throw new TypeError("Expected a function");
            function g2(e4) {
              var n3 = o2, r3 = i2;
              return o2 = i2 = void 0, l2 = e4, s2 = t3.apply(r3, n3);
            }
            function m2(t4) {
              return l2 = t4, a2 = setTimeout(f2, e3), d2 ? g2(t4) : s2;
            }
            function p2(t4) {
              var n3 = t4 - c2;
              return void 0 === c2 || n3 >= e3 || n3 < 0 || h2 && t4 - l2 >= r2;
            }
            function f2() {
              var t4 = Qs();
              if (p2(t4))
                return k2(t4);
              a2 = setTimeout(f2, function(t5) {
                var n3 = e3 - (t5 - c2);
                return h2 ? ra(n3, r2 - (t5 - l2)) : n3;
              }(t4));
            }
            function k2(t4) {
              return a2 = void 0, u2 && o2 ? g2(t4) : (o2 = i2 = void 0, s2);
            }
            function b2() {
              var t4 = Qs(), n3 = p2(t4);
              if (o2 = arguments, i2 = this, c2 = t4, n3) {
                if (void 0 === a2)
                  return m2(c2);
                if (h2)
                  return clearTimeout(a2), a2 = setTimeout(f2, e3), g2(c2);
              }
              return void 0 === a2 && (a2 = setTimeout(f2, e3)), s2;
            }
            return e3 = oa(e3) || 0, y(n2) && (d2 = !!n2.leading, r2 = (h2 = "maxWait" in n2) ? ia(oa(n2.maxWait) || 0, e3) : r2, u2 = "trailing" in n2 ? !!n2.trailing : u2), b2.cancel = function() {
              void 0 !== a2 && clearTimeout(a2), l2 = 0, o2 = c2 = i2 = a2 = void 0;
            }, b2.flush = function() {
              return void 0 === a2 ? s2 : k2(Qs());
            }, b2;
          };
          class aa extends _s {
            constructor(t3) {
              super(t3), this._fireSelectionChangeDoneDebounced = sa((t4) => this.document.fire("selectionChangeDone", t4), 200);
            }
            observe() {
              const t3 = this.document;
              t3.on("arrowKey", (e3, n2) => {
                t3.selection.isFake && this.isEnabled && n2.preventDefault();
              }, { context: "$capture" }), t3.on("arrowKey", (e3, n2) => {
                t3.selection.isFake && this.isEnabled && this._handleSelectionMove(n2.keyCode);
              }, { priority: "lowest" });
            }
            destroy() {
              super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
            }
            _handleSelectionMove(t3) {
              const e3 = this.document.selection, n2 = new Ui(e3.getRanges(), { backward: e3.isBackward, fake: false });
              t3 != dr.arrowleft && t3 != dr.arrowup || n2.setTo(n2.getFirstPosition()), t3 != dr.arrowright && t3 != dr.arrowdown || n2.setTo(n2.getLastPosition());
              const o2 = { oldSelection: e3, newSelection: n2, domSelection: null };
              this.document.fire("selectionChange", o2), this._fireSelectionChangeDoneDebounced(o2);
            }
          }
          class ca extends _s {
            constructor(t3) {
              super(t3), this.mutationObserver = t3.getObserver(qs), this.selection = this.document.selection, this.domConverter = t3.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = sa((t4) => this.document.fire("selectionChangeDone", t4), 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = sa(() => this.document.isSelecting = false, 5e3), this._loopbackCounter = 0;
            }
            observe(t3) {
              const e3 = t3.ownerDocument, n2 = () => {
                this.document.isSelecting = false, this._documentIsSelectingInactivityTimeoutDebounced.cancel();
              };
              this.listenTo(t3, "selectstart", () => {
                this.document.isSelecting = true, this._documentIsSelectingInactivityTimeoutDebounced();
              }, { priority: "highest" }), this.listenTo(t3, "keydown", n2, { priority: "highest" }), this.listenTo(t3, "keyup", n2, { priority: "highest" }), this._documents.has(e3) || (this.listenTo(e3, "mouseup", n2, { priority: "highest" }), this.listenTo(e3, "selectionchange", (t4, n3) => {
                this._handleSelectionChange(n3, e3), this._documentIsSelectingInactivityTimeoutDebounced();
              }), this._documents.add(e3));
            }
            destroy() {
              super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
            }
            _handleSelectionChange(t3, e3) {
              if (!this.isEnabled)
                return;
              const n2 = e3.defaultView.getSelection();
              if (this.checkShouldIgnoreEventFromTarget(n2.anchorNode))
                return;
              this.mutationObserver.flush();
              const o2 = this.domConverter.domSelectionToView(n2);
              if (0 != o2.rangeCount) {
                if (this.view.hasDomSelection = true, !(this.selection.isEqual(o2) && this.domConverter.isDomSelectionCorrect(n2) || ++this._loopbackCounter > 60))
                  if (this.selection.isSimilar(o2))
                    this.view.forceRender();
                  else {
                    const t4 = { oldSelection: this.selection, newSelection: o2, domSelection: n2 };
                    this.document.fire("selectionChange", t4), this._fireSelectionChangeDoneDebounced(t4);
                  }
              } else
                this.view.hasDomSelection = false;
            }
            _clearInfiniteLoop() {
              this._loopbackCounter = 0;
            }
          }
          class la extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = ["focus", "blur"], this.useCapture = true;
              const e3 = this.document;
              e3.on("focus", () => {
                e3.isFocused = true, this._renderTimeoutId = setTimeout(() => t3.change(() => {
                }), 50);
              }), e3.on("blur", (n2, o2) => {
                const i2 = e3.selection.editableElement;
                null !== i2 && i2 !== o2.target || (e3.isFocused = false, t3.change(() => {
                }));
              });
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3);
            }
            destroy() {
              this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
            }
          }
          class da extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
              const e3 = this.document;
              e3.on("compositionstart", () => {
                e3.isComposing = true;
              }), e3.on("compositionend", () => {
                e3.isComposing = false;
              });
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3);
            }
          }
          class ha extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = ["beforeinput"];
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3);
            }
          }
          class ua {
            constructor() {
              this._replacedElements = [];
            }
            replace(t3, e3) {
              this._replacedElements.push({ element: t3, newElement: e3 }), t3.style.display = "none", e3 && t3.parentNode.insertBefore(e3, t3.nextSibling);
            }
            restore() {
              this._replacedElements.forEach(({ element: t3, newElement: e3 }) => {
                t3.style.display = "", e3 && e3.remove();
              }), this._replacedElements = [];
            }
          }
          function ga(t3) {
            return "[object Range]" == Object.prototype.toString.apply(t3);
          }
          function ma(t3) {
            const e3 = t3.ownerDocument.defaultView.getComputedStyle(t3);
            return { top: parseInt(e3.borderTopWidth, 10), right: parseInt(e3.borderRightWidth, 10), bottom: parseInt(e3.borderBottomWidth, 10), left: parseInt(e3.borderLeftWidth, 10) };
          }
          const pa = ["top", "right", "bottom", "left", "width", "height"];
          class fa {
            constructor(t3) {
              const e3 = ga(t3);
              if (Object.defineProperty(this, "_source", { value: t3._source || t3, writable: true, enumerable: false }), vo(t3) || e3)
                if (e3) {
                  const e4 = fa.getDomRangeRects(t3);
                  ka(this, fa.getBoundingRect(e4));
                } else
                  ka(this, t3.getBoundingClientRect());
              else if (ks(t3)) {
                const { innerWidth: e4, innerHeight: n2 } = t3;
                ka(this, { top: 0, right: e4, bottom: n2, left: 0, width: e4, height: n2 });
              } else
                ka(this, t3);
            }
            clone() {
              return new fa(this);
            }
            moveTo(t3, e3) {
              return this.top = e3, this.right = t3 + this.width, this.bottom = e3 + this.height, this.left = t3, this;
            }
            moveBy(t3, e3) {
              return this.top += e3, this.right += t3, this.left += t3, this.bottom += e3, this;
            }
            getIntersection(t3) {
              const e3 = { top: Math.max(this.top, t3.top), right: Math.min(this.right, t3.right), bottom: Math.min(this.bottom, t3.bottom), left: Math.max(this.left, t3.left) };
              return e3.width = e3.right - e3.left, e3.height = e3.bottom - e3.top, e3.width < 0 || e3.height < 0 ? null : new fa(e3);
            }
            getIntersectionArea(t3) {
              const e3 = this.getIntersection(t3);
              return e3 ? e3.getArea() : 0;
            }
            getArea() {
              return this.width * this.height;
            }
            getVisible() {
              const t3 = this._source;
              let e3 = this.clone();
              if (!ba(t3)) {
                let n2 = t3.parentNode || t3.commonAncestorContainer;
                for (; n2 && !ba(n2); ) {
                  const t4 = new fa(n2), o2 = e3.getIntersection(t4);
                  if (!o2)
                    return null;
                  o2.getArea() < e3.getArea() && (e3 = o2), n2 = n2.parentNode;
                }
              }
              return e3;
            }
            isEqual(t3) {
              for (const e3 of pa)
                if (this[e3] !== t3[e3])
                  return false;
              return true;
            }
            contains(t3) {
              const e3 = this.getIntersection(t3);
              return !(!e3 || !e3.isEqual(t3));
            }
            excludeScrollbarsAndBorders() {
              const t3 = this._source;
              let e3, n2, o2;
              if (ks(t3))
                e3 = t3.innerWidth - t3.document.documentElement.clientWidth, n2 = t3.innerHeight - t3.document.documentElement.clientHeight, o2 = t3.getComputedStyle(t3.document.documentElement).direction;
              else {
                const i2 = ma(this._source);
                e3 = t3.offsetWidth - t3.clientWidth - i2.left - i2.right, n2 = t3.offsetHeight - t3.clientHeight - i2.top - i2.bottom, o2 = t3.ownerDocument.defaultView.getComputedStyle(t3).direction, this.left += i2.left, this.top += i2.top, this.right -= i2.right, this.bottom -= i2.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
              }
              return this.width -= e3, "ltr" === o2 ? this.right -= e3 : this.left += e3, this.height -= n2, this.bottom -= n2, this;
            }
            static getDomRangeRects(t3) {
              const e3 = [], n2 = Array.from(t3.getClientRects());
              if (n2.length)
                for (const t4 of n2)
                  e3.push(new fa(t4));
              else {
                let n3 = t3.startContainer;
                Br(n3) && (n3 = n3.parentNode);
                const o2 = new fa(n3.getBoundingClientRect());
                o2.right = o2.left, o2.width = 0, e3.push(o2);
              }
              return e3;
            }
            static getBoundingRect(t3) {
              const e3 = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY };
              let n2 = 0;
              for (const o2 of t3)
                n2++, e3.left = Math.min(e3.left, o2.left), e3.top = Math.min(e3.top, o2.top), e3.right = Math.max(e3.right, o2.right), e3.bottom = Math.max(e3.bottom, o2.bottom);
              return 0 == n2 ? null : (e3.width = e3.right - e3.left, e3.height = e3.bottom - e3.top, new fa(e3));
            }
          }
          function ka(t3, e3) {
            for (const n2 of pa)
              t3[n2] = e3[n2];
          }
          function ba(t3) {
            return !!vo(t3) && t3 === t3.ownerDocument.body;
          }
          class wa {
            constructor(t3, e3) {
              wa._observerInstance || wa._createObserver(), this._element = t3, this._callback = e3, wa._addElementCallback(t3, e3), wa._observerInstance.observe(t3);
            }
            destroy() {
              wa._deleteElementCallback(this._element, this._callback);
            }
            static _addElementCallback(t3, e3) {
              wa._elementCallbacks || (wa._elementCallbacks = /* @__PURE__ */ new Map());
              let n2 = wa._elementCallbacks.get(t3);
              n2 || (n2 = /* @__PURE__ */ new Set(), wa._elementCallbacks.set(t3, n2)), n2.add(e3);
            }
            static _deleteElementCallback(t3, e3) {
              const n2 = wa._getElementCallbacks(t3);
              n2 && (n2.delete(e3), n2.size || (wa._elementCallbacks.delete(t3), wa._observerInstance.unobserve(t3))), wa._elementCallbacks && !wa._elementCallbacks.size && (wa._observerInstance = null, wa._elementCallbacks = null);
            }
            static _getElementCallbacks(t3) {
              return wa._elementCallbacks ? wa._elementCallbacks.get(t3) : null;
            }
            static _createObserver() {
              let t3;
              t3 = "function" == typeof is.window.ResizeObserver ? is.window.ResizeObserver : Ca, wa._observerInstance = new t3((t4) => {
                for (const e3 of t4) {
                  const t5 = wa._getElementCallbacks(e3.target);
                  if (t5)
                    for (const n2 of t5)
                      n2(e3);
                }
              });
            }
          }
          wa._observerInstance = null, wa._elementCallbacks = null;
          class Ca {
            constructor(t3) {
              this._callback = t3, this._elements = /* @__PURE__ */ new Set(), this._previousRects = /* @__PURE__ */ new Map(), this._periodicCheckTimeout = null;
            }
            observe(t3) {
              this._elements.add(t3), this._checkElementRectsAndExecuteCallback(), 1 === this._elements.size && this._startPeriodicCheck();
            }
            unobserve(t3) {
              this._elements.delete(t3), this._previousRects.delete(t3), this._elements.size || this._stopPeriodicCheck();
            }
            _startPeriodicCheck() {
              const t3 = () => {
                this._checkElementRectsAndExecuteCallback(), this._periodicCheckTimeout = setTimeout(t3, 100);
              };
              this.listenTo(is.window, "resize", () => {
                this._checkElementRectsAndExecuteCallback();
              }), this._periodicCheckTimeout = setTimeout(t3, 100);
            }
            _stopPeriodicCheck() {
              clearTimeout(this._periodicCheckTimeout), this.stopListening(), this._previousRects.clear();
            }
            _checkElementRectsAndExecuteCallback() {
              const t3 = [];
              for (const e3 of this._elements)
                this._hasRectChanged(e3) && t3.push({ target: e3, contentRect: this._previousRects.get(e3) });
              t3.length && this._callback(t3);
            }
            _hasRectChanged(t3) {
              if (!t3.ownerDocument.body.contains(t3))
                return false;
              const e3 = new fa(t3), n2 = this._previousRects.get(t3), o2 = !n2 || !n2.isEqual(e3);
              return this._previousRects.set(t3, e3), o2;
            }
          }
          function Aa(t3) {
            const e3 = t3.next();
            return e3.done ? null : e3.value;
          }
          he(Ca, ws);
          class _a {
            constructor() {
              this.set("isFocused", false), this.set("focusedElement", null), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null;
            }
            add(t3) {
              if (this._elements.has(t3))
                throw new a("focustracker-add-element-already-exist", this);
              this.listenTo(t3, "focus", () => this._focus(t3), { useCapture: true }), this.listenTo(t3, "blur", () => this._blur(), { useCapture: true }), this._elements.add(t3);
            }
            remove(t3) {
              t3 === this.focusedElement && this._blur(t3), this._elements.has(t3) && (this.stopListening(t3), this._elements.delete(t3));
            }
            destroy() {
              this.stopListening();
            }
            _focus(t3) {
              clearTimeout(this._nextEventLoopTimeout), this.focusedElement = t3, this.isFocused = true;
            }
            _blur() {
              clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
                this.focusedElement = null, this.isFocused = false;
              }, 0);
            }
          }
          he(_a, ws), he(_a, re);
          class va {
            constructor() {
              this._listener = Object.create(ws);
            }
            listenTo(t3) {
              this._listener.listenTo(t3, "keydown", (t4, e3) => {
                this._listener.fire("_keydown:" + ur(e3), e3);
              });
            }
            set(t3, e3, n2 = {}) {
              const o2 = gr(t3), i2 = n2.priority;
              this._listener.listenTo(this._listener, "_keydown:" + o2, (t4, n3) => {
                e3(n3, () => {
                  n3.preventDefault(), n3.stopPropagation(), t4.stop();
                }), t4.return = true;
              }, { priority: i2 });
            }
            press(t3) {
              return !!this._listener.fire("_keydown:" + ur(t3), t3);
            }
            destroy() {
              this._listener.stopListening();
            }
          }
          class ya extends _s {
            constructor(t3) {
              super(t3), this.document.on("keydown", (t4, e3) => {
                if (this.isEnabled && ((n2 = e3.keyCode) == dr.arrowright || n2 == dr.arrowleft || n2 == dr.arrowup || n2 == dr.arrowdown)) {
                  const n3 = new qi(this.document, "arrowKey", this.document.selection.getFirstRange());
                  this.document.fire(n3, e3), n3.stop.called && t4.stop();
                }
                var n2;
              });
            }
            observe() {
            }
          }
          function xa({ target: t3, viewportOffset: e3 = 0 }) {
            const n2 = Na(t3);
            let o2 = n2, i2 = null;
            for (; o2; ) {
              let r2;
              r2 = Ba(o2 == n2 ? t3 : i2), Da(r2, () => za(t3, o2));
              const s2 = za(t3, o2);
              if (Ea(o2, s2, e3), o2.parent != o2) {
                if (i2 = o2.frameElement, o2 = o2.parent, !i2)
                  return;
              } else
                o2 = null;
            }
          }
          function Ea(t3, e3, n2) {
            const o2 = e3.clone().moveBy(0, n2), i2 = e3.clone().moveBy(0, -n2), r2 = new fa(t3).excludeScrollbarsAndBorders();
            if (![i2, o2].every((t4) => r2.contains(t4))) {
              let { scrollX: s2, scrollY: a2 } = t3;
              Ma(i2, r2) ? a2 -= r2.top - e3.top + n2 : Ia(o2, r2) && (a2 += e3.bottom - r2.bottom + n2), Sa(e3, r2) ? s2 -= r2.left - e3.left + n2 : Ta(e3, r2) && (s2 += e3.right - r2.right + n2), t3.scrollTo(s2, a2);
            }
          }
          function Da(t3, e3) {
            const n2 = Na(t3);
            let o2, i2;
            for (; t3 != n2.document.body; )
              i2 = e3(), o2 = new fa(t3).excludeScrollbarsAndBorders(), o2.contains(i2) || (Ma(i2, o2) ? t3.scrollTop -= o2.top - i2.top : Ia(i2, o2) && (t3.scrollTop += i2.bottom - o2.bottom), Sa(i2, o2) ? t3.scrollLeft -= o2.left - i2.left : Ta(i2, o2) && (t3.scrollLeft += i2.right - o2.right)), t3 = t3.parentNode;
          }
          function Ia(t3, e3) {
            return t3.bottom > e3.bottom;
          }
          function Ma(t3, e3) {
            return t3.top < e3.top;
          }
          function Sa(t3, e3) {
            return t3.left < e3.left;
          }
          function Ta(t3, e3) {
            return t3.right > e3.right;
          }
          function Na(t3) {
            return ga(t3) ? t3.startContainer.ownerDocument.defaultView : t3.ownerDocument.defaultView;
          }
          function Ba(t3) {
            if (ga(t3)) {
              let e3 = t3.commonAncestorContainer;
              return Br(e3) && (e3 = e3.parentNode), e3;
            }
            return t3.parentNode;
          }
          function za(t3, e3) {
            const n2 = Na(t3), o2 = new fa(t3);
            if (n2 === e3)
              return o2;
            {
              let t4 = n2;
              for (; t4 != e3; ) {
                const e4 = t4.frameElement, n3 = new fa(e4).excludeScrollbarsAndBorders();
                o2.moveBy(n3.left, n3.top), t4 = t4.parent;
              }
            }
            return o2;
          }
          Object.assign({}, { scrollViewportToShowTarget: xa, scrollAncestorsToShowTarget: function(t3) {
            Da(Ba(t3), () => new fa(t3));
          } });
          class Pa {
            constructor(t3) {
              this.document = new Ji(t3), this.domConverter = new gs(this.document), this.domRoots = /* @__PURE__ */ new Map(), this.set("isRenderingInProgress", false), this.set("hasDomSelection", false), this._renderer = new ts(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting").to(this.document), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = false, this._postFixersInProgress = false, this._renderingDisabled = false, this._hasChangedSinceTheLastRendering = false, this._writer = new _r(this.document), this.addObserver(qs), this.addObserver(ca), this.addObserver(la), this.addObserver(Ys), this.addObserver(aa), this.addObserver(da), this.addObserver(ya), sr.isAndroid && this.addObserver(ha), this.document.on("arrowKey", Vr, { priority: "low" }), kr(this), this.on("render", () => {
                this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = false;
              }), this.listenTo(this.document.selection, "change", () => {
                this._hasChangedSinceTheLastRendering = true;
              }), this.listenTo(this.document, "change:isFocused", () => {
                this._hasChangedSinceTheLastRendering = true;
              });
            }
            attachDomRoot(t3, e3 = "main") {
              const n2 = this.document.getRoot(e3);
              n2._name = t3.tagName.toLowerCase();
              const o2 = {};
              for (const { name: e4, value: i3 } of Array.from(t3.attributes))
                o2[e4] = i3, "class" === e4 ? this._writer.addClass(i3.split(" "), n2) : this._writer.setAttribute(e4, i3, n2);
              this._initialDomRootAttributes.set(t3, o2);
              const i2 = () => {
                this._writer.setAttribute("contenteditable", !n2.isReadOnly, n2), n2.isReadOnly ? this._writer.addClass("ck-read-only", n2) : this._writer.removeClass("ck-read-only", n2);
              };
              i2(), this.domRoots.set(e3, t3), this.domConverter.bindElements(t3, n2), this._renderer.markToSync("children", n2), this._renderer.markToSync("attributes", n2), this._renderer.domDocuments.add(t3.ownerDocument), n2.on("change:children", (t4, e4) => this._renderer.markToSync("children", e4)), n2.on("change:attributes", (t4, e4) => this._renderer.markToSync("attributes", e4)), n2.on("change:text", (t4, e4) => this._renderer.markToSync("text", e4)), n2.on("change:isReadOnly", () => this.change(i2)), n2.on("change", () => {
                this._hasChangedSinceTheLastRendering = true;
              });
              for (const n3 of this._observers.values())
                n3.observe(t3, e3);
            }
            detachDomRoot(t3) {
              const e3 = this.domRoots.get(t3);
              Array.from(e3.attributes).forEach(({ name: t4 }) => e3.removeAttribute(t4));
              const n2 = this._initialDomRootAttributes.get(e3);
              for (const t4 in n2)
                e3.setAttribute(t4, n2[t4]);
              this.domRoots.delete(t3), this.domConverter.unbindDomElement(e3);
            }
            getDomRoot(t3 = "main") {
              return this.domRoots.get(t3);
            }
            addObserver(t3) {
              let e3 = this._observers.get(t3);
              if (e3)
                return e3;
              e3 = new t3(this), this._observers.set(t3, e3);
              for (const [t4, n2] of this.domRoots)
                e3.observe(n2, t4);
              return e3.enable(), e3;
            }
            getObserver(t3) {
              return this._observers.get(t3);
            }
            disableObservers() {
              for (const t3 of this._observers.values())
                t3.disable();
            }
            enableObservers() {
              for (const t3 of this._observers.values())
                t3.enable();
            }
            scrollToTheSelection() {
              const t3 = this.document.selection.getFirstRange();
              t3 && xa({ target: this.domConverter.viewRangeToDom(t3), viewportOffset: 20 });
            }
            focus() {
              if (!this.document.isFocused) {
                const t3 = this.document.selection.editableElement;
                t3 && (this.domConverter.focus(t3), this.forceRender());
              }
            }
            change(t3) {
              if (this.isRenderingInProgress || this._postFixersInProgress)
                throw new a("cannot-change-view-tree", this);
              try {
                if (this._ongoingChange)
                  return t3(this._writer);
                this._ongoingChange = true;
                const e3 = t3(this._writer);
                return this._ongoingChange = false, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = true, this.document._callPostFixers(this._writer), this._postFixersInProgress = false, this.fire("render")), e3;
              } catch (t4) {
                a.rethrowUnexpectedError(t4, this);
              }
            }
            forceRender() {
              this._hasChangedSinceTheLastRendering = true, this.change(() => {
              });
            }
            destroy() {
              for (const t3 of this._observers.values())
                t3.destroy();
              this.document.destroy(), this.stopListening();
            }
            createPositionAt(t3, e3) {
              return Ri._createAt(t3, e3);
            }
            createPositionAfter(t3) {
              return Ri._createAfter(t3);
            }
            createPositionBefore(t3) {
              return Ri._createBefore(t3);
            }
            createRange(t3, e3) {
              return new ji(t3, e3);
            }
            createRangeOn(t3) {
              return ji._createOn(t3);
            }
            createRangeIn(t3) {
              return ji._createIn(t3);
            }
            createSelection(t3, e3, n2) {
              return new Ui(t3, e3, n2);
            }
            _disableRendering(t3) {
              this._renderingDisabled = t3, 0 == t3 && this.change(() => {
              });
            }
            _render() {
              this.isRenderingInProgress = true, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = false;
            }
          }
          he(Pa, re);
          class La {
            constructor(t3) {
              this.parent = null, this._attrs = Uo(t3);
            }
            get index() {
              let t3;
              if (!this.parent)
                return null;
              if (null === (t3 = this.parent.getChildIndex(this)))
                throw new a("model-node-not-found-in-parent", this);
              return t3;
            }
            get startOffset() {
              let t3;
              if (!this.parent)
                return null;
              if (null === (t3 = this.parent.getChildStartOffset(this)))
                throw new a("model-node-not-found-in-parent", this);
              return t3;
            }
            get offsetSize() {
              return 1;
            }
            get endOffset() {
              return this.parent ? this.startOffset + this.offsetSize : null;
            }
            get nextSibling() {
              const t3 = this.index;
              return null !== t3 && this.parent.getChild(t3 + 1) || null;
            }
            get previousSibling() {
              const t3 = this.index;
              return null !== t3 && this.parent.getChild(t3 - 1) || null;
            }
            get root() {
              let t3 = this;
              for (; t3.parent; )
                t3 = t3.parent;
              return t3;
            }
            isAttached() {
              return this.root.is("rootElement");
            }
            getPath() {
              const t3 = [];
              let e3 = this;
              for (; e3.parent; )
                t3.unshift(e3.startOffset), e3 = e3.parent;
              return t3;
            }
            getAncestors(t3 = { includeSelf: false, parentFirst: false }) {
              const e3 = [];
              let n2 = t3.includeSelf ? this : this.parent;
              for (; n2; )
                e3[t3.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
              return e3;
            }
            getCommonAncestor(t3, e3 = {}) {
              const n2 = this.getAncestors(e3), o2 = t3.getAncestors(e3);
              let i2 = 0;
              for (; n2[i2] == o2[i2] && n2[i2]; )
                i2++;
              return 0 === i2 ? null : n2[i2 - 1];
            }
            isBefore(t3) {
              if (this == t3)
                return false;
              if (this.root !== t3.root)
                return false;
              const e3 = this.getPath(), n2 = t3.getPath(), o2 = Oo(e3, n2);
              switch (o2) {
                case "prefix":
                  return true;
                case "extension":
                  return false;
                default:
                  return e3[o2] < n2[o2];
              }
            }
            isAfter(t3) {
              return this != t3 && (this.root === t3.root && !this.isBefore(t3));
            }
            hasAttribute(t3) {
              return this._attrs.has(t3);
            }
            getAttribute(t3) {
              return this._attrs.get(t3);
            }
            getAttributes() {
              return this._attrs.entries();
            }
            getAttributeKeys() {
              return this._attrs.keys();
            }
            toJSON() {
              const t3 = {};
              return this._attrs.size && (t3.attributes = Array.from(this._attrs).reduce((t4, e3) => (t4[e3[0]] = e3[1], t4), {})), t3;
            }
            is(t3) {
              return "node" === t3 || "model:node" === t3;
            }
            _clone() {
              return new La(this._attrs);
            }
            _remove() {
              this.parent._removeChildren(this.index);
            }
            _setAttribute(t3, e3) {
              this._attrs.set(t3, e3);
            }
            _setAttributesTo(t3) {
              this._attrs = Uo(t3);
            }
            _removeAttribute(t3) {
              return this._attrs.delete(t3);
            }
            _clearAttributes() {
              this._attrs.clear();
            }
          }
          class Oa extends La {
            constructor(t3, e3) {
              super(e3), this._data = t3 || "";
            }
            get offsetSize() {
              return this.data.length;
            }
            get data() {
              return this._data;
            }
            is(t3) {
              return "$text" === t3 || "model:$text" === t3 || "text" === t3 || "model:text" === t3 || "node" === t3 || "model:node" === t3;
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.data = this.data, t3;
            }
            _clone() {
              return new Oa(this.data, this.getAttributes());
            }
            static fromJSON(t3) {
              return new Oa(t3.data, t3.attributes);
            }
          }
          class Ra {
            constructor(t3, e3, n2) {
              if (this.textNode = t3, e3 < 0 || e3 > t3.offsetSize)
                throw new a("model-textproxy-wrong-offsetintext", this);
              if (n2 < 0 || e3 + n2 > t3.offsetSize)
                throw new a("model-textproxy-wrong-length", this);
              this.data = t3.data.substring(e3, e3 + n2), this.offsetInText = e3;
            }
            get startOffset() {
              return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null;
            }
            get offsetSize() {
              return this.data.length;
            }
            get endOffset() {
              return null !== this.startOffset ? this.startOffset + this.offsetSize : null;
            }
            get isPartial() {
              return this.offsetSize !== this.textNode.offsetSize;
            }
            get parent() {
              return this.textNode.parent;
            }
            get root() {
              return this.textNode.root;
            }
            is(t3) {
              return "$textProxy" === t3 || "model:$textProxy" === t3 || "textProxy" === t3 || "model:textProxy" === t3;
            }
            getPath() {
              const t3 = this.textNode.getPath();
              return t3.length > 0 && (t3[t3.length - 1] += this.offsetInText), t3;
            }
            getAncestors(t3 = { includeSelf: false, parentFirst: false }) {
              const e3 = [];
              let n2 = t3.includeSelf ? this : this.parent;
              for (; n2; )
                e3[t3.parentFirst ? "push" : "unshift"](n2), n2 = n2.parent;
              return e3;
            }
            hasAttribute(t3) {
              return this.textNode.hasAttribute(t3);
            }
            getAttribute(t3) {
              return this.textNode.getAttribute(t3);
            }
            getAttributes() {
              return this.textNode.getAttributes();
            }
            getAttributeKeys() {
              return this.textNode.getAttributeKeys();
            }
          }
          class ja {
            constructor(t3) {
              this._nodes = [], t3 && this._insertNodes(0, t3);
            }
            [Symbol.iterator]() {
              return this._nodes[Symbol.iterator]();
            }
            get length() {
              return this._nodes.length;
            }
            get maxOffset() {
              return this._nodes.reduce((t3, e3) => t3 + e3.offsetSize, 0);
            }
            getNode(t3) {
              return this._nodes[t3] || null;
            }
            getNodeIndex(t3) {
              const e3 = this._nodes.indexOf(t3);
              return -1 == e3 ? null : e3;
            }
            getNodeStartOffset(t3) {
              const e3 = this.getNodeIndex(t3);
              return null === e3 ? null : this._nodes.slice(0, e3).reduce((t4, e4) => t4 + e4.offsetSize, 0);
            }
            indexToOffset(t3) {
              if (t3 == this._nodes.length)
                return this.maxOffset;
              const e3 = this._nodes[t3];
              if (!e3)
                throw new a("model-nodelist-index-out-of-bounds", this);
              return this.getNodeStartOffset(e3);
            }
            offsetToIndex(t3) {
              let e3 = 0;
              for (const n2 of this._nodes) {
                if (t3 >= e3 && t3 < e3 + n2.offsetSize)
                  return this.getNodeIndex(n2);
                e3 += n2.offsetSize;
              }
              if (e3 != t3)
                throw new a("model-nodelist-offset-out-of-bounds", this, { offset: t3, nodeList: this });
              return this.length;
            }
            _insertNodes(t3, e3) {
              for (const t4 of e3)
                if (!(t4 instanceof La))
                  throw new a("model-nodelist-insertnodes-not-node", this);
              this._nodes.splice(t3, 0, ...e3);
            }
            _removeNodes(t3, e3 = 1) {
              return this._nodes.splice(t3, e3);
            }
            toJSON() {
              return this._nodes.map((t3) => t3.toJSON());
            }
          }
          class Fa extends La {
            constructor(t3, e3, n2) {
              super(e3), this.name = t3, this._children = new ja(), n2 && this._insertChild(0, n2);
            }
            get childCount() {
              return this._children.length;
            }
            get maxOffset() {
              return this._children.maxOffset;
            }
            get isEmpty() {
              return 0 === this.childCount;
            }
            is(t3, e3 = null) {
              return e3 ? e3 === this.name && ("element" === t3 || "model:element" === t3) : "element" === t3 || "model:element" === t3 || "node" === t3 || "model:node" === t3;
            }
            getChild(t3) {
              return this._children.getNode(t3);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            getChildIndex(t3) {
              return this._children.getNodeIndex(t3);
            }
            getChildStartOffset(t3) {
              return this._children.getNodeStartOffset(t3);
            }
            offsetToIndex(t3) {
              return this._children.offsetToIndex(t3);
            }
            getNodeByPath(t3) {
              let e3 = this;
              for (const n2 of t3)
                e3 = e3.getChild(e3.offsetToIndex(n2));
              return e3;
            }
            findAncestor(t3, e3 = { includeSelf: false }) {
              let n2 = e3.includeSelf ? this : this.parent;
              for (; n2; ) {
                if (n2.name === t3)
                  return n2;
                n2 = n2.parent;
              }
              return null;
            }
            toJSON() {
              const t3 = super.toJSON();
              if (t3.name = this.name, this._children.length > 0) {
                t3.children = [];
                for (const e3 of this._children)
                  t3.children.push(e3.toJSON());
              }
              return t3;
            }
            _clone(t3 = false) {
              const e3 = t3 ? Array.from(this._children).map((t4) => t4._clone(true)) : null;
              return new Fa(this.name, this.getAttributes(), e3);
            }
            _appendChild(t3) {
              this._insertChild(this.childCount, t3);
            }
            _insertChild(t3, e3) {
              const n2 = function(t4) {
                if ("string" == typeof t4)
                  return [new Oa(t4)];
                Do(t4) || (t4 = [t4]);
                return Array.from(t4).map((t5) => "string" == typeof t5 ? new Oa(t5) : t5 instanceof Ra ? new Oa(t5.data, t5.getAttributes()) : t5);
              }(e3);
              for (const t4 of n2)
                null !== t4.parent && t4._remove(), t4.parent = this;
              this._children._insertNodes(t3, n2);
            }
            _removeChildren(t3, e3 = 1) {
              const n2 = this._children._removeNodes(t3, e3);
              for (const t4 of n2)
                t4.parent = null;
              return n2;
            }
            static fromJSON(t3) {
              let e3 = null;
              if (t3.children) {
                e3 = [];
                for (const n2 of t3.children)
                  n2.name ? e3.push(Fa.fromJSON(n2)) : e3.push(Oa.fromJSON(n2));
              }
              return new Fa(t3.name, t3.attributes, e3);
            }
          }
          class Va {
            constructor(t3 = {}) {
              if (!t3.boundaries && !t3.startPosition)
                throw new a("model-tree-walker-no-start-position", null);
              const e3 = t3.direction || "forward";
              if ("forward" != e3 && "backward" != e3)
                throw new a("model-tree-walker-unknown-direction", t3, { direction: e3 });
              this.direction = e3, this.boundaries = t3.boundaries || null, t3.startPosition ? this.position = t3.startPosition.clone() : this.position = Ha._createAt(this.boundaries["backward" == this.direction ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!t3.singleCharacters, this.shallow = !!t3.shallow, this.ignoreElementEnd = !!t3.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
            }
            [Symbol.iterator]() {
              return this;
            }
            skip(t3) {
              let e3, n2, o2, i2;
              do {
                o2 = this.position, i2 = this._visitedParent, { done: e3, value: n2 } = this.next();
              } while (!e3 && t3(n2));
              e3 || (this.position = o2, this._visitedParent = i2);
            }
            next() {
              return "forward" == this.direction ? this._next() : this._previous();
            }
            _next() {
              const t3 = this.position, e3 = this.position.clone(), n2 = this._visitedParent;
              if (null === n2.parent && e3.offset === n2.maxOffset)
                return { done: true };
              if (n2 === this._boundaryEndParent && e3.offset == this.boundaries.end.offset)
                return { done: true };
              const o2 = e3.parent, i2 = qa(e3, o2), r2 = i2 || Wa(e3, o2, i2);
              if (r2 instanceof Fa)
                return this.shallow ? e3.offset++ : (e3.path.push(0), this._visitedParent = r2), this.position = e3, Ua("elementStart", r2, t3, e3, 1);
              if (r2 instanceof Oa) {
                let o3;
                if (this.singleCharacters)
                  o3 = 1;
                else {
                  let t4 = r2.endOffset;
                  this._boundaryEndParent == n2 && this.boundaries.end.offset < t4 && (t4 = this.boundaries.end.offset), o3 = t4 - e3.offset;
                }
                const i3 = e3.offset - r2.startOffset, s2 = new Ra(r2, i3, o3);
                return e3.offset += o3, this.position = e3, Ua("text", s2, t3, e3, o3);
              }
              return e3.path.pop(), e3.offset++, this.position = e3, this._visitedParent = n2.parent, this.ignoreElementEnd ? this._next() : Ua("elementEnd", n2, t3, e3);
            }
            _previous() {
              const t3 = this.position, e3 = this.position.clone(), n2 = this._visitedParent;
              if (null === n2.parent && 0 === e3.offset)
                return { done: true };
              if (n2 == this._boundaryStartParent && e3.offset == this.boundaries.start.offset)
                return { done: true };
              const o2 = e3.parent, i2 = qa(e3, o2), r2 = i2 || Ga(e3, o2, i2);
              if (r2 instanceof Fa)
                return e3.offset--, this.shallow ? (this.position = e3, Ua("elementStart", r2, t3, e3, 1)) : (e3.path.push(r2.maxOffset), this.position = e3, this._visitedParent = r2, this.ignoreElementEnd ? this._previous() : Ua("elementEnd", r2, t3, e3));
              if (r2 instanceof Oa) {
                let o3;
                if (this.singleCharacters)
                  o3 = 1;
                else {
                  let t4 = r2.startOffset;
                  this._boundaryStartParent == n2 && this.boundaries.start.offset > t4 && (t4 = this.boundaries.start.offset), o3 = e3.offset - t4;
                }
                const i3 = e3.offset - r2.startOffset, s2 = new Ra(r2, i3 - o3, o3);
                return e3.offset -= o3, this.position = e3, Ua("text", s2, t3, e3, o3);
              }
              return e3.path.pop(), this.position = e3, this._visitedParent = n2.parent, Ua("elementStart", n2, t3, e3, 1);
            }
          }
          function Ua(t3, e3, n2, o2, i2) {
            return { done: false, value: { type: t3, item: e3, previousPosition: n2, nextPosition: o2, length: i2 } };
          }
          class Ha {
            constructor(t3, e3, n2 = "toNone") {
              if (!t3.is("element") && !t3.is("documentFragment"))
                throw new a("model-position-root-invalid", t3);
              if (!(e3 instanceof Array) || 0 === e3.length)
                throw new a("model-position-path-incorrect-format", t3, { path: e3 });
              t3.is("rootElement") ? e3 = e3.slice() : (e3 = [...t3.getPath(), ...e3], t3 = t3.root), this.root = t3, this.path = e3, this.stickiness = n2;
            }
            get offset() {
              return this.path[this.path.length - 1];
            }
            set offset(t3) {
              this.path[this.path.length - 1] = t3;
            }
            get parent() {
              let t3 = this.root;
              for (let e3 = 0; e3 < this.path.length - 1; e3++)
                if (t3 = t3.getChild(t3.offsetToIndex(this.path[e3])), !t3)
                  throw new a("model-position-path-incorrect", this, { position: this });
              if (t3.is("$text"))
                throw new a("model-position-path-incorrect", this, { position: this });
              return t3;
            }
            get index() {
              return this.parent.offsetToIndex(this.offset);
            }
            get textNode() {
              return qa(this, this.parent);
            }
            get nodeAfter() {
              const t3 = this.parent;
              return Wa(this, t3, qa(this, t3));
            }
            get nodeBefore() {
              const t3 = this.parent;
              return Ga(this, t3, qa(this, t3));
            }
            get isAtStart() {
              return 0 === this.offset;
            }
            get isAtEnd() {
              return this.offset == this.parent.maxOffset;
            }
            compareWith(t3) {
              if (this.root != t3.root)
                return "different";
              const e3 = Oo(this.path, t3.path);
              switch (e3) {
                case "same":
                  return "same";
                case "prefix":
                  return "before";
                case "extension":
                  return "after";
                default:
                  return this.path[e3] < t3.path[e3] ? "before" : "after";
              }
            }
            getLastMatchingPosition(t3, e3 = {}) {
              e3.startPosition = this;
              const n2 = new Va(e3);
              return n2.skip(t3), n2.position;
            }
            getParentPath() {
              return this.path.slice(0, -1);
            }
            getAncestors() {
              const t3 = this.parent;
              return t3.is("documentFragment") ? [t3] : t3.getAncestors({ includeSelf: true });
            }
            findAncestor(t3) {
              const e3 = this.parent;
              return e3.is("element") ? e3.findAncestor(t3, { includeSelf: true }) : null;
            }
            getCommonPath(t3) {
              if (this.root != t3.root)
                return [];
              const e3 = Oo(this.path, t3.path), n2 = "string" == typeof e3 ? Math.min(this.path.length, t3.path.length) : e3;
              return this.path.slice(0, n2);
            }
            getCommonAncestor(t3) {
              const e3 = this.getAncestors(), n2 = t3.getAncestors();
              let o2 = 0;
              for (; e3[o2] == n2[o2] && e3[o2]; )
                o2++;
              return 0 === o2 ? null : e3[o2 - 1];
            }
            getShiftedBy(t3) {
              const e3 = this.clone(), n2 = e3.offset + t3;
              return e3.offset = n2 < 0 ? 0 : n2, e3;
            }
            isAfter(t3) {
              return "after" == this.compareWith(t3);
            }
            isBefore(t3) {
              return "before" == this.compareWith(t3);
            }
            isEqual(t3) {
              return "same" == this.compareWith(t3);
            }
            isTouching(t3) {
              let e3 = null, n2 = null;
              switch (this.compareWith(t3)) {
                case "same":
                  return true;
                case "before":
                  e3 = Ha._createAt(this), n2 = Ha._createAt(t3);
                  break;
                case "after":
                  e3 = Ha._createAt(t3), n2 = Ha._createAt(this);
                  break;
                default:
                  return false;
              }
              let o2 = e3.parent;
              for (; e3.path.length + n2.path.length; ) {
                if (e3.isEqual(n2))
                  return true;
                if (e3.path.length > n2.path.length) {
                  if (e3.offset !== o2.maxOffset)
                    return false;
                  e3.path = e3.path.slice(0, -1), o2 = o2.parent, e3.offset++;
                } else {
                  if (0 !== n2.offset)
                    return false;
                  n2.path = n2.path.slice(0, -1);
                }
              }
            }
            is(t3) {
              return "position" === t3 || "model:position" === t3;
            }
            hasSameParentAs(t3) {
              if (this.root !== t3.root)
                return false;
              return "same" == Oo(this.getParentPath(), t3.getParentPath());
            }
            getTransformedByOperation(t3) {
              let e3;
              switch (t3.type) {
                case "insert":
                  e3 = this._getTransformedByInsertOperation(t3);
                  break;
                case "move":
                case "remove":
                case "reinsert":
                  e3 = this._getTransformedByMoveOperation(t3);
                  break;
                case "split":
                  e3 = this._getTransformedBySplitOperation(t3);
                  break;
                case "merge":
                  e3 = this._getTransformedByMergeOperation(t3);
                  break;
                default:
                  e3 = Ha._createAt(this);
              }
              return e3;
            }
            _getTransformedByInsertOperation(t3) {
              return this._getTransformedByInsertion(t3.position, t3.howMany);
            }
            _getTransformedByMoveOperation(t3) {
              return this._getTransformedByMove(t3.sourcePosition, t3.targetPosition, t3.howMany);
            }
            _getTransformedBySplitOperation(t3) {
              const e3 = t3.movedRange;
              return e3.containsPosition(this) || e3.start.isEqual(this) && "toNext" == this.stickiness ? this._getCombined(t3.splitPosition, t3.moveTargetPosition) : t3.graveyardPosition ? this._getTransformedByMove(t3.graveyardPosition, t3.insertionPosition, 1) : this._getTransformedByInsertion(t3.insertionPosition, 1);
            }
            _getTransformedByMergeOperation(t3) {
              const e3 = t3.movedRange;
              let n2;
              return e3.containsPosition(this) || e3.start.isEqual(this) ? (n2 = this._getCombined(t3.sourcePosition, t3.targetPosition), t3.sourcePosition.isBefore(t3.targetPosition) && (n2 = n2._getTransformedByDeletion(t3.deletionPosition, 1))) : n2 = this.isEqual(t3.deletionPosition) ? Ha._createAt(t3.deletionPosition) : this._getTransformedByMove(t3.deletionPosition, t3.graveyardPosition, 1), n2;
            }
            _getTransformedByDeletion(t3, e3) {
              const n2 = Ha._createAt(this);
              if (this.root != t3.root)
                return n2;
              if ("same" == Oo(t3.getParentPath(), this.getParentPath())) {
                if (t3.offset < this.offset) {
                  if (t3.offset + e3 > this.offset)
                    return null;
                  n2.offset -= e3;
                }
              } else if ("prefix" == Oo(t3.getParentPath(), this.getParentPath())) {
                const o2 = t3.path.length - 1;
                if (t3.offset <= this.path[o2]) {
                  if (t3.offset + e3 > this.path[o2])
                    return null;
                  n2.path[o2] -= e3;
                }
              }
              return n2;
            }
            _getTransformedByInsertion(t3, e3) {
              const n2 = Ha._createAt(this);
              if (this.root != t3.root)
                return n2;
              if ("same" == Oo(t3.getParentPath(), this.getParentPath()))
                (t3.offset < this.offset || t3.offset == this.offset && "toPrevious" != this.stickiness) && (n2.offset += e3);
              else if ("prefix" == Oo(t3.getParentPath(), this.getParentPath())) {
                const o2 = t3.path.length - 1;
                t3.offset <= this.path[o2] && (n2.path[o2] += e3);
              }
              return n2;
            }
            _getTransformedByMove(t3, e3, n2) {
              if (e3 = e3._getTransformedByDeletion(t3, n2), t3.isEqual(e3))
                return Ha._createAt(this);
              const o2 = this._getTransformedByDeletion(t3, n2);
              return null === o2 || t3.isEqual(this) && "toNext" == this.stickiness || t3.getShiftedBy(n2).isEqual(this) && "toPrevious" == this.stickiness ? this._getCombined(t3, e3) : o2._getTransformedByInsertion(e3, n2);
            }
            _getCombined(t3, e3) {
              const n2 = t3.path.length - 1, o2 = Ha._createAt(e3);
              return o2.stickiness = this.stickiness, o2.offset = o2.offset + this.path[n2] - t3.offset, o2.path = [...o2.path, ...this.path.slice(n2 + 1)], o2;
            }
            toJSON() {
              return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
            }
            clone() {
              return new this.constructor(this.root, this.path, this.stickiness);
            }
            static _createAt(t3, e3, n2 = "toNone") {
              if (t3 instanceof Ha)
                return new Ha(t3.root, t3.path, t3.stickiness);
              {
                const o2 = t3;
                if ("end" == e3)
                  e3 = o2.maxOffset;
                else {
                  if ("before" == e3)
                    return this._createBefore(o2, n2);
                  if ("after" == e3)
                    return this._createAfter(o2, n2);
                  if (0 !== e3 && !e3)
                    throw new a("model-createpositionat-offset-required", [this, t3]);
                }
                if (!o2.is("element") && !o2.is("documentFragment"))
                  throw new a("model-position-parent-incorrect", [this, t3]);
                const i2 = o2.getPath();
                return i2.push(e3), new this(o2.root, i2, n2);
              }
            }
            static _createAfter(t3, e3) {
              if (!t3.parent)
                throw new a("model-position-after-root", [this, t3], { root: t3 });
              return this._createAt(t3.parent, t3.endOffset, e3);
            }
            static _createBefore(t3, e3) {
              if (!t3.parent)
                throw new a("model-position-before-root", t3, { root: t3 });
              return this._createAt(t3.parent, t3.startOffset, e3);
            }
            static fromJSON(t3, e3) {
              if ("$graveyard" === t3.root) {
                const n2 = new Ha(e3.graveyard, t3.path);
                return n2.stickiness = t3.stickiness, n2;
              }
              if (!e3.getRoot(t3.root))
                throw new a("model-position-fromjson-no-root", e3, { rootName: t3.root });
              return new Ha(e3.getRoot(t3.root), t3.path, t3.stickiness);
            }
          }
          function qa(t3, e3) {
            const n2 = e3.getChild(e3.offsetToIndex(t3.offset));
            return n2 && n2.is("$text") && n2.startOffset < t3.offset ? n2 : null;
          }
          function Wa(t3, e3, n2) {
            return null !== n2 ? null : e3.getChild(e3.offsetToIndex(t3.offset));
          }
          function Ga(t3, e3, n2) {
            return null !== n2 ? null : e3.getChild(e3.offsetToIndex(t3.offset) - 1);
          }
          class Ya {
            constructor(t3, e3 = null) {
              this.start = Ha._createAt(t3), this.end = e3 ? Ha._createAt(e3) : Ha._createAt(t3), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
            }
            *[Symbol.iterator]() {
              yield* new Va({ boundaries: this, ignoreElementEnd: true });
            }
            get isCollapsed() {
              return this.start.isEqual(this.end);
            }
            get isFlat() {
              return "same" == Oo(this.start.getParentPath(), this.end.getParentPath());
            }
            get root() {
              return this.start.root;
            }
            containsPosition(t3) {
              return t3.isAfter(this.start) && t3.isBefore(this.end);
            }
            containsRange(t3, e3 = false) {
              t3.isCollapsed && (e3 = false);
              const n2 = this.containsPosition(t3.start) || e3 && this.start.isEqual(t3.start), o2 = this.containsPosition(t3.end) || e3 && this.end.isEqual(t3.end);
              return n2 && o2;
            }
            containsItem(t3) {
              const e3 = Ha._createBefore(t3);
              return this.containsPosition(e3) || this.start.isEqual(e3);
            }
            is(t3) {
              return "range" === t3 || "model:range" === t3;
            }
            isEqual(t3) {
              return this.start.isEqual(t3.start) && this.end.isEqual(t3.end);
            }
            isIntersecting(t3) {
              return this.start.isBefore(t3.end) && this.end.isAfter(t3.start);
            }
            getDifference(t3) {
              const e3 = [];
              return this.isIntersecting(t3) ? (this.containsPosition(t3.start) && e3.push(new Ya(this.start, t3.start)), this.containsPosition(t3.end) && e3.push(new Ya(t3.end, this.end))) : e3.push(new Ya(this.start, this.end)), e3;
            }
            getIntersection(t3) {
              if (this.isIntersecting(t3)) {
                let e3 = this.start, n2 = this.end;
                return this.containsPosition(t3.start) && (e3 = t3.start), this.containsPosition(t3.end) && (n2 = t3.end), new Ya(e3, n2);
              }
              return null;
            }
            getJoined(t3, e3 = false) {
              let n2 = this.isIntersecting(t3);
              if (n2 || (n2 = this.start.isBefore(t3.start) ? e3 ? this.end.isTouching(t3.start) : this.end.isEqual(t3.start) : e3 ? t3.end.isTouching(this.start) : t3.end.isEqual(this.start)), !n2)
                return null;
              let o2 = this.start, i2 = this.end;
              return t3.start.isBefore(o2) && (o2 = t3.start), t3.end.isAfter(i2) && (i2 = t3.end), new Ya(o2, i2);
            }
            getMinimalFlatRanges() {
              const t3 = [], e3 = this.start.getCommonPath(this.end).length, n2 = Ha._createAt(this.start);
              let o2 = n2.parent;
              for (; n2.path.length > e3 + 1; ) {
                const e4 = o2.maxOffset - n2.offset;
                0 !== e4 && t3.push(new Ya(n2, n2.getShiftedBy(e4))), n2.path = n2.path.slice(0, -1), n2.offset++, o2 = o2.parent;
              }
              for (; n2.path.length <= this.end.path.length; ) {
                const e4 = this.end.path[n2.path.length - 1], o3 = e4 - n2.offset;
                0 !== o3 && t3.push(new Ya(n2, n2.getShiftedBy(o3))), n2.offset = e4, n2.path.push(0);
              }
              return t3;
            }
            getWalker(t3 = {}) {
              return t3.boundaries = this, new Va(t3);
            }
            *getItems(t3 = {}) {
              t3.boundaries = this, t3.ignoreElementEnd = true;
              const e3 = new Va(t3);
              for (const t4 of e3)
                yield t4.item;
            }
            *getPositions(t3 = {}) {
              t3.boundaries = this;
              const e3 = new Va(t3);
              yield e3.position;
              for (const t4 of e3)
                yield t4.nextPosition;
            }
            getTransformedByOperation(t3) {
              switch (t3.type) {
                case "insert":
                  return this._getTransformedByInsertOperation(t3);
                case "move":
                case "remove":
                case "reinsert":
                  return this._getTransformedByMoveOperation(t3);
                case "split":
                  return [this._getTransformedBySplitOperation(t3)];
                case "merge":
                  return [this._getTransformedByMergeOperation(t3)];
              }
              return [new Ya(this.start, this.end)];
            }
            getTransformedByOperations(t3) {
              const e3 = [new Ya(this.start, this.end)];
              for (const n2 of t3)
                for (let t4 = 0; t4 < e3.length; t4++) {
                  const o2 = e3[t4].getTransformedByOperation(n2);
                  e3.splice(t4, 1, ...o2), t4 += o2.length - 1;
                }
              for (let t4 = 0; t4 < e3.length; t4++) {
                const n2 = e3[t4];
                for (let o2 = t4 + 1; o2 < e3.length; o2++) {
                  const t5 = e3[o2];
                  (n2.containsRange(t5) || t5.containsRange(n2) || n2.isEqual(t5)) && e3.splice(o2, 1);
                }
              }
              return e3;
            }
            getCommonAncestor() {
              return this.start.getCommonAncestor(this.end);
            }
            getContainedElement() {
              if (this.isCollapsed)
                return null;
              const t3 = this.start.nodeAfter, e3 = this.end.nodeBefore;
              return t3 && t3.is("element") && t3 === e3 ? t3 : null;
            }
            toJSON() {
              return { start: this.start.toJSON(), end: this.end.toJSON() };
            }
            clone() {
              return new this.constructor(this.start, this.end);
            }
            _getTransformedByInsertOperation(t3, e3 = false) {
              return this._getTransformedByInsertion(t3.position, t3.howMany, e3);
            }
            _getTransformedByMoveOperation(t3, e3 = false) {
              const n2 = t3.sourcePosition, o2 = t3.howMany, i2 = t3.targetPosition;
              return this._getTransformedByMove(n2, i2, o2, e3);
            }
            _getTransformedBySplitOperation(t3) {
              const e3 = this.start._getTransformedBySplitOperation(t3);
              let n2 = this.end._getTransformedBySplitOperation(t3);
              return this.end.isEqual(t3.insertionPosition) && (n2 = this.end.getShiftedBy(1)), e3.root != n2.root && (n2 = this.end.getShiftedBy(-1)), new Ya(e3, n2);
            }
            _getTransformedByMergeOperation(t3) {
              if (this.start.isEqual(t3.targetPosition) && this.end.isEqual(t3.deletionPosition))
                return new Ya(this.start);
              let e3 = this.start._getTransformedByMergeOperation(t3), n2 = this.end._getTransformedByMergeOperation(t3);
              return e3.root != n2.root && (n2 = this.end.getShiftedBy(-1)), e3.isAfter(n2) ? (t3.sourcePosition.isBefore(t3.targetPosition) ? (e3 = Ha._createAt(n2), e3.offset = 0) : (t3.deletionPosition.isEqual(e3) || (n2 = t3.deletionPosition), e3 = t3.targetPosition), new Ya(e3, n2)) : new Ya(e3, n2);
            }
            _getTransformedByInsertion(t3, e3, n2 = false) {
              if (n2 && this.containsPosition(t3))
                return [new Ya(this.start, t3), new Ya(t3.getShiftedBy(e3), this.end._getTransformedByInsertion(t3, e3))];
              {
                const n3 = new Ya(this.start, this.end);
                return n3.start = n3.start._getTransformedByInsertion(t3, e3), n3.end = n3.end._getTransformedByInsertion(t3, e3), [n3];
              }
            }
            _getTransformedByMove(t3, e3, n2, o2 = false) {
              if (this.isCollapsed) {
                const o3 = this.start._getTransformedByMove(t3, e3, n2);
                return [new Ya(o3)];
              }
              const i2 = Ya._createFromPositionAndShift(t3, n2), r2 = e3._getTransformedByDeletion(t3, n2);
              if (this.containsPosition(e3) && !o2 && (i2.containsPosition(this.start) || i2.containsPosition(this.end))) {
                const o3 = this.start._getTransformedByMove(t3, e3, n2), i3 = this.end._getTransformedByMove(t3, e3, n2);
                return [new Ya(o3, i3)];
              }
              let s2;
              const a2 = this.getDifference(i2);
              let c2 = null;
              const l2 = this.getIntersection(i2);
              if (1 == a2.length ? c2 = new Ya(a2[0].start._getTransformedByDeletion(t3, n2), a2[0].end._getTransformedByDeletion(t3, n2)) : 2 == a2.length && (c2 = new Ya(this.start, this.end._getTransformedByDeletion(t3, n2))), s2 = c2 ? c2._getTransformedByInsertion(r2, n2, null !== l2 || o2) : [], l2) {
                const t4 = new Ya(l2.start._getCombined(i2.start, r2), l2.end._getCombined(i2.start, r2));
                2 == s2.length ? s2.splice(1, 0, t4) : s2.push(t4);
              }
              return s2;
            }
            _getTransformedByDeletion(t3, e3) {
              let n2 = this.start._getTransformedByDeletion(t3, e3), o2 = this.end._getTransformedByDeletion(t3, e3);
              return null == n2 && null == o2 ? null : (null == n2 && (n2 = t3), null == o2 && (o2 = t3), new Ya(n2, o2));
            }
            static _createFromPositionAndShift(t3, e3) {
              const n2 = t3, o2 = t3.getShiftedBy(e3);
              return e3 > 0 ? new this(n2, o2) : new this(o2, n2);
            }
            static _createIn(t3) {
              return new this(Ha._createAt(t3, 0), Ha._createAt(t3, t3.maxOffset));
            }
            static _createOn(t3) {
              return this._createFromPositionAndShift(Ha._createBefore(t3), t3.offsetSize);
            }
            static _createFromRanges(t3) {
              if (0 === t3.length)
                throw new a("range-create-from-ranges-empty-array", null);
              if (1 == t3.length)
                return t3[0].clone();
              const e3 = t3[0];
              t3.sort((t4, e4) => t4.start.isAfter(e4.start) ? 1 : -1);
              const n2 = t3.indexOf(e3), o2 = new this(e3.start, e3.end);
              if (n2 > 0)
                for (let e4 = n2 - 1; t3[e4].end.isEqual(o2.start); e4++)
                  o2.start = Ha._createAt(t3[e4].start);
              for (let e4 = n2 + 1; e4 < t3.length && t3[e4].start.isEqual(o2.end); e4++)
                o2.end = Ha._createAt(t3[e4].end);
              return o2;
            }
            static fromJSON(t3, e3) {
              return new this(Ha.fromJSON(t3.start, e3), Ha.fromJSON(t3.end, e3));
            }
          }
          class Qa {
            constructor() {
              this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (t3, e3) => {
                if (e3.viewPosition)
                  return;
                const n2 = this._modelToViewMapping.get(e3.modelPosition.parent);
                if (!n2)
                  throw new a("mapping-view-position-parent-not-found", this, { modelPosition: e3.modelPosition });
                e3.viewPosition = this.findPositionIn(n2, e3.modelPosition.offset);
              }, { priority: "low" }), this.on("viewToModelPosition", (t3, e3) => {
                if (e3.modelPosition)
                  return;
                const n2 = this.findMappedViewAncestor(e3.viewPosition), o2 = this._viewToModelMapping.get(n2), i2 = this._toModelOffset(e3.viewPosition.parent, e3.viewPosition.offset, n2);
                e3.modelPosition = Ha._createAt(o2, i2);
              }, { priority: "low" });
            }
            bindElements(t3, e3) {
              this._modelToViewMapping.set(t3, e3), this._viewToModelMapping.set(e3, t3);
            }
            unbindViewElement(t3, e3 = {}) {
              const n2 = this.toModelElement(t3);
              if (this._elementToMarkerNames.has(t3))
                for (const e4 of this._elementToMarkerNames.get(t3))
                  this._unboundMarkerNames.add(e4);
              e3.defer ? this._deferredBindingRemovals.set(t3, t3.root) : (this._viewToModelMapping.delete(t3), this._modelToViewMapping.get(n2) == t3 && this._modelToViewMapping.delete(n2));
            }
            unbindModelElement(t3) {
              const e3 = this.toViewElement(t3);
              this._modelToViewMapping.delete(t3), this._viewToModelMapping.get(e3) == t3 && this._viewToModelMapping.delete(e3);
            }
            bindElementToMarker(t3, e3) {
              const n2 = this._markerNameToElements.get(e3) || /* @__PURE__ */ new Set();
              n2.add(t3);
              const o2 = this._elementToMarkerNames.get(t3) || /* @__PURE__ */ new Set();
              o2.add(e3), this._markerNameToElements.set(e3, n2), this._elementToMarkerNames.set(t3, o2);
            }
            unbindElementFromMarkerName(t3, e3) {
              const n2 = this._markerNameToElements.get(e3);
              n2 && (n2.delete(t3), 0 == n2.size && this._markerNameToElements.delete(e3));
              const o2 = this._elementToMarkerNames.get(t3);
              o2 && (o2.delete(e3), 0 == o2.size && this._elementToMarkerNames.delete(t3));
            }
            flushUnboundMarkerNames() {
              const t3 = Array.from(this._unboundMarkerNames);
              return this._unboundMarkerNames.clear(), t3;
            }
            flushDeferredBindings() {
              for (const [t3, e3] of this._deferredBindingRemovals)
                t3.root == e3 && this.unbindViewElement(t3);
              this._deferredBindingRemovals = /* @__PURE__ */ new Map();
            }
            clearBindings() {
              this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
            }
            toModelElement(t3) {
              return this._viewToModelMapping.get(t3);
            }
            toViewElement(t3) {
              return this._modelToViewMapping.get(t3);
            }
            toModelRange(t3) {
              return new Ya(this.toModelPosition(t3.start), this.toModelPosition(t3.end));
            }
            toViewRange(t3) {
              return new ji(this.toViewPosition(t3.start), this.toViewPosition(t3.end));
            }
            toModelPosition(t3) {
              const e3 = { viewPosition: t3, mapper: this };
              return this.fire("viewToModelPosition", e3), e3.modelPosition;
            }
            toViewPosition(t3, e3 = { isPhantom: false }) {
              const n2 = { modelPosition: t3, mapper: this, isPhantom: e3.isPhantom };
              return this.fire("modelToViewPosition", n2), n2.viewPosition;
            }
            markerNameToElements(t3) {
              const e3 = this._markerNameToElements.get(t3);
              if (!e3)
                return null;
              const n2 = /* @__PURE__ */ new Set();
              for (const t4 of e3)
                if (t4.is("attributeElement"))
                  for (const e4 of t4.getElementsWithSameId())
                    n2.add(e4);
                else
                  n2.add(t4);
              return n2;
            }
            registerViewToModelLength(t3, e3) {
              this._viewToModelLengthCallbacks.set(t3, e3);
            }
            findMappedViewAncestor(t3) {
              let e3 = t3.parent;
              for (; !this._viewToModelMapping.has(e3); )
                e3 = e3.parent;
              return e3;
            }
            _toModelOffset(t3, e3, n2) {
              if (n2 != t3) {
                return this._toModelOffset(t3.parent, t3.index, n2) + this._toModelOffset(t3, e3, t3);
              }
              if (t3.is("$text"))
                return e3;
              let o2 = 0;
              for (let n3 = 0; n3 < e3; n3++)
                o2 += this.getModelLength(t3.getChild(n3));
              return o2;
            }
            getModelLength(t3) {
              if (this._viewToModelLengthCallbacks.get(t3.name)) {
                return this._viewToModelLengthCallbacks.get(t3.name)(t3);
              }
              if (this._viewToModelMapping.has(t3))
                return 1;
              if (t3.is("$text"))
                return t3.data.length;
              if (t3.is("uiElement"))
                return 0;
              {
                let e3 = 0;
                for (const n2 of t3.getChildren())
                  e3 += this.getModelLength(n2);
                return e3;
              }
            }
            findPositionIn(t3, e3) {
              let n2, o2 = 0, i2 = 0, r2 = 0;
              if (t3.is("$text"))
                return new Ri(t3, e3);
              for (; i2 < e3; )
                n2 = t3.getChild(r2), o2 = this.getModelLength(n2), i2 += o2, r2++;
              return i2 == e3 ? this._moveViewPositionToTextNode(new Ri(t3, r2)) : this.findPositionIn(n2, e3 - (i2 - o2));
            }
            _moveViewPositionToTextNode(t3) {
              const e3 = t3.nodeBefore, n2 = t3.nodeAfter;
              return e3 instanceof Fo ? new Ri(e3, e3.data.length) : n2 instanceof Fo ? new Ri(n2, 0) : t3;
            }
          }
          he(Qa, f);
          class Ka {
            constructor() {
              this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
            }
            add(t3, e3) {
              e3 = $a(e3), t3 instanceof Ra && (t3 = this._getSymbolForTextProxy(t3)), this._consumable.has(t3) || this._consumable.set(t3, /* @__PURE__ */ new Map()), this._consumable.get(t3).set(e3, true);
            }
            consume(t3, e3) {
              return e3 = $a(e3), t3 instanceof Ra && (t3 = this._getSymbolForTextProxy(t3)), !!this.test(t3, e3) && (this._consumable.get(t3).set(e3, false), true);
            }
            test(t3, e3) {
              e3 = $a(e3), t3 instanceof Ra && (t3 = this._getSymbolForTextProxy(t3));
              const n2 = this._consumable.get(t3);
              if (void 0 === n2)
                return null;
              const o2 = n2.get(e3);
              return void 0 === o2 ? null : o2;
            }
            revert(t3, e3) {
              e3 = $a(e3), t3 instanceof Ra && (t3 = this._getSymbolForTextProxy(t3));
              const n2 = this.test(t3, e3);
              return false === n2 ? (this._consumable.get(t3).set(e3, true), true) : true !== n2 && null;
            }
            verifyAllConsumed(t3) {
              const e3 = [];
              for (const [n2, o2] of this._consumable)
                for (const [i2, r2] of o2) {
                  const o3 = i2.split(":")[0];
                  r2 && t3 == o3 && e3.push({ event: i2, item: n2.name || n2.description });
                }
              if (e3.length)
                throw new a("conversion-model-consumable-not-consumed", null, { items: e3 });
            }
            _getSymbolForTextProxy(t3) {
              let e3 = null;
              const n2 = this._textProxyRegistry.get(t3.startOffset);
              if (n2) {
                const o2 = n2.get(t3.endOffset);
                o2 && (e3 = o2.get(t3.parent));
              }
              return e3 || (e3 = this._addSymbolForTextProxy(t3)), e3;
            }
            _addSymbolForTextProxy(t3) {
              const e3 = t3.startOffset, n2 = t3.endOffset, o2 = t3.parent, i2 = Symbol("$textProxy:" + t3.data);
              let r2, s2;
              return r2 = this._textProxyRegistry.get(e3), r2 || (r2 = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(e3, r2)), s2 = r2.get(n2), s2 || (s2 = /* @__PURE__ */ new Map(), r2.set(n2, s2)), s2.set(o2, i2), i2;
            }
          }
          function $a(t3) {
            const e3 = t3.split(":");
            return "insert" == e3[0] ? e3[0] : "addMarker" == e3[0] || "removeMarker" == e3[0] ? t3 : e3.length > 1 ? e3[0] + ":" + e3[1] : e3[0];
          }
          class Za {
            constructor(t3) {
              this._conversionApi = { dispatcher: this, ...t3 }, this._firedEventsMap = /* @__PURE__ */ new WeakMap();
            }
            convertChanges(t3, e3, n2) {
              const o2 = this._createConversionApi(n2, t3.getRefreshedItems());
              for (const e4 of t3.getMarkersToRemove())
                this._convertMarkerRemove(e4.name, e4.range, o2);
              const i2 = this._reduceChanges(t3.getChanges());
              for (const t4 of i2)
                "insert" === t4.type ? this._convertInsert(Ya._createFromPositionAndShift(t4.position, t4.length), o2) : "reinsert" === t4.type ? this._convertReinsert(Ya._createFromPositionAndShift(t4.position, t4.length), o2) : "remove" === t4.type ? this._convertRemove(t4.position, t4.length, t4.name, o2) : this._convertAttribute(t4.range, t4.attributeKey, t4.attributeOldValue, t4.attributeNewValue, o2);
              for (const t4 of o2.mapper.flushUnboundMarkerNames()) {
                const n3 = e3.get(t4).getRange();
                this._convertMarkerRemove(t4, n3, o2), this._convertMarkerAdd(t4, n3, o2);
              }
              for (const e4 of t3.getMarkersToAdd())
                this._convertMarkerAdd(e4.name, e4.range, o2);
              o2.mapper.flushDeferredBindings(), o2.consumable.verifyAllConsumed("insert");
            }
            convert(t3, e3, n2, o2 = {}) {
              const i2 = this._createConversionApi(n2, void 0, o2);
              this._convertInsert(t3, i2);
              for (const [t4, n3] of e3)
                this._convertMarkerAdd(t4, n3, i2);
              i2.consumable.verifyAllConsumed("insert");
            }
            convertSelection(t3, e3, n2) {
              const o2 = Array.from(e3.getMarkersAtPosition(t3.getFirstPosition())), i2 = this._createConversionApi(n2);
              if (this._addConsumablesForSelection(i2.consumable, t3, o2), this.fire("selection", { selection: t3 }, i2), t3.isCollapsed) {
                for (const e4 of o2) {
                  const n3 = e4.getRange();
                  if (!Ja(t3.getFirstPosition(), e4, i2.mapper))
                    continue;
                  const o3 = { item: t3, markerName: e4.name, markerRange: n3 };
                  i2.consumable.test(t3, "addMarker:" + e4.name) && this.fire("addMarker:" + e4.name, o3, i2);
                }
                for (const e4 of t3.getAttributeKeys()) {
                  const n3 = { item: t3, range: t3.getFirstRange(), attributeKey: e4, attributeOldValue: null, attributeNewValue: t3.getAttribute(e4) };
                  i2.consumable.test(t3, "attribute:" + n3.attributeKey) && this.fire("attribute:" + n3.attributeKey + ":$text", n3, i2);
                }
              }
            }
            _convertInsert(t3, e3, n2 = {}) {
              n2.doNotAddConsumables || this._addConsumablesForInsert(e3.consumable, Array.from(t3));
              for (const n3 of Array.from(t3.getWalker({ shallow: true })).map(Xa))
                this._testAndFire("insert", n3, e3);
            }
            _convertRemove(t3, e3, n2, o2) {
              this.fire("remove:" + n2, { position: t3, length: e3 }, o2);
            }
            _convertAttribute(t3, e3, n2, o2, i2) {
              this._addConsumablesForRange(i2.consumable, t3, `attribute:${e3}`);
              for (const r2 of t3) {
                const t4 = { item: r2.item, range: Ya._createFromPositionAndShift(r2.previousPosition, r2.length), attributeKey: e3, attributeOldValue: n2, attributeNewValue: o2 };
                this._testAndFire(`attribute:${e3}`, t4, i2);
              }
            }
            _convertReinsert(t3, e3) {
              const n2 = Array.from(t3.getWalker({ shallow: true }));
              this._addConsumablesForInsert(e3.consumable, n2);
              for (const t4 of n2.map(Xa))
                this._testAndFire("insert", { ...t4, reconversion: true }, e3);
            }
            _convertMarkerAdd(t3, e3, n2) {
              if ("$graveyard" == e3.root.rootName)
                return;
              const o2 = "addMarker:" + t3;
              if (n2.consumable.add(e3, o2), this.fire(o2, { markerName: t3, markerRange: e3 }, n2), n2.consumable.consume(e3, o2)) {
                this._addConsumablesForRange(n2.consumable, e3, o2);
                for (const i2 of e3.getItems()) {
                  if (!n2.consumable.test(i2, o2))
                    continue;
                  const r2 = { item: i2, range: Ya._createOn(i2), markerName: t3, markerRange: e3 };
                  this.fire(o2, r2, n2);
                }
              }
            }
            _convertMarkerRemove(t3, e3, n2) {
              "$graveyard" != e3.root.rootName && this.fire("removeMarker:" + t3, { markerName: t3, markerRange: e3 }, n2);
            }
            _reduceChanges(t3) {
              const e3 = { changes: t3 };
              return this.fire("reduceChanges", e3), e3.changes;
            }
            _addConsumablesForInsert(t3, e3) {
              for (const n2 of e3) {
                const e4 = n2.item;
                if (null === t3.test(e4, "insert")) {
                  t3.add(e4, "insert");
                  for (const n3 of e4.getAttributeKeys())
                    t3.add(e4, "attribute:" + n3);
                }
              }
              return t3;
            }
            _addConsumablesForRange(t3, e3, n2) {
              for (const o2 of e3.getItems())
                t3.add(o2, n2);
              return t3;
            }
            _addConsumablesForSelection(t3, e3, n2) {
              t3.add(e3, "selection");
              for (const o2 of n2)
                t3.add(e3, "addMarker:" + o2.name);
              for (const n3 of e3.getAttributeKeys())
                t3.add(e3, "attribute:" + n3);
              return t3;
            }
            _testAndFire(t3, e3, n2) {
              const o2 = function(t4, e4) {
                const n3 = e4.item.name || "$text";
                return `${t4}:${n3}`;
              }(t3, e3), i2 = e3.item.is("$textProxy") ? n2.consumable._getSymbolForTextProxy(e3.item) : e3.item, r2 = this._firedEventsMap.get(n2), s2 = r2.get(i2);
              if (s2) {
                if (s2.has(o2))
                  return;
                s2.add(o2);
              } else
                r2.set(i2, /* @__PURE__ */ new Set([o2]));
              this.fire(o2, e3, n2);
            }
            _testAndFireAddAttributes(t3, e3) {
              const n2 = { item: t3, range: Ya._createOn(t3) };
              for (const t4 of n2.item.getAttributeKeys())
                n2.attributeKey = t4, n2.attributeOldValue = null, n2.attributeNewValue = n2.item.getAttribute(t4), this._testAndFire(`attribute:${t4}`, n2, e3);
            }
            _createConversionApi(t3, e3 = /* @__PURE__ */ new Set(), n2 = {}) {
              const o2 = { ...this._conversionApi, consumable: new Ka(), writer: t3, options: n2, convertItem: (t4) => this._convertInsert(Ya._createOn(t4), o2), convertChildren: (t4) => this._convertInsert(Ya._createIn(t4), o2, { doNotAddConsumables: true }), convertAttributes: (t4) => this._testAndFireAddAttributes(t4, o2), canReuseView: (t4) => !e3.has(o2.mapper.toModelElement(t4)) };
              return this._firedEventsMap.set(o2, /* @__PURE__ */ new Map()), o2;
            }
          }
          function Ja(t3, e3, n2) {
            const o2 = e3.getRange(), i2 = Array.from(t3.getAncestors());
            i2.shift(), i2.reverse();
            return !i2.some((t4) => {
              if (o2.containsItem(t4)) {
                return !!n2.toViewElement(t4).getCustomProperty("addHighlight");
              }
            });
          }
          function Xa(t3) {
            return { item: t3.item, range: Ya._createFromPositionAndShift(t3.previousPosition, t3.length) };
          }
          he(Za, f);
          class tc {
            constructor(t3, e3, n2) {
              this._lastRangeBackward = false, this._ranges = [], this._attrs = /* @__PURE__ */ new Map(), t3 && this.setTo(t3, e3, n2);
            }
            get anchor() {
              if (this._ranges.length > 0) {
                const t3 = this._ranges[this._ranges.length - 1];
                return this._lastRangeBackward ? t3.end : t3.start;
              }
              return null;
            }
            get focus() {
              if (this._ranges.length > 0) {
                const t3 = this._ranges[this._ranges.length - 1];
                return this._lastRangeBackward ? t3.start : t3.end;
              }
              return null;
            }
            get isCollapsed() {
              return 1 === this._ranges.length && this._ranges[0].isCollapsed;
            }
            get rangeCount() {
              return this._ranges.length;
            }
            get isBackward() {
              return !this.isCollapsed && this._lastRangeBackward;
            }
            isEqual(t3) {
              if (this.rangeCount != t3.rangeCount)
                return false;
              if (0 === this.rangeCount)
                return true;
              if (!this.anchor.isEqual(t3.anchor) || !this.focus.isEqual(t3.focus))
                return false;
              for (const e3 of this._ranges) {
                let n2 = false;
                for (const o2 of t3._ranges)
                  if (e3.isEqual(o2)) {
                    n2 = true;
                    break;
                  }
                if (!n2)
                  return false;
              }
              return true;
            }
            *getRanges() {
              for (const t3 of this._ranges)
                yield new Ya(t3.start, t3.end);
            }
            getFirstRange() {
              let t3 = null;
              for (const e3 of this._ranges)
                t3 && !e3.start.isBefore(t3.start) || (t3 = e3);
              return t3 ? new Ya(t3.start, t3.end) : null;
            }
            getLastRange() {
              let t3 = null;
              for (const e3 of this._ranges)
                t3 && !e3.end.isAfter(t3.end) || (t3 = e3);
              return t3 ? new Ya(t3.start, t3.end) : null;
            }
            getFirstPosition() {
              const t3 = this.getFirstRange();
              return t3 ? t3.start.clone() : null;
            }
            getLastPosition() {
              const t3 = this.getLastRange();
              return t3 ? t3.end.clone() : null;
            }
            setTo(t3, e3, n2) {
              if (null === t3)
                this._setRanges([]);
              else if (t3 instanceof tc)
                this._setRanges(t3.getRanges(), t3.isBackward);
              else if (t3 && "function" == typeof t3.getRanges)
                this._setRanges(t3.getRanges(), t3.isBackward);
              else if (t3 instanceof Ya)
                this._setRanges([t3], !!e3 && !!e3.backward);
              else if (t3 instanceof Ha)
                this._setRanges([new Ya(t3)]);
              else if (t3 instanceof La) {
                const o2 = !!n2 && !!n2.backward;
                let i2;
                if ("in" == e3)
                  i2 = Ya._createIn(t3);
                else if ("on" == e3)
                  i2 = Ya._createOn(t3);
                else {
                  if (void 0 === e3)
                    throw new a("model-selection-setto-required-second-parameter", [this, t3]);
                  i2 = new Ya(Ha._createAt(t3, e3));
                }
                this._setRanges([i2], o2);
              } else {
                if (!Do(t3))
                  throw new a("model-selection-setto-not-selectable", [this, t3]);
                this._setRanges(t3, e3 && !!e3.backward);
              }
            }
            _setRanges(t3, e3 = false) {
              const n2 = (t3 = Array.from(t3)).some((e4) => {
                if (!(e4 instanceof Ya))
                  throw new a("model-selection-set-ranges-not-range", [this, t3]);
                return this._ranges.every((t4) => !t4.isEqual(e4));
              });
              if (t3.length !== this._ranges.length || n2) {
                this._removeAllRanges();
                for (const e4 of t3)
                  this._pushRange(e4);
                this._lastRangeBackward = !!e3, this.fire("change:range", { directChange: true });
              }
            }
            setFocus(t3, e3) {
              if (null === this.anchor)
                throw new a("model-selection-setfocus-no-ranges", [this, t3]);
              const n2 = Ha._createAt(t3, e3);
              if ("same" == n2.compareWith(this.focus))
                return;
              const o2 = this.anchor;
              this._ranges.length && this._popRange(), "before" == n2.compareWith(o2) ? (this._pushRange(new Ya(n2, o2)), this._lastRangeBackward = true) : (this._pushRange(new Ya(o2, n2)), this._lastRangeBackward = false), this.fire("change:range", { directChange: true });
            }
            getAttribute(t3) {
              return this._attrs.get(t3);
            }
            getAttributes() {
              return this._attrs.entries();
            }
            getAttributeKeys() {
              return this._attrs.keys();
            }
            hasAttribute(t3) {
              return this._attrs.has(t3);
            }
            removeAttribute(t3) {
              this.hasAttribute(t3) && (this._attrs.delete(t3), this.fire("change:attribute", { attributeKeys: [t3], directChange: true }));
            }
            setAttribute(t3, e3) {
              this.getAttribute(t3) !== e3 && (this._attrs.set(t3, e3), this.fire("change:attribute", { attributeKeys: [t3], directChange: true }));
            }
            getSelectedElement() {
              return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
            }
            is(t3) {
              return "selection" === t3 || "model:selection" === t3;
            }
            *getSelectedBlocks() {
              const t3 = /* @__PURE__ */ new WeakSet();
              for (const e3 of this.getRanges()) {
                const n2 = oc(e3.start, t3);
                n2 && ic(n2, e3) && (yield n2);
                for (const n3 of e3.getWalker()) {
                  const o3 = n3.item;
                  "elementEnd" == n3.type && nc(o3, t3, e3) && (yield o3);
                }
                const o2 = oc(e3.end, t3);
                o2 && !e3.end.isTouching(Ha._createAt(o2, 0)) && ic(o2, e3) && (yield o2);
              }
            }
            containsEntireContent(t3 = this.anchor.root) {
              const e3 = Ha._createAt(t3, 0), n2 = Ha._createAt(t3, "end");
              return e3.isTouching(this.getFirstPosition()) && n2.isTouching(this.getLastPosition());
            }
            _pushRange(t3) {
              this._checkRange(t3), this._ranges.push(new Ya(t3.start, t3.end));
            }
            _checkRange(t3) {
              for (let e3 = 0; e3 < this._ranges.length; e3++)
                if (t3.isIntersecting(this._ranges[e3]))
                  throw new a("model-selection-range-intersects", [this, t3], { addedRange: t3, intersectingRange: this._ranges[e3] });
            }
            _removeAllRanges() {
              for (; this._ranges.length > 0; )
                this._popRange();
            }
            _popRange() {
              this._ranges.pop();
            }
          }
          function ec(t3, e3) {
            return !e3.has(t3) && (e3.add(t3), t3.root.document.model.schema.isBlock(t3) && t3.parent);
          }
          function nc(t3, e3, n2) {
            return ec(t3, e3) && ic(t3, n2);
          }
          function oc(t3, e3) {
            const n2 = t3.parent.root.document.model.schema, o2 = t3.parent.getAncestors({ parentFirst: true, includeSelf: true });
            let i2 = false;
            const r2 = o2.find((t4) => !i2 && (i2 = n2.isLimit(t4), !i2 && ec(t4, e3)));
            return o2.forEach((t4) => e3.add(t4)), r2;
          }
          function ic(t3, e3) {
            const n2 = function(t4) {
              const e4 = t4.root.document.model.schema;
              let n3 = t4.parent;
              for (; n3; ) {
                if (e4.isBlock(n3))
                  return n3;
                n3 = n3.parent;
              }
            }(t3);
            if (!n2)
              return true;
            return !e3.containsRange(Ya._createOn(n2), true);
          }
          he(tc, f);
          class rc extends Ya {
            constructor(t3, e3) {
              super(t3, e3), sc.call(this);
            }
            detach() {
              this.stopListening();
            }
            is(t3) {
              return "liveRange" === t3 || "model:liveRange" === t3 || "range" == t3 || "model:range" === t3;
            }
            toRange() {
              return new Ya(this.start, this.end);
            }
            static fromRange(t3) {
              return new rc(t3.start, t3.end);
            }
          }
          function sc() {
            this.listenTo(this.root.document.model, "applyOperation", (t3, e3) => {
              const n2 = e3[0];
              n2.isDocumentOperation && ac.call(this, n2);
            }, { priority: "low" });
          }
          function ac(t3) {
            const e3 = this.getTransformedByOperation(t3), n2 = Ya._createFromRanges(e3), o2 = !n2.isEqual(this), i2 = function(t4, e4) {
              switch (e4.type) {
                case "insert":
                  return t4.containsPosition(e4.position);
                case "move":
                case "remove":
                case "reinsert":
                case "merge":
                  return t4.containsPosition(e4.sourcePosition) || t4.start.isEqual(e4.sourcePosition) || t4.containsPosition(e4.targetPosition);
                case "split":
                  return t4.containsPosition(e4.splitPosition) || t4.containsPosition(e4.insertionPosition);
              }
              return false;
            }(this, t3);
            let r2 = null;
            if (o2) {
              "$graveyard" == n2.root.rootName && (r2 = "remove" == t3.type ? t3.sourcePosition : t3.deletionPosition);
              const e4 = this.toRange();
              this.start = n2.start, this.end = n2.end, this.fire("change:range", e4, { deletionPosition: r2 });
            } else
              i2 && this.fire("change:content", this.toRange(), { deletionPosition: r2 });
          }
          he(rc, f);
          const cc = "selection:";
          class lc {
            constructor(t3) {
              this._selection = new dc(t3), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
            }
            get isCollapsed() {
              return this._selection.isCollapsed;
            }
            get anchor() {
              return this._selection.anchor;
            }
            get focus() {
              return this._selection.focus;
            }
            get rangeCount() {
              return this._selection.rangeCount;
            }
            get hasOwnRange() {
              return this._selection.hasOwnRange;
            }
            get isBackward() {
              return this._selection.isBackward;
            }
            get isGravityOverridden() {
              return this._selection.isGravityOverridden;
            }
            get markers() {
              return this._selection.markers;
            }
            get _ranges() {
              return this._selection._ranges;
            }
            getRanges() {
              return this._selection.getRanges();
            }
            getFirstPosition() {
              return this._selection.getFirstPosition();
            }
            getLastPosition() {
              return this._selection.getLastPosition();
            }
            getFirstRange() {
              return this._selection.getFirstRange();
            }
            getLastRange() {
              return this._selection.getLastRange();
            }
            getSelectedBlocks() {
              return this._selection.getSelectedBlocks();
            }
            getSelectedElement() {
              return this._selection.getSelectedElement();
            }
            containsEntireContent(t3) {
              return this._selection.containsEntireContent(t3);
            }
            destroy() {
              this._selection.destroy();
            }
            getAttributeKeys() {
              return this._selection.getAttributeKeys();
            }
            getAttributes() {
              return this._selection.getAttributes();
            }
            getAttribute(t3) {
              return this._selection.getAttribute(t3);
            }
            hasAttribute(t3) {
              return this._selection.hasAttribute(t3);
            }
            refresh() {
              this._selection._updateMarkers(), this._selection._updateAttributes(false);
            }
            observeMarkers(t3) {
              this._selection.observeMarkers(t3);
            }
            is(t3) {
              return "selection" === t3 || "model:selection" == t3 || "documentSelection" == t3 || "model:documentSelection" == t3;
            }
            _setFocus(t3, e3) {
              this._selection.setFocus(t3, e3);
            }
            _setTo(t3, e3, n2) {
              this._selection.setTo(t3, e3, n2);
            }
            _setAttribute(t3, e3) {
              this._selection.setAttribute(t3, e3);
            }
            _removeAttribute(t3) {
              this._selection.removeAttribute(t3);
            }
            _getStoredAttributes() {
              return this._selection._getStoredAttributes();
            }
            _overrideGravity() {
              return this._selection.overrideGravity();
            }
            _restoreGravity(t3) {
              this._selection.restoreGravity(t3);
            }
            static _getStoreAttributeKey(t3) {
              return cc + t3;
            }
            static _isStoreAttributeKey(t3) {
              return t3.startsWith(cc);
            }
          }
          he(lc, f);
          class dc extends tc {
            constructor(t3) {
              super(), this.markers = new Io({ idProperty: "name" }), this._model = t3.model, this._document = t3, this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = false, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this.listenTo(this._model, "applyOperation", (t4, e3) => {
                const n2 = e3[0];
                n2.isDocumentOperation && "marker" != n2.type && "rename" != n2.type && "noop" != n2.type && (0 == this._ranges.length && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = false, this.fire("change:range", { directChange: false })));
              }, { priority: "lowest" }), this.on("change:range", () => {
                for (const t4 of this.getRanges())
                  if (!this._document._validateSelectionRange(t4))
                    throw new a("document-selection-wrong-position", this, { range: t4 });
              }), this.listenTo(this._model.markers, "update", (t4, e3, n2, o2) => {
                this._updateMarker(e3, o2);
              }), this.listenTo(this._document, "change", (t4, e3) => {
                !function(t5, e4) {
                  const n2 = t5.document.differ;
                  for (const o2 of n2.getChanges()) {
                    if ("insert" != o2.type)
                      continue;
                    const n3 = o2.position.parent;
                    o2.length === n3.maxOffset && t5.enqueueChange(e4, (t6) => {
                      const e5 = Array.from(n3.getAttributeKeys()).filter((t7) => t7.startsWith(cc));
                      for (const o3 of e5)
                        t6.removeAttribute(o3, n3);
                    });
                  }
                }(this._model, e3);
              });
            }
            get isCollapsed() {
              return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
            }
            get anchor() {
              return super.anchor || this._document._getDefaultRange().start;
            }
            get focus() {
              return super.focus || this._document._getDefaultRange().end;
            }
            get rangeCount() {
              return this._ranges.length ? this._ranges.length : 1;
            }
            get hasOwnRange() {
              return this._ranges.length > 0;
            }
            get isGravityOverridden() {
              return !!this._overriddenGravityRegister.size;
            }
            destroy() {
              for (let t3 = 0; t3 < this._ranges.length; t3++)
                this._ranges[t3].detach();
              this.stopListening();
            }
            *getRanges() {
              this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
            }
            getFirstRange() {
              return super.getFirstRange() || this._document._getDefaultRange();
            }
            getLastRange() {
              return super.getLastRange() || this._document._getDefaultRange();
            }
            setTo(t3, e3, n2) {
              super.setTo(t3, e3, n2), this._updateAttributes(true), this._updateMarkers();
            }
            setFocus(t3, e3) {
              super.setFocus(t3, e3), this._updateAttributes(true), this._updateMarkers();
            }
            setAttribute(t3, e3) {
              if (this._setAttribute(t3, e3)) {
                const e4 = [t3];
                this.fire("change:attribute", { attributeKeys: e4, directChange: true });
              }
            }
            removeAttribute(t3) {
              if (this._removeAttribute(t3)) {
                const e3 = [t3];
                this.fire("change:attribute", { attributeKeys: e3, directChange: true });
              }
            }
            overrideGravity() {
              const t3 = r();
              return this._overriddenGravityRegister.add(t3), 1 === this._overriddenGravityRegister.size && this._updateAttributes(true), t3;
            }
            restoreGravity(t3) {
              if (!this._overriddenGravityRegister.has(t3))
                throw new a("document-selection-gravity-wrong-restore", this, { uid: t3 });
              this._overriddenGravityRegister.delete(t3), this.isGravityOverridden || this._updateAttributes(true);
            }
            observeMarkers(t3) {
              this._observedMarkers.add(t3), this._updateMarkers();
            }
            _popRange() {
              this._ranges.pop().detach();
            }
            _pushRange(t3) {
              const e3 = this._prepareRange(t3);
              e3 && this._ranges.push(e3);
            }
            _prepareRange(t3) {
              if (this._checkRange(t3), t3.root == this._document.graveyard)
                return;
              const e3 = rc.fromRange(t3);
              return e3.on("change:range", (t4, n2, o2) => {
                if (this._hasChangedRange = true, e3.root == this._document.graveyard) {
                  this._selectionRestorePosition = o2.deletionPosition;
                  const t5 = this._ranges.indexOf(e3);
                  this._ranges.splice(t5, 1), e3.detach();
                }
              }), e3;
            }
            _updateMarkers() {
              if (!this._observedMarkers.size)
                return;
              const t3 = [];
              let e3 = false;
              for (const e4 of this._model.markers) {
                const n3 = e4.name.split(":", 1)[0];
                if (!this._observedMarkers.has(n3))
                  continue;
                const o2 = e4.getRange();
                for (const n4 of this.getRanges())
                  o2.containsRange(n4, !n4.isCollapsed) && t3.push(e4);
              }
              const n2 = Array.from(this.markers);
              for (const n3 of t3)
                this.markers.has(n3) || (this.markers.add(n3), e3 = true);
              for (const n3 of Array.from(this.markers))
                t3.includes(n3) || (this.markers.remove(n3), e3 = true);
              e3 && this.fire("change:marker", { oldMarkers: n2, directChange: false });
            }
            _updateMarker(t3, e3) {
              const n2 = t3.name.split(":", 1)[0];
              if (!this._observedMarkers.has(n2))
                return;
              let o2 = false;
              const i2 = Array.from(this.markers), r2 = this.markers.has(t3);
              if (e3) {
                let n3 = false;
                for (const t4 of this.getRanges())
                  if (e3.containsRange(t4, !t4.isCollapsed)) {
                    n3 = true;
                    break;
                  }
                n3 && !r2 ? (this.markers.add(t3), o2 = true) : !n3 && r2 && (this.markers.remove(t3), o2 = true);
              } else
                r2 && (this.markers.remove(t3), o2 = true);
              o2 && this.fire("change:marker", { oldMarkers: i2, directChange: false });
            }
            _updateAttributes(t3) {
              const e3 = Uo(this._getSurroundingAttributes()), n2 = Uo(this.getAttributes());
              if (t3)
                this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
              else
                for (const [t4, e4] of this._attributePriority)
                  "low" == e4 && (this._attrs.delete(t4), this._attributePriority.delete(t4));
              this._setAttributesTo(e3);
              const o2 = [];
              for (const [t4, e4] of this.getAttributes())
                n2.has(t4) && n2.get(t4) === e4 || o2.push(t4);
              for (const [t4] of n2)
                this.hasAttribute(t4) || o2.push(t4);
              o2.length > 0 && this.fire("change:attribute", { attributeKeys: o2, directChange: false });
            }
            _setAttribute(t3, e3, n2 = true) {
              const o2 = n2 ? "normal" : "low";
              if ("low" == o2 && "normal" == this._attributePriority.get(t3))
                return false;
              return super.getAttribute(t3) !== e3 && (this._attrs.set(t3, e3), this._attributePriority.set(t3, o2), true);
            }
            _removeAttribute(t3, e3 = true) {
              const n2 = e3 ? "normal" : "low";
              return ("low" != n2 || "normal" != this._attributePriority.get(t3)) && (this._attributePriority.set(t3, n2), !!super.hasAttribute(t3) && (this._attrs.delete(t3), true));
            }
            _setAttributesTo(t3) {
              const e3 = /* @__PURE__ */ new Set();
              for (const [e4, n2] of this.getAttributes())
                t3.get(e4) !== n2 && this._removeAttribute(e4, false);
              for (const [n2, o2] of t3) {
                this._setAttribute(n2, o2, false) && e3.add(n2);
              }
              return e3;
            }
            *_getStoredAttributes() {
              const t3 = this.getFirstPosition().parent;
              if (this.isCollapsed && t3.isEmpty) {
                for (const e3 of t3.getAttributeKeys())
                  if (e3.startsWith(cc)) {
                    const n2 = e3.substr(cc.length);
                    yield [n2, t3.getAttribute(e3)];
                  }
              }
            }
            _getSurroundingAttributes() {
              const t3 = this.getFirstPosition(), e3 = this._model.schema;
              let n2 = null;
              if (this.isCollapsed) {
                const o2 = t3.textNode ? t3.textNode : t3.nodeBefore, i2 = t3.textNode ? t3.textNode : t3.nodeAfter;
                if (this.isGravityOverridden || (n2 = hc(o2)), n2 || (n2 = hc(i2)), !this.isGravityOverridden && !n2) {
                  let t4 = o2;
                  for (; t4 && !e3.isInline(t4) && !n2; )
                    t4 = t4.previousSibling, n2 = hc(t4);
                }
                if (!n2) {
                  let t4 = i2;
                  for (; t4 && !e3.isInline(t4) && !n2; )
                    t4 = t4.nextSibling, n2 = hc(t4);
                }
                n2 || (n2 = this._getStoredAttributes());
              } else {
                const t4 = this.getFirstRange();
                for (const o2 of t4) {
                  if (o2.item.is("element") && e3.isObject(o2.item))
                    break;
                  if ("text" == o2.type) {
                    n2 = o2.item.getAttributes();
                    break;
                  }
                }
              }
              return n2;
            }
            _fixGraveyardSelection(t3) {
              const e3 = this._model.schema.getNearestSelectionRange(t3);
              e3 && this._pushRange(e3);
            }
          }
          function hc(t3) {
            return t3 instanceof Ra || t3 instanceof Oa ? t3.getAttributes() : null;
          }
          class uc {
            constructor(t3) {
              this._dispatchers = t3;
            }
            add(t3) {
              for (const e3 of this._dispatchers)
                t3(e3);
              return this;
            }
          }
          const gc = function(t3) {
            return Ao(t3, 5);
          };
          class mc extends uc {
            elementToElement(t3) {
              return this.add(function(t4) {
                (t4 = gc(t4)).model = kc(t4.model), t4.view = bc(t4.view, "container"), t4.model.attributes.length && (t4.model.children = true);
                return (e3) => {
                  e3.on("insert:" + t4.model.name, function(t5, e4 = Ec) {
                    return (n2, o2, i2) => {
                      if (!e4(o2.item, i2.consumable, { preflight: true }))
                        return;
                      const r2 = t5(o2.item, i2);
                      if (!r2)
                        return;
                      e4(o2.item, i2.consumable);
                      const s2 = i2.mapper.toViewPosition(o2.range.start);
                      i2.mapper.bindElements(o2.item, r2), i2.writer.insert(s2, r2), i2.convertAttributes(o2.item), yc(r2, o2.item.getChildren(), i2, { reconversion: o2.reconversion });
                    };
                  }(t4.view, vc(t4.model)), { priority: t4.converterPriority || "normal" }), (t4.model.children || t4.model.attributes.length) && e3.on("reduceChanges", _c(t4.model), { priority: "low" });
                };
              }(t3));
            }
            elementToStructure(t3) {
              return this.add(function(t4) {
                return (t4 = gc(t4)).model = kc(t4.model), t4.view = bc(t4.view, "container"), t4.model.children = true, (e3) => {
                  if (e3._conversionApi.schema.checkChild(t4.model.name, "$text"))
                    throw new a("conversion-element-to-structure-disallowed-text", e3, { elementName: t4.model.name });
                  var n2, o2;
                  e3.on("insert:" + t4.model.name, (n2 = t4.view, o2 = vc(t4.model), (t5, e4, i2) => {
                    if (!o2(e4.item, i2.consumable, { preflight: true }))
                      return;
                    const r2 = /* @__PURE__ */ new Map();
                    i2.writer._registerSlotFactory(function(t6, e5, n3) {
                      return (o3, i3 = "children") => {
                        const r3 = o3.createContainerElement("$slot");
                        let s3 = null;
                        if ("children" === i3)
                          s3 = Array.from(t6.getChildren());
                        else {
                          if ("function" != typeof i3)
                            throw new a("conversion-slot-mode-unknown", n3.dispatcher, { modeOrFilter: i3 });
                          s3 = Array.from(t6.getChildren()).filter((t7) => i3(t7));
                        }
                        return e5.set(r3, s3), r3;
                      };
                    }(e4.item, r2, i2));
                    const s2 = n2(e4.item, i2);
                    if (i2.writer._clearSlotFactory(), !s2)
                      return;
                    !function(t6, e5, n3) {
                      const o3 = Array.from(e5.values()).flat(), i3 = new Set(o3);
                      if (i3.size != o3.length)
                        throw new a("conversion-slot-filter-overlap", n3.dispatcher, { element: t6 });
                      if (i3.size != t6.childCount)
                        throw new a("conversion-slot-filter-incomplete", n3.dispatcher, { element: t6 });
                    }(e4.item, r2, i2), o2(e4.item, i2.consumable);
                    const c2 = i2.mapper.toViewPosition(e4.range.start);
                    i2.mapper.bindElements(e4.item, s2), i2.writer.insert(c2, s2), i2.convertAttributes(e4.item), function(t6, e5, n3, o3) {
                      n3.mapper.on("modelToViewPosition", s3, { priority: "highest" });
                      let i3 = null, r3 = null;
                      for ([i3, r3] of e5)
                        yc(t6, r3, n3, o3), n3.writer.move(n3.writer.createRangeIn(i3), n3.writer.createPositionBefore(i3)), n3.writer.remove(i3);
                      function s3(t7, e6) {
                        const n4 = e6.modelPosition.nodeAfter, o4 = r3.indexOf(n4);
                        o4 < 0 || (e6.viewPosition = e6.mapper.findPositionIn(i3, o4));
                      }
                      n3.mapper.off("modelToViewPosition", s3);
                    }(s2, r2, i2, { reconversion: e4.reconversion });
                  }), { priority: t4.converterPriority || "normal" }), e3.on("reduceChanges", _c(t4.model), { priority: "low" });
                };
              }(t3));
            }
            attributeToElement(t3) {
              return this.add(function(t4) {
                t4 = gc(t4);
                let e3 = "attribute:" + (t4.model.key ? t4.model.key : t4.model);
                t4.model.name && (e3 += ":" + t4.model.name);
                if (t4.model.values)
                  for (const e4 of t4.model.values)
                    t4.view[e4] = bc(t4.view[e4], "attribute");
                else
                  t4.view = bc(t4.view, "attribute");
                const n2 = wc(t4);
                return (o2) => {
                  o2.on(e3, function(t5) {
                    return (e4, n3, o3) => {
                      if (!o3.consumable.test(n3.item, e4.name))
                        return;
                      const i2 = t5(n3.attributeOldValue, o3), r2 = t5(n3.attributeNewValue, o3);
                      if (!i2 && !r2)
                        return;
                      o3.consumable.consume(n3.item, e4.name);
                      const s2 = o3.writer, a2 = s2.document.selection;
                      if (n3.item instanceof tc || n3.item instanceof lc)
                        s2.wrap(a2.getFirstRange(), r2);
                      else {
                        let t6 = o3.mapper.toViewRange(n3.range);
                        null !== n3.attributeOldValue && i2 && (t6 = s2.unwrap(t6, i2)), null !== n3.attributeNewValue && r2 && s2.wrap(t6, r2);
                      }
                    };
                  }(n2), { priority: t4.converterPriority || "normal" });
                };
              }(t3));
            }
            attributeToAttribute(t3) {
              return this.add(function(t4) {
                t4 = gc(t4);
                let e3 = "attribute:" + (t4.model.key ? t4.model.key : t4.model);
                t4.model.name && (e3 += ":" + t4.model.name);
                if (t4.model.values)
                  for (const e4 of t4.model.values)
                    t4.view[e4] = Cc(t4.view[e4]);
                else
                  t4.view = Cc(t4.view);
                const n2 = wc(t4);
                return (o2) => {
                  var i2;
                  o2.on(e3, (i2 = n2, (t5, e4, n3) => {
                    if (!n3.consumable.test(e4.item, t5.name))
                      return;
                    const o3 = i2(e4.attributeOldValue, n3), r2 = i2(e4.attributeNewValue, n3);
                    if (!o3 && !r2)
                      return;
                    n3.consumable.consume(e4.item, t5.name);
                    const s2 = n3.mapper.toViewElement(e4.item), c2 = n3.writer;
                    if (!s2)
                      throw new a("conversion-attribute-to-attribute-on-text", n3.dispatcher, e4);
                    if (null !== e4.attributeOldValue && o3)
                      if ("class" == o3.key) {
                        const t6 = So(o3.value);
                        for (const e5 of t6)
                          c2.removeClass(e5, s2);
                      } else if ("style" == o3.key) {
                        const t6 = Object.keys(o3.value);
                        for (const e5 of t6)
                          c2.removeStyle(e5, s2);
                      } else
                        c2.removeAttribute(o3.key, s2);
                    if (null !== e4.attributeNewValue && r2)
                      if ("class" == r2.key) {
                        const t6 = So(r2.value);
                        for (const e5 of t6)
                          c2.addClass(e5, s2);
                      } else if ("style" == r2.key) {
                        const t6 = Object.keys(r2.value);
                        for (const e5 of t6)
                          c2.setStyle(e5, r2.value[e5], s2);
                      } else
                        c2.setAttribute(r2.key, r2.value, s2);
                  }), { priority: t4.converterPriority || "normal" });
                };
              }(t3));
            }
            markerToElement(t3) {
              return this.add(function(t4) {
                return (t4 = gc(t4)).view = bc(t4.view, "ui"), (e3) => {
                  var n2;
                  e3.on("addMarker:" + t4.model, (n2 = t4.view, (t5, e4, o2) => {
                    e4.isOpening = true;
                    const i2 = n2(e4, o2);
                    e4.isOpening = false;
                    const r2 = n2(e4, o2);
                    if (!i2 || !r2)
                      return;
                    const s2 = e4.markerRange;
                    if (s2.isCollapsed && !o2.consumable.consume(s2, t5.name))
                      return;
                    for (const e5 of s2)
                      if (!o2.consumable.consume(e5.item, t5.name))
                        return;
                    const a2 = o2.mapper, c2 = o2.writer;
                    c2.insert(a2.toViewPosition(s2.start), i2), o2.mapper.bindElementToMarker(i2, e4.markerName), s2.isCollapsed || (c2.insert(a2.toViewPosition(s2.end), r2), o2.mapper.bindElementToMarker(r2, e4.markerName)), t5.stop();
                  }), { priority: t4.converterPriority || "normal" }), e3.on("removeMarker:" + t4.model, (t4.view, (t5, e4, n3) => {
                    const o2 = n3.mapper.markerNameToElements(e4.markerName);
                    if (o2) {
                      for (const t6 of o2)
                        n3.mapper.unbindElementFromMarkerName(t6, e4.markerName), n3.writer.clear(n3.writer.createRangeOn(t6), t6);
                      n3.writer.clearClonedElementsGroup(e4.markerName), t5.stop();
                    }
                  }), { priority: t4.converterPriority || "normal" });
                };
              }(t3));
            }
            markerToHighlight(t3) {
              return this.add(function(t4) {
                return (e3) => {
                  var n2;
                  e3.on("addMarker:" + t4.model, (n2 = t4.view, (t5, e4, o2) => {
                    if (!e4.item)
                      return;
                    if (!(e4.item instanceof tc || e4.item instanceof lc || e4.item.is("$textProxy")))
                      return;
                    const i2 = Ac(n2, e4, o2);
                    if (!i2)
                      return;
                    if (!o2.consumable.consume(e4.item, t5.name))
                      return;
                    const r2 = o2.writer, s2 = pc(r2, i2), a2 = r2.document.selection;
                    if (e4.item instanceof tc || e4.item instanceof lc)
                      r2.wrap(a2.getFirstRange(), s2, a2);
                    else {
                      const t6 = o2.mapper.toViewRange(e4.range), n3 = r2.wrap(t6, s2);
                      for (const t7 of n3.getItems())
                        if (t7.is("attributeElement") && t7.isSimilar(s2)) {
                          o2.mapper.bindElementToMarker(t7, e4.markerName);
                          break;
                        }
                    }
                  }), { priority: t4.converterPriority || "normal" }), e3.on("addMarker:" + t4.model, function(t5) {
                    return (e4, n3, o2) => {
                      if (!n3.item)
                        return;
                      if (!(n3.item instanceof Fa))
                        return;
                      const i2 = Ac(t5, n3, o2);
                      if (!i2)
                        return;
                      if (!o2.consumable.test(n3.item, e4.name))
                        return;
                      const r2 = o2.mapper.toViewElement(n3.item);
                      if (r2 && r2.getCustomProperty("addHighlight")) {
                        o2.consumable.consume(n3.item, e4.name);
                        for (const t6 of Ya._createIn(n3.item))
                          o2.consumable.consume(t6.item, e4.name);
                        r2.getCustomProperty("addHighlight")(r2, i2, o2.writer), o2.mapper.bindElementToMarker(r2, n3.markerName);
                      }
                    };
                  }(t4.view), { priority: t4.converterPriority || "normal" }), e3.on("removeMarker:" + t4.model, function(t5) {
                    return (e4, n3, o2) => {
                      if (n3.markerRange.isCollapsed)
                        return;
                      const i2 = Ac(t5, n3, o2);
                      if (!i2)
                        return;
                      const r2 = pc(o2.writer, i2), s2 = o2.mapper.markerNameToElements(n3.markerName);
                      if (s2) {
                        for (const t6 of s2)
                          o2.mapper.unbindElementFromMarkerName(t6, n3.markerName), t6.is("attributeElement") ? o2.writer.unwrap(o2.writer.createRangeOn(t6), r2) : t6.getCustomProperty("removeHighlight")(t6, i2.id, o2.writer);
                        o2.writer.clearClonedElementsGroup(n3.markerName), e4.stop();
                      }
                    };
                  }(t4.view), { priority: t4.converterPriority || "normal" });
                };
              }(t3));
            }
            markerToData(t3) {
              return this.add(function(t4) {
                const e3 = (t4 = gc(t4)).model;
                t4.view || (t4.view = (n2) => ({ group: e3, name: n2.substr(t4.model.length + 1) }));
                return (n2) => {
                  var o2;
                  n2.on("addMarker:" + e3, (o2 = t4.view, (t5, e4, n3) => {
                    const i2 = o2(e4.markerName, n3);
                    if (!i2)
                      return;
                    const r2 = e4.markerRange;
                    n3.consumable.consume(r2, t5.name) && (fc(r2, false, n3, e4, i2), fc(r2, true, n3, e4, i2), t5.stop());
                  }), { priority: t4.converterPriority || "normal" }), n2.on("removeMarker:" + e3, function(t5) {
                    return (e4, n3, o3) => {
                      const i2 = t5(n3.markerName, o3);
                      if (!i2)
                        return;
                      const r2 = o3.mapper.markerNameToElements(n3.markerName);
                      if (r2) {
                        for (const t6 of r2)
                          o3.mapper.unbindElementFromMarkerName(t6, n3.markerName), t6.is("containerElement") ? (s2(`data-${i2.group}-start-before`, t6), s2(`data-${i2.group}-start-after`, t6), s2(`data-${i2.group}-end-before`, t6), s2(`data-${i2.group}-end-after`, t6)) : o3.writer.clear(o3.writer.createRangeOn(t6), t6);
                        o3.writer.clearClonedElementsGroup(n3.markerName), e4.stop();
                      }
                      function s2(t6, e5) {
                        if (e5.hasAttribute(t6)) {
                          const n4 = new Set(e5.getAttribute(t6).split(","));
                          n4.delete(i2.name), 0 == n4.size ? o3.writer.removeAttribute(t6, e5) : o3.writer.setAttribute(t6, Array.from(n4).join(","), e5);
                        }
                      }
                    };
                  }(t4.view), { priority: t4.converterPriority || "normal" });
                };
              }(t3));
            }
          }
          function pc(t3, e3) {
            const n2 = t3.createAttributeElement("span", e3.attributes);
            return e3.classes && n2._addClass(e3.classes), "number" == typeof e3.priority && (n2._priority = e3.priority), n2._id = e3.id, n2;
          }
          function fc(t3, e3, n2, o2, i2) {
            const r2 = e3 ? t3.start : t3.end, s2 = r2.nodeAfter && r2.nodeAfter.is("element") ? r2.nodeAfter : null, a2 = r2.nodeBefore && r2.nodeBefore.is("element") ? r2.nodeBefore : null;
            if (s2 || a2) {
              let t4, r3;
              e3 && s2 || !e3 && !a2 ? (t4 = s2, r3 = true) : (t4 = a2, r3 = false);
              const c2 = n2.mapper.toViewElement(t4);
              if (c2)
                return void function(t5, e4, n3, o3, i3, r4) {
                  const s3 = `data-${r4.group}-${e4 ? "start" : "end"}-${n3 ? "before" : "after"}`, a3 = t5.hasAttribute(s3) ? t5.getAttribute(s3).split(",") : [];
                  a3.unshift(r4.name), o3.writer.setAttribute(s3, a3.join(","), t5), o3.mapper.bindElementToMarker(t5, i3.markerName);
                }(c2, e3, r3, n2, o2, i2);
            }
            !function(t4, e4, n3, o3, i3) {
              const r3 = `${i3.group}-${e4 ? "start" : "end"}`, s3 = i3.name ? { name: i3.name } : null, a3 = n3.writer.createUIElement(r3, s3);
              n3.writer.insert(t4, a3), n3.mapper.bindElementToMarker(a3, o3.markerName);
            }(n2.mapper.toViewPosition(r2), e3, n2, o2, i2);
          }
          function kc(t3) {
            return "string" == typeof t3 && (t3 = { name: t3 }), t3.attributes ? Array.isArray(t3.attributes) || (t3.attributes = [t3.attributes]) : t3.attributes = [], t3.children = !!t3.children, t3;
          }
          function bc(t3, e3) {
            return "function" == typeof t3 ? t3 : (n2, o2) => function(t4, e4, n3) {
              "string" == typeof t4 && (t4 = { name: t4 });
              let o3;
              const i2 = e4.writer, r2 = Object.assign({}, t4.attributes);
              if ("container" == n3)
                o3 = i2.createContainerElement(t4.name, r2);
              else if ("attribute" == n3) {
                const e5 = { priority: t4.priority || Xi.DEFAULT_PRIORITY };
                o3 = i2.createAttributeElement(t4.name, r2, e5);
              } else
                o3 = i2.createUIElement(t4.name, r2);
              if (t4.styles) {
                const e5 = Object.keys(t4.styles);
                for (const n4 of e5)
                  i2.setStyle(n4, t4.styles[n4], o3);
              }
              if (t4.classes) {
                const e5 = t4.classes;
                if ("string" == typeof e5)
                  i2.addClass(e5, o3);
                else
                  for (const t5 of e5)
                    i2.addClass(t5, o3);
              }
              return o3;
            }(t3, o2, e3);
          }
          function wc(t3) {
            return t3.model.values ? (e3, n2) => {
              const o2 = t3.view[e3];
              return o2 ? o2(e3, n2) : null;
            } : t3.view;
          }
          function Cc(t3) {
            return "string" == typeof t3 ? (e3) => ({ key: t3, value: e3 }) : "object" == typeof t3 ? t3.value ? () => t3 : (e3) => ({ key: t3.key, value: e3 }) : t3;
          }
          function Ac(t3, e3, n2) {
            const o2 = "function" == typeof t3 ? t3(e3, n2) : t3;
            return o2 ? (o2.priority || (o2.priority = 10), o2.id || (o2.id = e3.markerName), o2) : null;
          }
          function _c(t3) {
            const e3 = function(t4) {
              return (e4, n2) => {
                if (!e4.is("element", t4.name))
                  return false;
                if ("attribute" == n2.type) {
                  if (t4.attributes.includes(n2.attributeKey))
                    return true;
                } else if (t4.children)
                  return true;
                return false;
              };
            }(t3);
            return (t4, n2) => {
              const o2 = [];
              n2.reconvertedElements || (n2.reconvertedElements = /* @__PURE__ */ new Set());
              for (const t5 of n2.changes) {
                const i2 = t5.position ? t5.position.parent : t5.range.start.nodeAfter;
                if (i2 && e3(i2, t5)) {
                  if (!n2.reconvertedElements.has(i2)) {
                    n2.reconvertedElements.add(i2);
                    const t6 = Ha._createBefore(i2);
                    o2.push({ type: "remove", name: i2.name, position: t6, length: 1 }, { type: "reinsert", name: i2.name, position: t6, length: 1 });
                  }
                } else
                  o2.push(t5);
              }
              n2.changes = o2;
            };
          }
          function vc(t3) {
            return (e3, n2, o2 = {}) => {
              const i2 = ["insert"];
              for (const n3 of t3.attributes)
                e3.hasAttribute(n3) && i2.push(`attribute:${n3}`);
              return !!i2.every((t4) => n2.test(e3, t4)) && (o2.preflight || i2.forEach((t4) => n2.consume(e3, t4)), true);
            };
          }
          function yc(t3, e3, n2, o2) {
            for (const i2 of e3)
              xc(t3.root, i2, n2, o2) || n2.convertItem(i2);
          }
          function xc(t3, e3, n2, o2) {
            const { writer: i2, mapper: r2 } = n2;
            if (!o2.reconversion)
              return false;
            const s2 = r2.toViewElement(e3);
            return !(!s2 || s2.root == t3) && (!!n2.canReuseView(s2) && (i2.move(i2.createRangeOn(s2), r2.toViewPosition(Ha._createBefore(e3))), true));
          }
          function Ec(t3, e3, { preflight: n2 } = {}) {
            return n2 ? e3.test(t3, "insert") : e3.consume(t3, "insert");
          }
          function Dc(t3) {
            const { schema: e3, document: n2 } = t3.model;
            for (const o2 of n2.getRootNames()) {
              const i2 = n2.getRoot(o2);
              if (i2.isEmpty && !e3.checkChild(i2, "$text") && e3.checkChild(i2, "paragraph"))
                return t3.insertElement("paragraph", i2), true;
            }
            return false;
          }
          function Ic(t3, e3, n2) {
            const o2 = n2.createContext(t3);
            return !!n2.checkChild(o2, "paragraph") && !!n2.checkChild(o2.push("paragraph"), e3);
          }
          function Mc(t3, e3) {
            const n2 = e3.createElement("paragraph");
            return e3.insert(n2, t3), e3.createPositionAt(n2, 0);
          }
          class Sc extends uc {
            elementToElement(t3) {
              return this.add(Tc(t3));
            }
            elementToAttribute(t3) {
              return this.add(function(t4) {
                zc(t4 = gc(t4));
                const e3 = Pc(t4, false), n2 = Nc(t4.view), o2 = n2 ? "element:" + n2 : "element";
                return (n3) => {
                  n3.on(o2, e3, { priority: t4.converterPriority || "low" });
                };
              }(t3));
            }
            attributeToAttribute(t3) {
              return this.add(function(t4) {
                t4 = gc(t4);
                let e3 = null;
                ("string" == typeof t4.view || t4.view.key) && (e3 = function(t5) {
                  "string" == typeof t5.view && (t5.view = { key: t5.view });
                  const e4 = t5.view.key;
                  let n3;
                  if ("class" == e4 || "style" == e4) {
                    n3 = { ["class" == e4 ? "classes" : "styles"]: t5.view.value };
                  } else {
                    n3 = { attributes: { [e4]: void 0 === t5.view.value ? /[\s\S]*/ : t5.view.value } };
                  }
                  t5.view.name && (n3.name = t5.view.name);
                  return t5.view = n3, e4;
                }(t4));
                zc(t4, e3);
                const n2 = Pc(t4, true);
                return (e4) => {
                  e4.on("element", n2, { priority: t4.converterPriority || "low" });
                };
              }(t3));
            }
            elementToMarker(t3) {
              return this.add(function(t4) {
                return function(t5) {
                  const e3 = t5.model;
                  t5.model = (t6, n2) => {
                    const o2 = "string" == typeof e3 ? e3 : e3(t6, n2);
                    return n2.writer.createElement("$marker", { "data-name": o2 });
                  };
                }(t4 = gc(t4)), Tc(t4);
              }(t3));
            }
            dataToMarker(t3) {
              return this.add(function(t4) {
                (t4 = gc(t4)).model || (t4.model = (e4) => e4 ? t4.view + ":" + e4 : t4.view);
                const e3 = Bc(Lc(t4, "start")), n2 = Bc(Lc(t4, "end"));
                return (o2) => {
                  o2.on("element:" + t4.view + "-start", e3, { priority: t4.converterPriority || "normal" }), o2.on("element:" + t4.view + "-end", n2, { priority: t4.converterPriority || "normal" });
                  const i2 = s.get("low"), r2 = s.get("highest"), a2 = s.get(t4.converterPriority) / r2;
                  o2.on("element", function(t5) {
                    return (e4, n3, o3) => {
                      const i3 = `data-${t5.view}`;
                      function r3(e5, i4) {
                        for (const r4 of i4) {
                          const i5 = t5.model(r4, o3), s2 = o3.writer.createElement("$marker", { "data-name": i5 });
                          o3.writer.insert(s2, e5), n3.modelCursor.isEqual(e5) ? n3.modelCursor = n3.modelCursor.getShiftedBy(1) : n3.modelCursor = n3.modelCursor._getTransformedByInsertion(e5, 1), n3.modelRange = n3.modelRange._getTransformedByInsertion(e5, 1)[0];
                        }
                      }
                      (o3.consumable.test(n3.viewItem, { attributes: i3 + "-end-after" }) || o3.consumable.test(n3.viewItem, { attributes: i3 + "-start-after" }) || o3.consumable.test(n3.viewItem, { attributes: i3 + "-end-before" }) || o3.consumable.test(n3.viewItem, { attributes: i3 + "-start-before" })) && (n3.modelRange || Object.assign(n3, o3.convertChildren(n3.viewItem, n3.modelCursor)), o3.consumable.consume(n3.viewItem, { attributes: i3 + "-end-after" }) && r3(n3.modelRange.end, n3.viewItem.getAttribute(i3 + "-end-after").split(",")), o3.consumable.consume(n3.viewItem, { attributes: i3 + "-start-after" }) && r3(n3.modelRange.end, n3.viewItem.getAttribute(i3 + "-start-after").split(",")), o3.consumable.consume(n3.viewItem, { attributes: i3 + "-end-before" }) && r3(n3.modelRange.start, n3.viewItem.getAttribute(i3 + "-end-before").split(",")), o3.consumable.consume(n3.viewItem, { attributes: i3 + "-start-before" }) && r3(n3.modelRange.start, n3.viewItem.getAttribute(i3 + "-start-before").split(",")));
                    };
                  }(t4), { priority: i2 + a2 });
                };
              }(t3));
            }
          }
          function Tc(t3) {
            const e3 = Bc(t3 = gc(t3)), n2 = Nc(t3.view), o2 = n2 ? "element:" + n2 : "element";
            return (n3) => {
              n3.on(o2, e3, { priority: t3.converterPriority || "normal" });
            };
          }
          function Nc(t3) {
            return "string" == typeof t3 ? t3 : "object" == typeof t3 && "string" == typeof t3.name ? t3.name : null;
          }
          function Bc(t3) {
            const e3 = new Ho(t3.view);
            return (n2, o2, i2) => {
              const r2 = e3.match(o2.viewItem);
              if (!r2)
                return;
              const s2 = r2.match;
              if (s2.name = true, !i2.consumable.test(o2.viewItem, s2))
                return;
              const a2 = function(t4, e4, n3) {
                return t4 instanceof Function ? t4(e4, n3) : n3.writer.createElement(t4);
              }(t3.model, o2.viewItem, i2);
              a2 && i2.safeInsert(a2, o2.modelCursor) && (i2.consumable.consume(o2.viewItem, s2), i2.convertChildren(o2.viewItem, a2), i2.updateConversionResult(a2, o2));
            };
          }
          function zc(t3, e3 = null) {
            const n2 = null === e3 || ((t4) => t4.getAttribute(e3)), o2 = "object" != typeof t3.model ? t3.model : t3.model.key, i2 = "object" != typeof t3.model || void 0 === t3.model.value ? n2 : t3.model.value;
            t3.model = { key: o2, value: i2 };
          }
          function Pc(t3, e3) {
            const n2 = new Ho(t3.view);
            return (o2, i2, r2) => {
              const s2 = n2.match(i2.viewItem);
              if (!s2)
                return;
              if (!function(t4, e4) {
                const n3 = "function" == typeof t4 ? t4(e4) : t4;
                if ("object" == typeof n3 && !Nc(n3))
                  return false;
                return !n3.classes && !n3.attributes && !n3.styles;
              }(t3.view, i2.viewItem) ? delete s2.match.name : s2.match.name = true, !r2.consumable.test(i2.viewItem, s2.match))
                return;
              const a2 = t3.model.key, c2 = "function" == typeof t3.model.value ? t3.model.value(i2.viewItem, r2) : t3.model.value;
              if (null === c2)
                return;
              i2.modelRange || Object.assign(i2, r2.convertChildren(i2.viewItem, i2.modelCursor));
              const l2 = function(t4, e4, n3, o3) {
                let i3 = false;
                for (const r3 of Array.from(t4.getItems({ shallow: n3 })))
                  o3.schema.checkAttribute(r3, e4.key) && (i3 = true, r3.hasAttribute(e4.key) || o3.writer.setAttribute(e4.key, e4.value, r3));
                return i3;
              }(i2.modelRange, { key: a2, value: c2 }, e3, r2);
              l2 && r2.consumable.consume(i2.viewItem, s2.match);
            };
          }
          function Lc(t3, e3) {
            const n2 = {};
            return n2.view = t3.view + "-" + e3, n2.model = (e4, n3) => {
              const o2 = e4.getAttribute("name"), i2 = t3.model(o2, n3);
              return n3.writer.createElement("$marker", { "data-name": i2 });
            }, n2;
          }
          class Oc {
            constructor(t3, e3) {
              this.model = t3, this.view = new Pa(e3), this.mapper = new Qa(), this.downcastDispatcher = new Za({ mapper: this.mapper, schema: t3.schema });
              const n2 = this.model.document, o2 = n2.selection, i2 = this.model.markers;
              this.listenTo(this.model, "_beforeChanges", () => {
                this.view._disableRendering(true);
              }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
                this.view._disableRendering(false);
              }, { priority: "lowest" }), this.listenTo(n2, "change", () => {
                this.view.change((t4) => {
                  this.downcastDispatcher.convertChanges(n2.differ, i2, t4), this.downcastDispatcher.convertSelection(o2, i2, t4);
                });
              }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", function(t4, e4) {
                return (n3, o3) => {
                  const i3 = o3.newSelection, r2 = [];
                  for (const t5 of i3.getRanges())
                    r2.push(e4.toModelRange(t5));
                  const s2 = t4.createSelection(r2, { backward: i3.isBackward });
                  s2.isEqual(t4.document.selection) || t4.change((t5) => {
                    t5.setSelection(s2);
                  });
                };
              }(this.model, this.mapper)), this.downcastDispatcher.on("insert:$text", (t4, e4, n3) => {
                if (!n3.consumable.consume(e4.item, t4.name))
                  return;
                const o3 = n3.writer, i3 = n3.mapper.toViewPosition(e4.range.start), r2 = o3.createText(e4.item.data);
                o3.insert(i3, r2);
              }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (t4, e4, n3) => {
                n3.convertAttributes(e4.item), e4.reconversion || !e4.item.is("element") || e4.item.isEmpty || n3.convertChildren(e4.item);
              }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (t4, e4, n3) => {
                const o3 = n3.mapper.toViewPosition(e4.position), i3 = e4.position.getShiftedBy(e4.length), r2 = n3.mapper.toViewPosition(i3, { isPhantom: true }), s2 = n3.writer.createRange(o3, r2), a2 = n3.writer.remove(s2.getTrimmed());
                for (const t5 of n3.writer.createRangeIn(a2).getItems())
                  n3.mapper.unbindViewElement(t5, { defer: true });
              }, { priority: "low" }), this.downcastDispatcher.on("selection", (t4, e4, n3) => {
                const o3 = n3.writer, i3 = o3.document.selection;
                for (const t5 of i3.getRanges())
                  t5.isCollapsed && t5.end.parent.isAttached() && n3.writer.mergeAttributes(t5.start);
                o3.setSelection(null);
              }, { priority: "high" }), this.downcastDispatcher.on("selection", (t4, e4, n3) => {
                const o3 = e4.selection;
                if (o3.isCollapsed)
                  return;
                if (!n3.consumable.consume(o3, "selection"))
                  return;
                const i3 = [];
                for (const t5 of o3.getRanges()) {
                  const e5 = n3.mapper.toViewRange(t5);
                  i3.push(e5);
                }
                n3.writer.setSelection(i3, { backward: o3.isBackward });
              }, { priority: "low" }), this.downcastDispatcher.on("selection", (t4, e4, n3) => {
                const o3 = e4.selection;
                if (!o3.isCollapsed)
                  return;
                if (!n3.consumable.consume(o3, "selection"))
                  return;
                const i3 = n3.writer, r2 = o3.getFirstPosition(), s2 = n3.mapper.toViewPosition(r2), a2 = i3.breakAttributes(s2);
                i3.setSelection(a2);
              }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((t4) => {
                if ("$graveyard" == t4.rootName)
                  return null;
                const e4 = new Li(this.view.document, t4.name);
                return e4.rootName = t4.rootName, this.mapper.bindElements(t4, e4), e4;
              });
            }
            destroy() {
              this.view.destroy(), this.stopListening();
            }
            reconvertMarker(t3) {
              const e3 = "string" == typeof t3 ? t3 : t3.name, n2 = this.model.markers.get(e3);
              if (!n2)
                throw new a("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: e3 });
              this.model.change(() => {
                this.model.markers._refresh(n2);
              });
            }
            reconvertItem(t3) {
              this.model.change(() => {
                this.model.document.differ._refreshItem(t3);
              });
            }
          }
          he(Oc, re);
          class Rc {
            constructor() {
              this._commands = /* @__PURE__ */ new Map();
            }
            add(t3, e3) {
              this._commands.set(t3, e3);
            }
            get(t3) {
              return this._commands.get(t3);
            }
            execute(t3, ...e3) {
              const n2 = this.get(t3);
              if (!n2)
                throw new a("commandcollection-command-not-found", this, { commandName: t3 });
              return n2.execute(...e3);
            }
            *names() {
              yield* this._commands.keys();
            }
            *commands() {
              yield* this._commands.values();
            }
            [Symbol.iterator]() {
              return this._commands[Symbol.iterator]();
            }
            destroy() {
              for (const t3 of this.commands())
                t3.destroy();
            }
          }
          class jc {
            constructor() {
              this._consumables = /* @__PURE__ */ new Map();
            }
            add(t3, e3) {
              let n2;
              t3.is("$text") || t3.is("documentFragment") ? this._consumables.set(t3, true) : (this._consumables.has(t3) ? n2 = this._consumables.get(t3) : (n2 = new Fc(t3), this._consumables.set(t3, n2)), n2.add(e3));
            }
            test(t3, e3) {
              const n2 = this._consumables.get(t3);
              return void 0 === n2 ? null : t3.is("$text") || t3.is("documentFragment") ? n2 : n2.test(e3);
            }
            consume(t3, e3) {
              return !!this.test(t3, e3) && (t3.is("$text") || t3.is("documentFragment") ? this._consumables.set(t3, false) : this._consumables.get(t3).consume(e3), true);
            }
            revert(t3, e3) {
              const n2 = this._consumables.get(t3);
              void 0 !== n2 && (t3.is("$text") || t3.is("documentFragment") ? this._consumables.set(t3, true) : n2.revert(e3));
            }
            static consumablesFromElement(t3) {
              const e3 = { element: t3, name: true, attributes: [], classes: [], styles: [] }, n2 = t3.getAttributeKeys();
              for (const t4 of n2)
                "style" != t4 && "class" != t4 && e3.attributes.push(t4);
              const o2 = t3.getClassNames();
              for (const t4 of o2)
                e3.classes.push(t4);
              const i2 = t3.getStyleNames();
              for (const t4 of i2)
                e3.styles.push(t4);
              return e3;
            }
            static createFrom(t3, e3) {
              if (e3 || (e3 = new jc(t3)), t3.is("$text"))
                return e3.add(t3), e3;
              t3.is("element") && e3.add(t3, jc.consumablesFromElement(t3)), t3.is("documentFragment") && e3.add(t3);
              for (const n2 of t3.getChildren())
                e3 = jc.createFrom(n2, e3);
              return e3;
            }
          }
          class Fc {
            constructor(t3) {
              this.element = t3, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
            }
            add(t3) {
              t3.name && (this._canConsumeName = true);
              for (const e3 in this._consumables)
                e3 in t3 && this._add(e3, t3[e3]);
            }
            test(t3) {
              if (t3.name && !this._canConsumeName)
                return this._canConsumeName;
              for (const e3 in this._consumables)
                if (e3 in t3) {
                  const n2 = this._test(e3, t3[e3]);
                  if (true !== n2)
                    return n2;
                }
              return true;
            }
            consume(t3) {
              t3.name && (this._canConsumeName = false);
              for (const e3 in this._consumables)
                e3 in t3 && this._consume(e3, t3[e3]);
            }
            revert(t3) {
              t3.name && (this._canConsumeName = true);
              for (const e3 in this._consumables)
                e3 in t3 && this._revert(e3, t3[e3]);
            }
            _add(t3, e3) {
              const n2 = Mt(e3) ? e3 : [e3], o2 = this._consumables[t3];
              for (const e4 of n2) {
                if ("attributes" === t3 && ("class" === e4 || "style" === e4))
                  throw new a("viewconsumable-invalid-attribute", this);
                if (o2.set(e4, true), "styles" === t3)
                  for (const t4 of this.element.document.stylesProcessor.getRelatedStyles(e4))
                    o2.set(t4, true);
              }
            }
            _test(t3, e3) {
              const n2 = Mt(e3) ? e3 : [e3], o2 = this._consumables[t3];
              for (const e4 of n2)
                if ("attributes" !== t3 || "class" !== e4 && "style" !== e4) {
                  const t4 = o2.get(e4);
                  if (void 0 === t4)
                    return null;
                  if (!t4)
                    return false;
                } else {
                  const t4 = "class" == e4 ? "classes" : "styles", n3 = this._test(t4, [...this._consumables[t4].keys()]);
                  if (true !== n3)
                    return n3;
                }
              return true;
            }
            _consume(t3, e3) {
              const n2 = Mt(e3) ? e3 : [e3], o2 = this._consumables[t3];
              for (const e4 of n2)
                if ("attributes" !== t3 || "class" !== e4 && "style" !== e4) {
                  if (o2.set(e4, false), "styles" == t3)
                    for (const t4 of this.element.document.stylesProcessor.getRelatedStyles(e4))
                      o2.set(t4, false);
                } else {
                  const t4 = "class" == e4 ? "classes" : "styles";
                  this._consume(t4, [...this._consumables[t4].keys()]);
                }
            }
            _revert(t3, e3) {
              const n2 = Mt(e3) ? e3 : [e3], o2 = this._consumables[t3];
              for (const e4 of n2)
                if ("attributes" !== t3 || "class" !== e4 && "style" !== e4) {
                  false === o2.get(e4) && o2.set(e4, true);
                } else {
                  const t4 = "class" == e4 ? "classes" : "styles";
                  this._revert(t4, [...this._consumables[t4].keys()]);
                }
            }
          }
          class Vc {
            constructor() {
              this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (t3, e3) => {
                e3[0] = new Uc(e3[0]);
              }, { priority: "highest" }), this.on("checkChild", (t3, e3) => {
                e3[0] = new Uc(e3[0]), e3[1] = this.getDefinition(e3[1]);
              }, { priority: "highest" });
            }
            register(t3, e3) {
              if (this._sourceDefinitions[t3])
                throw new a("schema-cannot-register-item-twice", this, { itemName: t3 });
              this._sourceDefinitions[t3] = [Object.assign({}, e3)], this._clearCache();
            }
            extend(t3, e3) {
              if (!this._sourceDefinitions[t3])
                throw new a("schema-cannot-extend-missing-item", this, { itemName: t3 });
              this._sourceDefinitions[t3].push(Object.assign({}, e3)), this._clearCache();
            }
            getDefinitions() {
              return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
            }
            getDefinition(t3) {
              let e3;
              return e3 = "string" == typeof t3 ? t3 : t3.is && (t3.is("$text") || t3.is("$textProxy")) ? "$text" : t3.name, this.getDefinitions()[e3];
            }
            isRegistered(t3) {
              return !!this.getDefinition(t3);
            }
            isBlock(t3) {
              const e3 = this.getDefinition(t3);
              return !(!e3 || !e3.isBlock);
            }
            isLimit(t3) {
              const e3 = this.getDefinition(t3);
              return !!e3 && !(!e3.isLimit && !e3.isObject);
            }
            isObject(t3) {
              const e3 = this.getDefinition(t3);
              return !!e3 && !!(e3.isObject || e3.isLimit && e3.isSelectable && e3.isContent);
            }
            isInline(t3) {
              const e3 = this.getDefinition(t3);
              return !(!e3 || !e3.isInline);
            }
            isSelectable(t3) {
              const e3 = this.getDefinition(t3);
              return !!e3 && !(!e3.isSelectable && !e3.isObject);
            }
            isContent(t3) {
              const e3 = this.getDefinition(t3);
              return !!e3 && !(!e3.isContent && !e3.isObject);
            }
            checkChild(t3, e3) {
              return !!e3 && this._checkContextMatch(e3, t3);
            }
            checkAttribute(t3, e3) {
              const n2 = this.getDefinition(t3.last);
              return !!n2 && n2.allowAttributes.includes(e3);
            }
            checkMerge(t3, e3 = null) {
              if (t3 instanceof Ha) {
                const e4 = t3.nodeBefore, n2 = t3.nodeAfter;
                if (!(e4 instanceof Fa))
                  throw new a("schema-check-merge-no-element-before", this);
                if (!(n2 instanceof Fa))
                  throw new a("schema-check-merge-no-element-after", this);
                return this.checkMerge(e4, n2);
              }
              for (const n2 of e3.getChildren())
                if (!this.checkChild(t3, n2))
                  return false;
              return true;
            }
            addChildCheck(t3) {
              this.on("checkChild", (e3, [n2, o2]) => {
                if (!o2)
                  return;
                const i2 = t3(n2, o2);
                "boolean" == typeof i2 && (e3.stop(), e3.return = i2);
              }, { priority: "high" });
            }
            addAttributeCheck(t3) {
              this.on("checkAttribute", (e3, [n2, o2]) => {
                const i2 = t3(n2, o2);
                "boolean" == typeof i2 && (e3.stop(), e3.return = i2);
              }, { priority: "high" });
            }
            setAttributeProperties(t3, e3) {
              this._attributeProperties[t3] = Object.assign(this.getAttributeProperties(t3), e3);
            }
            getAttributeProperties(t3) {
              return this._attributeProperties[t3] || {};
            }
            getLimitElement(t3) {
              let e3;
              if (t3 instanceof Ha)
                e3 = t3.parent;
              else {
                e3 = (t3 instanceof Ya ? [t3] : Array.from(t3.getRanges())).reduce((t4, e4) => {
                  const n2 = e4.getCommonAncestor();
                  return t4 ? t4.getCommonAncestor(n2, { includeSelf: true }) : n2;
                }, null);
              }
              for (; !this.isLimit(e3) && e3.parent; )
                e3 = e3.parent;
              return e3;
            }
            checkAttributeInSelection(t3, e3) {
              if (t3.isCollapsed) {
                const n2 = [...t3.getFirstPosition().getAncestors(), new Oa("", t3.getAttributes())];
                return this.checkAttribute(n2, e3);
              }
              {
                const n2 = t3.getRanges();
                for (const t4 of n2)
                  for (const n3 of t4)
                    if (this.checkAttribute(n3.item, e3))
                      return true;
              }
              return false;
            }
            *getValidRanges(t3, e3) {
              t3 = function* (t4) {
                for (const e4 of t4)
                  yield* e4.getMinimalFlatRanges();
              }(t3);
              for (const n2 of t3)
                yield* this._getValidRangesForRange(n2, e3);
            }
            getNearestSelectionRange(t3, e3 = "both") {
              if (this.checkChild(t3, "$text"))
                return new Ya(t3);
              let n2, o2;
              const i2 = t3.getAncestors().reverse().find((t4) => this.isLimit(t4)) || t3.root;
              "both" != e3 && "backward" != e3 || (n2 = new Va({ boundaries: Ya._createIn(i2), startPosition: t3, direction: "backward" })), "both" != e3 && "forward" != e3 || (o2 = new Va({ boundaries: Ya._createIn(i2), startPosition: t3 }));
              for (const t4 of function* (t5, e4) {
                let n3 = false;
                for (; !n3; ) {
                  if (n3 = true, t5) {
                    const e5 = t5.next();
                    e5.done || (n3 = false, yield { walker: t5, value: e5.value });
                  }
                  if (e4) {
                    const t6 = e4.next();
                    t6.done || (n3 = false, yield { walker: e4, value: t6.value });
                  }
                }
              }(n2, o2)) {
                const e4 = t4.walker == n2 ? "elementEnd" : "elementStart", o3 = t4.value;
                if (o3.type == e4 && this.isObject(o3.item))
                  return Ya._createOn(o3.item);
                if (this.checkChild(o3.nextPosition, "$text"))
                  return new Ya(o3.nextPosition);
              }
              return null;
            }
            findAllowedParent(t3, e3) {
              let n2 = t3.parent;
              for (; n2; ) {
                if (this.checkChild(n2, e3))
                  return n2;
                if (this.isLimit(n2))
                  return null;
                n2 = n2.parent;
              }
              return null;
            }
            removeDisallowedAttributes(t3, e3) {
              for (const n2 of t3)
                if (n2.is("$text"))
                  el(this, n2, e3);
                else {
                  const t4 = Ya._createIn(n2).getPositions();
                  for (const n3 of t4) {
                    el(this, n3.nodeBefore || n3.parent, e3);
                  }
                }
            }
            createContext(t3) {
              return new Uc(t3);
            }
            _clearCache() {
              this._compiledDefinitions = null;
            }
            _compile() {
              const t3 = {}, e3 = this._sourceDefinitions, n2 = Object.keys(e3);
              for (const o2 of n2)
                t3[o2] = Hc(e3[o2], o2);
              for (const e4 of n2)
                qc(t3, e4);
              for (const e4 of n2)
                Wc(t3, e4);
              for (const e4 of n2)
                Gc(t3, e4);
              for (const e4 of n2)
                Yc(t3, e4), Qc(t3, e4);
              for (const e4 of n2)
                Kc(t3, e4), $c(t3, e4), Zc(t3, e4);
              this._compiledDefinitions = t3;
            }
            _checkContextMatch(t3, e3, n2 = e3.length - 1) {
              const o2 = e3.getItem(n2);
              if (t3.allowIn.includes(o2.name)) {
                if (0 == n2)
                  return true;
                {
                  const t4 = this.getDefinition(o2);
                  return this._checkContextMatch(t4, e3, n2 - 1);
                }
              }
              return false;
            }
            *_getValidRangesForRange(t3, e3) {
              let n2 = t3.start, o2 = t3.start;
              for (const i2 of t3.getItems({ shallow: true }))
                i2.is("element") && (yield* this._getValidRangesForRange(Ya._createIn(i2), e3)), this.checkAttribute(i2, e3) || (n2.isEqual(o2) || (yield new Ya(n2, o2)), n2 = Ha._createAfter(i2)), o2 = Ha._createAfter(i2);
              n2.isEqual(o2) || (yield new Ya(n2, o2));
            }
          }
          he(Vc, re);
          class Uc {
            constructor(t3) {
              if (t3 instanceof Uc)
                return t3;
              "string" == typeof t3 ? t3 = [t3] : Array.isArray(t3) || (t3 = t3.getAncestors({ includeSelf: true })), this._items = t3.map(tl);
            }
            get length() {
              return this._items.length;
            }
            get last() {
              return this._items[this._items.length - 1];
            }
            [Symbol.iterator]() {
              return this._items[Symbol.iterator]();
            }
            push(t3) {
              const e3 = new Uc([t3]);
              return e3._items = [...this._items, ...e3._items], e3;
            }
            getItem(t3) {
              return this._items[t3];
            }
            *getNames() {
              yield* this._items.map((t3) => t3.name);
            }
            endsWith(t3) {
              return Array.from(this.getNames()).join(" ").endsWith(t3);
            }
            startsWith(t3) {
              return Array.from(this.getNames()).join(" ").startsWith(t3);
            }
          }
          function Hc(t3, e3) {
            const n2 = { name: e3, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
            return function(t4, e4) {
              for (const n3 of t4) {
                const t5 = Object.keys(n3).filter((t6) => t6.startsWith("is"));
                for (const o2 of t5)
                  e4[o2] = n3[o2];
              }
            }(t3, n2), Jc(t3, n2, "allowIn"), Jc(t3, n2, "allowContentOf"), Jc(t3, n2, "allowWhere"), Jc(t3, n2, "allowAttributes"), Jc(t3, n2, "allowAttributesOf"), Jc(t3, n2, "allowChildren"), Jc(t3, n2, "inheritTypesFrom"), function(t4, e4) {
              for (const n3 of t4) {
                const t5 = n3.inheritAllFrom;
                t5 && (e4.allowContentOf.push(t5), e4.allowWhere.push(t5), e4.allowAttributesOf.push(t5), e4.inheritTypesFrom.push(t5));
              }
            }(t3, n2), n2;
          }
          function qc(t3, e3) {
            const n2 = t3[e3];
            for (const o2 of n2.allowChildren) {
              const n3 = t3[o2];
              n3 && n3.allowIn.push(e3);
            }
            n2.allowChildren.length = 0;
          }
          function Wc(t3, e3) {
            for (const n2 of t3[e3].allowContentOf)
              if (t3[n2]) {
                Xc(t3, n2).forEach((t4) => {
                  t4.allowIn.push(e3);
                });
              }
            delete t3[e3].allowContentOf;
          }
          function Gc(t3, e3) {
            for (const n2 of t3[e3].allowWhere) {
              const o2 = t3[n2];
              if (o2) {
                const n3 = o2.allowIn;
                t3[e3].allowIn.push(...n3);
              }
            }
            delete t3[e3].allowWhere;
          }
          function Yc(t3, e3) {
            for (const n2 of t3[e3].allowAttributesOf) {
              const o2 = t3[n2];
              if (o2) {
                const n3 = o2.allowAttributes;
                t3[e3].allowAttributes.push(...n3);
              }
            }
            delete t3[e3].allowAttributesOf;
          }
          function Qc(t3, e3) {
            const n2 = t3[e3];
            for (const e4 of n2.inheritTypesFrom) {
              const o2 = t3[e4];
              if (o2) {
                const t4 = Object.keys(o2).filter((t5) => t5.startsWith("is"));
                for (const e5 of t4)
                  e5 in n2 || (n2[e5] = o2[e5]);
              }
            }
            delete n2.inheritTypesFrom;
          }
          function Kc(t3, e3) {
            const n2 = t3[e3], o2 = n2.allowIn.filter((e4) => t3[e4]);
            n2.allowIn = Array.from(new Set(o2));
          }
          function $c(t3, e3) {
            const n2 = t3[e3];
            for (const o2 of n2.allowIn) {
              t3[o2].allowChildren.push(e3);
            }
          }
          function Zc(t3, e3) {
            const n2 = t3[e3];
            n2.allowAttributes = Array.from(new Set(n2.allowAttributes));
          }
          function Jc(t3, e3, n2) {
            for (const o2 of t3)
              "string" == typeof o2[n2] ? e3[n2].push(o2[n2]) : Array.isArray(o2[n2]) && e3[n2].push(...o2[n2]);
          }
          function Xc(t3, e3) {
            const n2 = t3[e3];
            return (o2 = t3, Object.keys(o2).map((t4) => o2[t4])).filter((t4) => t4.allowIn.includes(n2.name));
            var o2;
          }
          function tl(t3) {
            return "string" == typeof t3 || t3.is("documentFragment") ? { name: "string" == typeof t3 ? t3 : "$documentFragment", *getAttributeKeys() {
            }, getAttribute() {
            } } : { name: t3.is("element") ? t3.name : "$text", *getAttributeKeys() {
              yield* t3.getAttributeKeys();
            }, getAttribute: (e3) => t3.getAttribute(e3) };
          }
          function el(t3, e3, n2) {
            for (const o2 of e3.getAttributeKeys())
              t3.checkAttribute(e3, o2) || n2.removeAttribute(o2, e3);
          }
          class nl {
            constructor(t3 = {}) {
              this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this.conversionApi = Object.assign({}, t3), this.conversionApi.convertItem = this._convertItem.bind(this), this.conversionApi.convertChildren = this._convertChildren.bind(this), this.conversionApi.safeInsert = this._safeInsert.bind(this), this.conversionApi.updateConversionResult = this._updateConversionResult.bind(this), this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this), this.conversionApi.getSplitParts = this._getSplitParts.bind(this);
            }
            convert(t3, e3, n2 = ["$root"]) {
              this.fire("viewCleanup", t3), this._modelCursor = function(t4, e4) {
                let n3;
                for (const o3 of new Uc(t4)) {
                  const t5 = {};
                  for (const e5 of o3.getAttributeKeys())
                    t5[e5] = o3.getAttribute(e5);
                  const i3 = e4.createElement(o3.name, t5);
                  n3 && e4.append(i3, n3), n3 = Ha._createAt(i3, 0);
                }
                return n3;
              }(n2, e3), this.conversionApi.writer = e3, this.conversionApi.consumable = jc.createFrom(t3), this.conversionApi.store = {};
              const { modelRange: o2 } = this._convertItem(t3, this._modelCursor), i2 = e3.createDocumentFragment();
              if (o2) {
                this._removeEmptyElements();
                for (const t4 of Array.from(this._modelCursor.parent.getChildren()))
                  e3.append(t4, i2);
                i2.markers = function(t4, e4) {
                  const n3 = /* @__PURE__ */ new Set(), o3 = /* @__PURE__ */ new Map(), i3 = Ya._createIn(t4).getItems();
                  for (const t5 of i3)
                    "$marker" == t5.name && n3.add(t5);
                  for (const t5 of n3) {
                    const n4 = t5.getAttribute("data-name"), i4 = e4.createPositionBefore(t5);
                    o3.has(n4) ? o3.get(n4).end = i4.clone() : o3.set(n4, new Ya(i4.clone())), e4.remove(t5);
                  }
                  return o3;
                }(i2, e3);
              }
              return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, i2;
            }
            _convertItem(t3, e3) {
              const n2 = Object.assign({ viewItem: t3, modelCursor: e3, modelRange: null });
              if (t3.is("element") ? this.fire("element:" + t3.name, n2, this.conversionApi) : t3.is("$text") ? this.fire("text", n2, this.conversionApi) : this.fire("documentFragment", n2, this.conversionApi), n2.modelRange && !(n2.modelRange instanceof Ya))
                throw new a("view-conversion-dispatcher-incorrect-result", this);
              return { modelRange: n2.modelRange, modelCursor: n2.modelCursor };
            }
            _convertChildren(t3, e3) {
              let n2 = e3.is("position") ? e3 : Ha._createAt(e3, 0);
              const o2 = new Ya(n2);
              for (const e4 of Array.from(t3.getChildren())) {
                const t4 = this._convertItem(e4, n2);
                t4.modelRange instanceof Ya && (o2.end = t4.modelRange.end, n2 = t4.modelCursor);
              }
              return { modelRange: o2, modelCursor: n2 };
            }
            _safeInsert(t3, e3) {
              const n2 = this._splitToAllowedParent(t3, e3);
              return !!n2 && (this.conversionApi.writer.insert(t3, n2.position), true);
            }
            _updateConversionResult(t3, e3) {
              const n2 = this._getSplitParts(t3), o2 = this.conversionApi.writer;
              e3.modelRange || (e3.modelRange = o2.createRange(o2.createPositionBefore(t3), o2.createPositionAfter(n2[n2.length - 1])));
              const i2 = this._cursorParents.get(t3);
              e3.modelCursor = i2 ? o2.createPositionAt(i2, 0) : e3.modelRange.end;
            }
            _splitToAllowedParent(t3, e3) {
              const { schema: n2, writer: o2 } = this.conversionApi;
              let i2 = n2.findAllowedParent(e3, t3);
              if (i2) {
                if (i2 === e3.parent)
                  return { position: e3 };
                this._modelCursor.parent.getAncestors().includes(i2) && (i2 = null);
              }
              if (!i2)
                return Ic(e3, t3, n2) ? { position: Mc(e3, o2) } : null;
              const r2 = this.conversionApi.writer.split(e3, i2), s2 = [];
              for (const t4 of r2.range.getWalker())
                if ("elementEnd" == t4.type)
                  s2.push(t4.item);
                else {
                  const e4 = s2.pop(), n3 = t4.item;
                  this._registerSplitPair(e4, n3);
                }
              const a2 = r2.range.end.parent;
              return this._cursorParents.set(t3, a2), { position: r2.position, cursorParent: a2 };
            }
            _registerSplitPair(t3, e3) {
              this._splitParts.has(t3) || this._splitParts.set(t3, [t3]);
              const n2 = this._splitParts.get(t3);
              this._splitParts.set(e3, n2), n2.push(e3);
            }
            _getSplitParts(t3) {
              let e3;
              return e3 = this._splitParts.has(t3) ? this._splitParts.get(t3) : [t3], e3;
            }
            _removeEmptyElements() {
              let t3 = false;
              for (const e3 of this._splitParts.keys())
                e3.isEmpty && (this.conversionApi.writer.remove(e3), this._splitParts.delete(e3), t3 = true);
              t3 && this._removeEmptyElements();
            }
          }
          he(nl, f);
          class ol {
            getHtml(t3) {
              const e3 = document.implementation.createHTMLDocument("").createElement("div");
              return e3.appendChild(t3), e3.innerHTML;
            }
          }
          class il {
            constructor(t3) {
              this.domParser = new DOMParser(), this.domConverter = new gs(t3, { renderingMode: "data" }), this.htmlWriter = new ol();
            }
            toData(t3) {
              const e3 = this.domConverter.viewToDom(t3, document);
              return this.htmlWriter.getHtml(e3);
            }
            toView(t3) {
              const e3 = this._toDom(t3);
              return this.domConverter.domToView(e3);
            }
            registerRawContentMatcher(t3) {
              this.domConverter.registerRawContentMatcher(t3);
            }
            useFillerType(t3) {
              this.domConverter.blockFillerMode = "marked" == t3 ? "markedNbsp" : "nbsp";
            }
            _toDom(t3) {
              t3.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (t3 = `<body>${t3}</body>`);
              const e3 = this.domParser.parseFromString(t3, "text/html"), n2 = e3.createDocumentFragment(), o2 = e3.body.childNodes;
              for (; o2.length > 0; )
                n2.appendChild(o2[0]);
              return n2;
            }
          }
          class rl {
            constructor(t3, e3) {
              this.model = t3, this.mapper = new Qa(), this.downcastDispatcher = new Za({ mapper: this.mapper, schema: t3.schema }), this.downcastDispatcher.on("insert:$text", (t4, e4, n2) => {
                if (!n2.consumable.consume(e4.item, t4.name))
                  return;
                const o2 = n2.writer, i2 = n2.mapper.toViewPosition(e4.range.start), r2 = o2.createText(e4.item.data);
                o2.insert(i2, r2);
              }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (t4, e4, n2) => {
                n2.convertAttributes(e4.item), e4.reconversion || !e4.item.is("element") || e4.item.isEmpty || n2.convertChildren(e4.item);
              }, { priority: "lowest" }), this.upcastDispatcher = new nl({ schema: t3.schema }), this.viewDocument = new Ji(e3), this.stylesProcessor = e3, this.htmlProcessor = new il(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new _r(this.viewDocument), this.upcastDispatcher.on("text", (t4, e4, { schema: n2, consumable: o2, writer: i2 }) => {
                let r2 = e4.modelCursor;
                if (!o2.test(e4.viewItem))
                  return;
                if (!n2.checkChild(r2, "$text")) {
                  if (!Ic(r2, "$text", n2))
                    return;
                  r2 = Mc(r2, i2);
                }
                o2.consume(e4.viewItem);
                const s2 = i2.createText(e4.viewItem.data);
                i2.insert(s2, r2), e4.modelRange = i2.createRange(r2, r2.getShiftedBy(s2.offsetSize)), e4.modelCursor = e4.modelRange.end;
              }, { priority: "lowest" }), this.upcastDispatcher.on("element", (t4, e4, n2) => {
                if (!e4.modelRange && n2.consumable.consume(e4.viewItem, { name: true })) {
                  const { modelRange: t5, modelCursor: o2 } = n2.convertChildren(e4.viewItem, e4.modelCursor);
                  e4.modelRange = t5, e4.modelCursor = o2;
                }
              }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (t4, e4, n2) => {
                if (!e4.modelRange && n2.consumable.consume(e4.viewItem, { name: true })) {
                  const { modelRange: t5, modelCursor: o2 } = n2.convertChildren(e4.viewItem, e4.modelCursor);
                  e4.modelRange = t5, e4.modelCursor = o2;
                }
              }, { priority: "lowest" }), this.decorate("init"), this.decorate("set"), this.decorate("get"), this.on("init", () => {
                this.fire("ready");
              }, { priority: "lowest" }), this.on("ready", () => {
                this.model.enqueueChange({ isUndoable: false }, Dc);
              }, { priority: "lowest" });
            }
            get(t3 = {}) {
              const { rootName: e3 = "main", trim: n2 = "empty" } = t3;
              if (!this._checkIfRootsExists([e3]))
                throw new a("datacontroller-get-non-existent-root", this);
              const o2 = this.model.document.getRoot(e3);
              return "empty" !== n2 || this.model.hasContent(o2, { ignoreWhitespaces: true }) ? this.stringify(o2, t3) : "";
            }
            stringify(t3, e3 = {}) {
              const n2 = this.toView(t3, e3);
              return this.processor.toData(n2);
            }
            toView(t3, e3 = {}) {
              const n2 = this.viewDocument, o2 = this._viewWriter;
              this.mapper.clearBindings();
              const i2 = Ya._createIn(t3), r2 = new Ar(n2);
              this.mapper.bindElements(t3, r2);
              const s2 = t3.is("documentFragment") ? t3.markers : function(t4) {
                const e4 = [], n3 = t4.root.document;
                if (!n3)
                  return /* @__PURE__ */ new Map();
                const o3 = Ya._createIn(t4);
                for (const t5 of n3.model.markers) {
                  const n4 = t5.getRange(), i3 = n4.isCollapsed, r3 = n4.start.isEqual(o3.start) || n4.end.isEqual(o3.end);
                  if (i3 && r3)
                    e4.push([t5.name, n4]);
                  else {
                    const i4 = o3.getIntersection(n4);
                    i4 && e4.push([t5.name, i4]);
                  }
                }
                return e4.sort(([t5, e5], [n4, o4]) => {
                  if ("after" !== e5.end.compareWith(o4.start))
                    return 1;
                  if ("before" !== e5.start.compareWith(o4.end))
                    return -1;
                  switch (e5.start.compareWith(o4.start)) {
                    case "before":
                      return 1;
                    case "after":
                      return -1;
                    default:
                      switch (e5.end.compareWith(o4.end)) {
                        case "before":
                          return 1;
                        case "after":
                          return -1;
                        default:
                          return n4.localeCompare(t5);
                      }
                  }
                }), new Map(e4);
              }(t3);
              return this.downcastDispatcher.convert(i2, s2, o2, e3), r2;
            }
            init(t3) {
              if (this.model.document.version)
                throw new a("datacontroller-init-document-not-empty", this);
              let e3 = {};
              if ("string" == typeof t3 ? e3.main = t3 : e3 = t3, !this._checkIfRootsExists(Object.keys(e3)))
                throw new a("datacontroller-init-non-existent-root", this);
              return this.model.enqueueChange({ isUndoable: false }, (t4) => {
                for (const n2 of Object.keys(e3)) {
                  const o2 = this.model.document.getRoot(n2);
                  t4.insert(this.parse(e3[n2], o2), o2, 0);
                }
              }), Promise.resolve();
            }
            set(t3, e3 = {}) {
              let n2 = {};
              if ("string" == typeof t3 ? n2.main = t3 : n2 = t3, !this._checkIfRootsExists(Object.keys(n2)))
                throw new a("datacontroller-set-non-existent-root", this);
              this.model.enqueueChange(e3.batchType || {}, (t4) => {
                t4.setSelection(null), t4.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                for (const e4 of Object.keys(n2)) {
                  const o2 = this.model.document.getRoot(e4);
                  t4.remove(t4.createRangeIn(o2)), t4.insert(this.parse(n2[e4], o2), o2, 0);
                }
              });
            }
            parse(t3, e3 = "$root") {
              const n2 = this.processor.toView(t3);
              return this.toModel(n2, e3);
            }
            toModel(t3, e3 = "$root") {
              return this.model.change((n2) => this.upcastDispatcher.convert(t3, n2, e3));
            }
            addStyleProcessorRules(t3) {
              t3(this.stylesProcessor);
            }
            registerRawContentMatcher(t3) {
              this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t3), this.htmlProcessor.registerRawContentMatcher(t3);
            }
            destroy() {
              this.stopListening();
            }
            _checkIfRootsExists(t3) {
              for (const e3 of t3)
                if (!this.model.document.getRootNames().includes(e3))
                  return false;
              return true;
            }
          }
          he(rl, re);
          class sl {
            constructor(t3, e3) {
              this._helpers = /* @__PURE__ */ new Map(), this._downcast = So(t3), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }), this._upcast = So(e3), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false });
            }
            addAlias(t3, e3) {
              const n2 = this._downcast.includes(e3);
              if (!this._upcast.includes(e3) && !n2)
                throw new a("conversion-add-alias-dispatcher-not-registered", this);
              this._createConversionHelpers({ name: t3, dispatchers: [e3], isDowncast: n2 });
            }
            for(t3) {
              if (!this._helpers.has(t3))
                throw new a("conversion-for-unknown-group", this);
              return this._helpers.get(t3);
            }
            elementToElement(t3) {
              this.for("downcast").elementToElement(t3);
              for (const { model: e3, view: n2 } of al(t3))
                this.for("upcast").elementToElement({ model: e3, view: n2, converterPriority: t3.converterPriority });
            }
            attributeToElement(t3) {
              this.for("downcast").attributeToElement(t3);
              for (const { model: e3, view: n2 } of al(t3))
                this.for("upcast").elementToAttribute({ view: n2, model: e3, converterPriority: t3.converterPriority });
            }
            attributeToAttribute(t3) {
              this.for("downcast").attributeToAttribute(t3);
              for (const { model: e3, view: n2 } of al(t3))
                this.for("upcast").attributeToAttribute({ view: n2, model: e3 });
            }
            _createConversionHelpers({ name: t3, dispatchers: e3, isDowncast: n2 }) {
              if (this._helpers.has(t3))
                throw new a("conversion-group-exists", this);
              const o2 = n2 ? new mc(e3) : new Sc(e3);
              this._helpers.set(t3, o2);
            }
          }
          function* al(t3) {
            if (t3.model.values)
              for (const e3 of t3.model.values) {
                const n2 = { key: t3.model.key, value: e3 }, o2 = t3.view[e3], i2 = t3.upcastAlso ? t3.upcastAlso[e3] : void 0;
                yield* cl(n2, o2, i2);
              }
            else
              yield* cl(t3.model, t3.view, t3.upcastAlso);
          }
          function* cl(t3, e3, n2) {
            if (yield { model: t3, view: e3 }, n2)
              for (const e4 of So(n2))
                yield { model: t3, view: e4 };
          }
          class ll {
            constructor(t3 = {}) {
              "string" == typeof t3 && (t3 = "transparent" === t3 ? { isUndoable: false } : {}, c("batch-constructor-deprecated-string-type"));
              const { isUndoable: e3 = true, isLocal: n2 = true, isUndo: o2 = false, isTyping: i2 = false } = t3;
              this.operations = [], this.isUndoable = e3, this.isLocal = n2, this.isUndo = o2, this.isTyping = i2;
            }
            get type() {
              return c("batch-type-deprecated"), "default";
            }
            get baseVersion() {
              for (const t3 of this.operations)
                if (null !== t3.baseVersion)
                  return t3.baseVersion;
              return null;
            }
            addOperation(t3) {
              return t3.batch = this, this.operations.push(t3), t3;
            }
          }
          class dl {
            constructor(t3) {
              this.baseVersion = t3, this.isDocumentOperation = null !== this.baseVersion, this.batch = null;
            }
            _validate() {
            }
            toJSON() {
              const t3 = Object.assign({}, this);
              return t3.__className = this.constructor.className, delete t3.batch, delete t3.isDocumentOperation, t3;
            }
            static get className() {
              return "Operation";
            }
            static fromJSON(t3) {
              return new this(t3.baseVersion);
            }
          }
          class hl {
            constructor(t3) {
              this.markers = /* @__PURE__ */ new Map(), this._children = new ja(), t3 && this._insertChild(0, t3);
            }
            [Symbol.iterator]() {
              return this.getChildren();
            }
            get childCount() {
              return this._children.length;
            }
            get maxOffset() {
              return this._children.maxOffset;
            }
            get isEmpty() {
              return 0 === this.childCount;
            }
            get root() {
              return this;
            }
            get parent() {
              return null;
            }
            is(t3) {
              return "documentFragment" === t3 || "model:documentFragment" === t3;
            }
            getChild(t3) {
              return this._children.getNode(t3);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            getChildIndex(t3) {
              return this._children.getNodeIndex(t3);
            }
            getChildStartOffset(t3) {
              return this._children.getNodeStartOffset(t3);
            }
            getPath() {
              return [];
            }
            getNodeByPath(t3) {
              let e3 = this;
              for (const n2 of t3)
                e3 = e3.getChild(e3.offsetToIndex(n2));
              return e3;
            }
            offsetToIndex(t3) {
              return this._children.offsetToIndex(t3);
            }
            toJSON() {
              const t3 = [];
              for (const e3 of this._children)
                t3.push(e3.toJSON());
              return t3;
            }
            static fromJSON(t3) {
              const e3 = [];
              for (const n2 of t3)
                n2.name ? e3.push(Fa.fromJSON(n2)) : e3.push(Oa.fromJSON(n2));
              return new hl(e3);
            }
            _appendChild(t3) {
              this._insertChild(this.childCount, t3);
            }
            _insertChild(t3, e3) {
              const n2 = function(t4) {
                if ("string" == typeof t4)
                  return [new Oa(t4)];
                Do(t4) || (t4 = [t4]);
                return Array.from(t4).map((t5) => "string" == typeof t5 ? new Oa(t5) : t5 instanceof Ra ? new Oa(t5.data, t5.getAttributes()) : t5);
              }(e3);
              for (const t4 of n2)
                null !== t4.parent && t4._remove(), t4.parent = this;
              this._children._insertNodes(t3, n2);
            }
            _removeChildren(t3, e3 = 1) {
              const n2 = this._children._removeNodes(t3, e3);
              for (const t4 of n2)
                t4.parent = null;
              return n2;
            }
          }
          function ul(t3, e3) {
            const n2 = (e3 = pl(e3)).reduce((t4, e4) => t4 + e4.offsetSize, 0), o2 = t3.parent;
            kl(t3);
            const i2 = t3.index;
            return o2._insertChild(i2, e3), fl(o2, i2 + e3.length), fl(o2, i2), new Ya(t3, t3.getShiftedBy(n2));
          }
          function gl(t3) {
            if (!t3.isFlat)
              throw new a("operation-utils-remove-range-not-flat", this);
            const e3 = t3.start.parent;
            kl(t3.start), kl(t3.end);
            const n2 = e3._removeChildren(t3.start.index, t3.end.index - t3.start.index);
            return fl(e3, t3.start.index), n2;
          }
          function ml(t3, e3) {
            if (!t3.isFlat)
              throw new a("operation-utils-move-range-not-flat", this);
            const n2 = gl(t3);
            return ul(e3 = e3._getTransformedByDeletion(t3.start, t3.end.offset - t3.start.offset), n2);
          }
          function pl(t3) {
            const e3 = [];
            t3 instanceof Array || (t3 = [t3]);
            for (let n2 = 0; n2 < t3.length; n2++)
              if ("string" == typeof t3[n2])
                e3.push(new Oa(t3[n2]));
              else if (t3[n2] instanceof Ra)
                e3.push(new Oa(t3[n2].data, t3[n2].getAttributes()));
              else if (t3[n2] instanceof hl || t3[n2] instanceof ja)
                for (const o2 of t3[n2])
                  e3.push(o2);
              else
                t3[n2] instanceof La && e3.push(t3[n2]);
            for (let t4 = 1; t4 < e3.length; t4++) {
              const n2 = e3[t4], o2 = e3[t4 - 1];
              n2 instanceof Oa && o2 instanceof Oa && bl(n2, o2) && (e3.splice(t4 - 1, 2, new Oa(o2.data + n2.data, o2.getAttributes())), t4--);
            }
            return e3;
          }
          function fl(t3, e3) {
            const n2 = t3.getChild(e3 - 1), o2 = t3.getChild(e3);
            if (n2 && o2 && n2.is("$text") && o2.is("$text") && bl(n2, o2)) {
              const i2 = new Oa(n2.data + o2.data, n2.getAttributes());
              t3._removeChildren(e3 - 1, 2), t3._insertChild(e3 - 1, i2);
            }
          }
          function kl(t3) {
            const e3 = t3.textNode, n2 = t3.parent;
            if (e3) {
              const o2 = t3.offset - e3.startOffset, i2 = e3.index;
              n2._removeChildren(i2, 1);
              const r2 = new Oa(e3.data.substr(0, o2), e3.getAttributes()), s2 = new Oa(e3.data.substr(o2), e3.getAttributes());
              n2._insertChild(i2, [r2, s2]);
            }
          }
          function bl(t3, e3) {
            const n2 = t3.getAttributes(), o2 = e3.getAttributes();
            for (const t4 of n2) {
              if (t4[1] !== e3.getAttribute(t4[0]))
                return false;
              o2.next();
            }
            return o2.next().done;
          }
          const wl = function(t3, e3) {
            return Us(t3, e3);
          };
          class Cl extends dl {
            constructor(t3, e3, n2, o2, i2) {
              super(i2), this.range = t3.clone(), this.key = e3, this.oldValue = void 0 === n2 ? null : n2, this.newValue = void 0 === o2 ? null : o2;
            }
            get type() {
              return null === this.oldValue ? "addAttribute" : null === this.newValue ? "removeAttribute" : "changeAttribute";
            }
            clone() {
              return new Cl(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
            }
            getReversed() {
              return new Cl(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.range = this.range.toJSON(), t3;
            }
            _validate() {
              if (!this.range.isFlat)
                throw new a("attribute-operation-range-not-flat", this);
              for (const t3 of this.range.getItems({ shallow: true })) {
                if (null !== this.oldValue && !wl(t3.getAttribute(this.key), this.oldValue))
                  throw new a("attribute-operation-wrong-old-value", this, { item: t3, key: this.key, value: this.oldValue });
                if (null === this.oldValue && null !== this.newValue && t3.hasAttribute(this.key))
                  throw new a("attribute-operation-attribute-exists", this, { node: t3, key: this.key });
              }
            }
            _execute() {
              wl(this.oldValue, this.newValue) || function(t3, e3, n2) {
                kl(t3.start), kl(t3.end);
                for (const o2 of t3.getItems({ shallow: true })) {
                  const t4 = o2.is("$textProxy") ? o2.textNode : o2;
                  null !== n2 ? t4._setAttribute(e3, n2) : t4._removeAttribute(e3), fl(t4.parent, t4.index);
                }
                fl(t3.end.parent, t3.end.index);
              }(this.range, this.key, this.newValue);
            }
            static get className() {
              return "AttributeOperation";
            }
            static fromJSON(t3, e3) {
              return new Cl(Ya.fromJSON(t3.range, e3), t3.key, t3.oldValue, t3.newValue, t3.baseVersion);
            }
          }
          class Al extends dl {
            constructor(t3, e3) {
              super(null), this.sourcePosition = t3.clone(), this.howMany = e3;
            }
            get type() {
              return "detach";
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.sourcePosition = this.sourcePosition.toJSON(), t3;
            }
            _validate() {
              if (this.sourcePosition.root.document)
                throw new a("detach-operation-on-document-node", this);
            }
            _execute() {
              gl(Ya._createFromPositionAndShift(this.sourcePosition, this.howMany));
            }
            static get className() {
              return "DetachOperation";
            }
          }
          class _l extends dl {
            constructor(t3, e3, n2, o2) {
              super(o2), this.sourcePosition = t3.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e3, this.targetPosition = n2.clone(), this.targetPosition.stickiness = "toNone";
            }
            get type() {
              return "$graveyard" == this.targetPosition.root.rootName ? "remove" : "$graveyard" == this.sourcePosition.root.rootName ? "reinsert" : "move";
            }
            clone() {
              return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
            }
            getMovedRangeStart() {
              return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
            }
            getReversed() {
              const t3 = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
              return new this.constructor(this.getMovedRangeStart(), this.howMany, t3, this.baseVersion + 1);
            }
            _validate() {
              const t3 = this.sourcePosition.parent, e3 = this.targetPosition.parent, n2 = this.sourcePosition.offset, o2 = this.targetPosition.offset;
              if (n2 + this.howMany > t3.maxOffset)
                throw new a("move-operation-nodes-do-not-exist", this);
              if (t3 === e3 && n2 < o2 && o2 < n2 + this.howMany)
                throw new a("move-operation-range-into-itself", this);
              if (this.sourcePosition.root == this.targetPosition.root && "prefix" == Oo(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())) {
                const t4 = this.sourcePosition.path.length - 1;
                if (this.targetPosition.path[t4] >= n2 && this.targetPosition.path[t4] < n2 + this.howMany)
                  throw new a("move-operation-node-into-itself", this);
              }
            }
            _execute() {
              ml(Ya._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.sourcePosition = this.sourcePosition.toJSON(), t3.targetPosition = this.targetPosition.toJSON(), t3;
            }
            static get className() {
              return "MoveOperation";
            }
            static fromJSON(t3, e3) {
              const n2 = Ha.fromJSON(t3.sourcePosition, e3), o2 = Ha.fromJSON(t3.targetPosition, e3);
              return new this(n2, t3.howMany, o2, t3.baseVersion);
            }
          }
          class vl extends dl {
            constructor(t3, e3, n2) {
              super(n2), this.position = t3.clone(), this.position.stickiness = "toNone", this.nodes = new ja(pl(e3)), this.shouldReceiveAttributes = false;
            }
            get type() {
              return "insert";
            }
            get howMany() {
              return this.nodes.maxOffset;
            }
            clone() {
              const t3 = new ja([...this.nodes].map((t4) => t4._clone(true))), e3 = new vl(this.position, t3, this.baseVersion);
              return e3.shouldReceiveAttributes = this.shouldReceiveAttributes, e3;
            }
            getReversed() {
              const t3 = this.position.root.document.graveyard, e3 = new Ha(t3, [0]);
              return new _l(this.position, this.nodes.maxOffset, e3, this.baseVersion + 1);
            }
            _validate() {
              const t3 = this.position.parent;
              if (!t3 || t3.maxOffset < this.position.offset)
                throw new a("insert-operation-position-invalid", this);
            }
            _execute() {
              const t3 = this.nodes;
              this.nodes = new ja([...t3].map((t4) => t4._clone(true))), ul(this.position, t3);
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.position = this.position.toJSON(), t3.nodes = this.nodes.toJSON(), t3;
            }
            static get className() {
              return "InsertOperation";
            }
            static fromJSON(t3, e3) {
              const n2 = [];
              for (const e4 of t3.nodes)
                e4.name ? n2.push(Fa.fromJSON(e4)) : n2.push(Oa.fromJSON(e4));
              const o2 = new vl(Ha.fromJSON(t3.position, e3), n2, t3.baseVersion);
              return o2.shouldReceiveAttributes = t3.shouldReceiveAttributes, o2;
            }
          }
          class yl extends dl {
            constructor(t3, e3, n2, o2, i2, r2) {
              super(r2), this.name = t3, this.oldRange = e3 ? e3.clone() : null, this.newRange = n2 ? n2.clone() : null, this.affectsData = i2, this._markers = o2;
            }
            get type() {
              return "marker";
            }
            clone() {
              return new yl(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
            }
            getReversed() {
              return new yl(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
            }
            _execute() {
              const t3 = this.newRange ? "_set" : "_remove";
              this._markers[t3](this.name, this.newRange, true, this.affectsData);
            }
            toJSON() {
              const t3 = super.toJSON();
              return this.oldRange && (t3.oldRange = this.oldRange.toJSON()), this.newRange && (t3.newRange = this.newRange.toJSON()), delete t3._markers, t3;
            }
            static get className() {
              return "MarkerOperation";
            }
            static fromJSON(t3, e3) {
              return new yl(t3.name, t3.oldRange ? Ya.fromJSON(t3.oldRange, e3) : null, t3.newRange ? Ya.fromJSON(t3.newRange, e3) : null, e3.model.markers, t3.affectsData, t3.baseVersion);
            }
          }
          class xl extends dl {
            constructor(t3, e3, n2, o2) {
              super(o2), this.position = t3, this.position.stickiness = "toNext", this.oldName = e3, this.newName = n2;
            }
            get type() {
              return "rename";
            }
            clone() {
              return new xl(this.position.clone(), this.oldName, this.newName, this.baseVersion);
            }
            getReversed() {
              return new xl(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
            }
            _validate() {
              const t3 = this.position.nodeAfter;
              if (!(t3 instanceof Fa))
                throw new a("rename-operation-wrong-position", this);
              if (t3.name !== this.oldName)
                throw new a("rename-operation-wrong-name", this);
            }
            _execute() {
              this.position.nodeAfter.name = this.newName;
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.position = this.position.toJSON(), t3;
            }
            static get className() {
              return "RenameOperation";
            }
            static fromJSON(t3, e3) {
              return new xl(Ha.fromJSON(t3.position, e3), t3.oldName, t3.newName, t3.baseVersion);
            }
          }
          class El extends dl {
            constructor(t3, e3, n2, o2, i2) {
              super(i2), this.root = t3, this.key = e3, this.oldValue = n2, this.newValue = o2;
            }
            get type() {
              return null === this.oldValue ? "addRootAttribute" : null === this.newValue ? "removeRootAttribute" : "changeRootAttribute";
            }
            clone() {
              return new El(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
            }
            getReversed() {
              return new El(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
            }
            _validate() {
              if (this.root != this.root.root || this.root.is("documentFragment"))
                throw new a("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
              if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue)
                throw new a("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
              if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key))
                throw new a("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
            }
            _execute() {
              null !== this.newValue ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.root = this.root.toJSON(), t3;
            }
            static get className() {
              return "RootAttributeOperation";
            }
            static fromJSON(t3, e3) {
              if (!e3.getRoot(t3.root))
                throw new a("rootattribute-operation-fromjson-no-root", this, { rootName: t3.root });
              return new El(e3.getRoot(t3.root), t3.key, t3.oldValue, t3.newValue, t3.baseVersion);
            }
          }
          class Dl extends dl {
            constructor(t3, e3, n2, o2, i2) {
              super(i2), this.sourcePosition = t3.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e3, this.targetPosition = n2.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = o2.clone();
            }
            get type() {
              return "merge";
            }
            get deletionPosition() {
              return new Ha(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
            }
            get movedRange() {
              const t3 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
              return new Ya(this.sourcePosition, t3);
            }
            clone() {
              return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
            }
            getReversed() {
              const t3 = this.targetPosition._getTransformedByMergeOperation(this), e3 = this.sourcePosition.path.slice(0, -1), n2 = new Ha(this.sourcePosition.root, e3)._getTransformedByMergeOperation(this);
              return new Il(t3, this.howMany, n2, this.graveyardPosition, this.baseVersion + 1);
            }
            _validate() {
              const t3 = this.sourcePosition.parent, e3 = this.targetPosition.parent;
              if (!t3.parent)
                throw new a("merge-operation-source-position-invalid", this);
              if (!e3.parent)
                throw new a("merge-operation-target-position-invalid", this);
              if (this.howMany != t3.maxOffset)
                throw new a("merge-operation-how-many-invalid", this);
            }
            _execute() {
              const t3 = this.sourcePosition.parent;
              ml(Ya._createIn(t3), this.targetPosition), ml(Ya._createOn(t3), this.graveyardPosition);
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.sourcePosition = t3.sourcePosition.toJSON(), t3.targetPosition = t3.targetPosition.toJSON(), t3.graveyardPosition = t3.graveyardPosition.toJSON(), t3;
            }
            static get className() {
              return "MergeOperation";
            }
            static fromJSON(t3, e3) {
              const n2 = Ha.fromJSON(t3.sourcePosition, e3), o2 = Ha.fromJSON(t3.targetPosition, e3), i2 = Ha.fromJSON(t3.graveyardPosition, e3);
              return new this(n2, t3.howMany, o2, i2, t3.baseVersion);
            }
          }
          class Il extends dl {
            constructor(t3, e3, n2, o2, i2) {
              super(i2), this.splitPosition = t3.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e3, this.insertionPosition = n2, this.graveyardPosition = o2 ? o2.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
            }
            get type() {
              return "split";
            }
            get moveTargetPosition() {
              const t3 = this.insertionPosition.path.slice();
              return t3.push(0), new Ha(this.insertionPosition.root, t3);
            }
            get movedRange() {
              const t3 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
              return new Ya(this.splitPosition, t3);
            }
            clone() {
              return new this.constructor(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
            }
            getReversed() {
              const t3 = this.splitPosition.root.document.graveyard, e3 = new Ha(t3, [0]);
              return new Dl(this.moveTargetPosition, this.howMany, this.splitPosition, e3, this.baseVersion + 1);
            }
            _validate() {
              const t3 = this.splitPosition.parent, e3 = this.splitPosition.offset;
              if (!t3 || t3.maxOffset < e3)
                throw new a("split-operation-position-invalid", this);
              if (!t3.parent)
                throw new a("split-operation-split-in-root", this);
              if (this.howMany != t3.maxOffset - this.splitPosition.offset)
                throw new a("split-operation-how-many-invalid", this);
              if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
                throw new a("split-operation-graveyard-position-invalid", this);
            }
            _execute() {
              const t3 = this.splitPosition.parent;
              if (this.graveyardPosition)
                ml(Ya._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
              else {
                const e3 = t3._clone();
                ul(this.insertionPosition, e3);
              }
              ml(new Ya(Ha._createAt(t3, this.splitPosition.offset), Ha._createAt(t3, t3.maxOffset)), this.moveTargetPosition);
            }
            toJSON() {
              const t3 = super.toJSON();
              return t3.splitPosition = this.splitPosition.toJSON(), t3.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t3.graveyardPosition = this.graveyardPosition.toJSON()), t3;
            }
            static get className() {
              return "SplitOperation";
            }
            static getInsertionPosition(t3) {
              const e3 = t3.path.slice(0, -1);
              return e3[e3.length - 1]++, new Ha(t3.root, e3, "toPrevious");
            }
            static fromJSON(t3, e3) {
              const n2 = Ha.fromJSON(t3.splitPosition, e3), o2 = Ha.fromJSON(t3.insertionPosition, e3), i2 = t3.graveyardPosition ? Ha.fromJSON(t3.graveyardPosition, e3) : null;
              return new this(n2, t3.howMany, o2, i2, t3.baseVersion);
            }
          }
          class Ml extends Fa {
            constructor(t3, e3, n2 = "main") {
              super(e3), this._document = t3, this.rootName = n2;
            }
            get document() {
              return this._document;
            }
            is(t3, e3) {
              return e3 ? e3 === this.name && ("rootElement" === t3 || "model:rootElement" === t3 || "element" === t3 || "model:element" === t3) : "rootElement" === t3 || "model:rootElement" === t3 || "element" === t3 || "model:element" === t3 || "node" === t3 || "model:node" === t3;
            }
            toJSON() {
              return this.rootName;
            }
          }
          class Sl {
            constructor(t3, e3) {
              this.model = t3, this.batch = e3;
            }
            createText(t3, e3) {
              return new Oa(t3, e3);
            }
            createElement(t3, e3) {
              return new Fa(t3, e3);
            }
            createDocumentFragment() {
              return new hl();
            }
            cloneElement(t3, e3 = true) {
              return t3._clone(e3);
            }
            insert(t3, e3, n2 = 0) {
              if (this._assertWriterUsedCorrectly(), t3 instanceof Oa && "" == t3.data)
                return;
              const o2 = Ha._createAt(e3, n2);
              if (t3.parent) {
                if (Pl(t3.root, o2.root))
                  return void this.move(Ya._createOn(t3), o2);
                if (t3.root.document)
                  throw new a("model-writer-insert-forbidden-move", this);
                this.remove(t3);
              }
              const i2 = o2.root.document ? o2.root.document.version : null, r2 = new vl(o2, t3, i2);
              if (t3 instanceof Oa && (r2.shouldReceiveAttributes = true), this.batch.addOperation(r2), this.model.applyOperation(r2), t3 instanceof hl)
                for (const [e4, n3] of t3.markers) {
                  const t4 = Ha._createAt(n3.root, 0), i3 = { range: new Ya(n3.start._getCombined(t4, o2), n3.end._getCombined(t4, o2)), usingOperation: true, affectsData: true };
                  this.model.markers.has(e4) ? this.updateMarker(e4, i3) : this.addMarker(e4, i3);
                }
            }
            insertText(t3, e3, n2, o2) {
              e3 instanceof hl || e3 instanceof Fa || e3 instanceof Ha ? this.insert(this.createText(t3), e3, n2) : this.insert(this.createText(t3, e3), n2, o2);
            }
            insertElement(t3, e3, n2, o2) {
              e3 instanceof hl || e3 instanceof Fa || e3 instanceof Ha ? this.insert(this.createElement(t3), e3, n2) : this.insert(this.createElement(t3, e3), n2, o2);
            }
            append(t3, e3) {
              this.insert(t3, e3, "end");
            }
            appendText(t3, e3, n2) {
              e3 instanceof hl || e3 instanceof Fa ? this.insert(this.createText(t3), e3, "end") : this.insert(this.createText(t3, e3), n2, "end");
            }
            appendElement(t3, e3, n2) {
              e3 instanceof hl || e3 instanceof Fa ? this.insert(this.createElement(t3), e3, "end") : this.insert(this.createElement(t3, e3), n2, "end");
            }
            setAttribute(t3, e3, n2) {
              if (this._assertWriterUsedCorrectly(), n2 instanceof Ya) {
                const o2 = n2.getMinimalFlatRanges();
                for (const n3 of o2)
                  Tl(this, t3, e3, n3);
              } else
                Nl(this, t3, e3, n2);
            }
            setAttributes(t3, e3) {
              for (const [n2, o2] of Uo(t3))
                this.setAttribute(n2, o2, e3);
            }
            removeAttribute(t3, e3) {
              if (this._assertWriterUsedCorrectly(), e3 instanceof Ya) {
                const n2 = e3.getMinimalFlatRanges();
                for (const e4 of n2)
                  Tl(this, t3, null, e4);
              } else
                Nl(this, t3, null, e3);
            }
            clearAttributes(t3) {
              this._assertWriterUsedCorrectly();
              const e3 = (t4) => {
                for (const e4 of t4.getAttributeKeys())
                  this.removeAttribute(e4, t4);
              };
              if (t3 instanceof Ya)
                for (const n2 of t3.getItems())
                  e3(n2);
              else
                e3(t3);
            }
            move(t3, e3, n2) {
              if (this._assertWriterUsedCorrectly(), !(t3 instanceof Ya))
                throw new a("writer-move-invalid-range", this);
              if (!t3.isFlat)
                throw new a("writer-move-range-not-flat", this);
              const o2 = Ha._createAt(e3, n2);
              if (o2.isEqual(t3.start))
                return;
              if (this._addOperationForAffectedMarkers("move", t3), !Pl(t3.root, o2.root))
                throw new a("writer-move-different-document", this);
              const i2 = t3.root.document ? t3.root.document.version : null, r2 = new _l(t3.start, t3.end.offset - t3.start.offset, o2, i2);
              this.batch.addOperation(r2), this.model.applyOperation(r2);
            }
            remove(t3) {
              this._assertWriterUsedCorrectly();
              const e3 = (t3 instanceof Ya ? t3 : Ya._createOn(t3)).getMinimalFlatRanges().reverse();
              for (const t4 of e3)
                this._addOperationForAffectedMarkers("move", t4), zl(t4.start, t4.end.offset - t4.start.offset, this.batch, this.model);
            }
            merge(t3) {
              this._assertWriterUsedCorrectly();
              const e3 = t3.nodeBefore, n2 = t3.nodeAfter;
              if (this._addOperationForAffectedMarkers("merge", t3), !(e3 instanceof Fa))
                throw new a("writer-merge-no-element-before", this);
              if (!(n2 instanceof Fa))
                throw new a("writer-merge-no-element-after", this);
              t3.root.document ? this._merge(t3) : this._mergeDetached(t3);
            }
            createPositionFromPath(t3, e3, n2) {
              return this.model.createPositionFromPath(t3, e3, n2);
            }
            createPositionAt(t3, e3) {
              return this.model.createPositionAt(t3, e3);
            }
            createPositionAfter(t3) {
              return this.model.createPositionAfter(t3);
            }
            createPositionBefore(t3) {
              return this.model.createPositionBefore(t3);
            }
            createRange(t3, e3) {
              return this.model.createRange(t3, e3);
            }
            createRangeIn(t3) {
              return this.model.createRangeIn(t3);
            }
            createRangeOn(t3) {
              return this.model.createRangeOn(t3);
            }
            createSelection(t3, e3, n2) {
              return this.model.createSelection(t3, e3, n2);
            }
            _mergeDetached(t3) {
              const e3 = t3.nodeBefore, n2 = t3.nodeAfter;
              this.move(Ya._createIn(n2), Ha._createAt(e3, "end")), this.remove(n2);
            }
            _merge(t3) {
              const e3 = Ha._createAt(t3.nodeBefore, "end"), n2 = Ha._createAt(t3.nodeAfter, 0), o2 = t3.root.document.graveyard, i2 = new Ha(o2, [0]), r2 = t3.root.document.version, s2 = new Dl(n2, t3.nodeAfter.maxOffset, e3, i2, r2);
              this.batch.addOperation(s2), this.model.applyOperation(s2);
            }
            rename(t3, e3) {
              if (this._assertWriterUsedCorrectly(), !(t3 instanceof Fa))
                throw new a("writer-rename-not-element-instance", this);
              const n2 = t3.root.document ? t3.root.document.version : null, o2 = new xl(Ha._createBefore(t3), t3.name, e3, n2);
              this.batch.addOperation(o2), this.model.applyOperation(o2);
            }
            split(t3, e3) {
              this._assertWriterUsedCorrectly();
              let n2, o2, i2 = t3.parent;
              if (!i2.parent)
                throw new a("writer-split-element-no-parent", this);
              if (e3 || (e3 = i2.parent), !t3.parent.getAncestors({ includeSelf: true }).includes(e3))
                throw new a("writer-split-invalid-limit-element", this);
              do {
                const e4 = i2.root.document ? i2.root.document.version : null, r2 = i2.maxOffset - t3.offset, s2 = Il.getInsertionPosition(t3), a2 = new Il(t3, r2, s2, null, e4);
                this.batch.addOperation(a2), this.model.applyOperation(a2), n2 || o2 || (n2 = i2, o2 = t3.parent.nextSibling), i2 = (t3 = this.createPositionAfter(t3.parent)).parent;
              } while (i2 !== e3);
              return { position: t3, range: new Ya(Ha._createAt(n2, "end"), Ha._createAt(o2, 0)) };
            }
            wrap(t3, e3) {
              if (this._assertWriterUsedCorrectly(), !t3.isFlat)
                throw new a("writer-wrap-range-not-flat", this);
              const n2 = e3 instanceof Fa ? e3 : new Fa(e3);
              if (n2.childCount > 0)
                throw new a("writer-wrap-element-not-empty", this);
              if (null !== n2.parent)
                throw new a("writer-wrap-element-attached", this);
              this.insert(n2, t3.start);
              const o2 = new Ya(t3.start.getShiftedBy(1), t3.end.getShiftedBy(1));
              this.move(o2, Ha._createAt(n2, 0));
            }
            unwrap(t3) {
              if (this._assertWriterUsedCorrectly(), null === t3.parent)
                throw new a("writer-unwrap-element-no-parent", this);
              this.move(Ya._createIn(t3), this.createPositionAfter(t3)), this.remove(t3);
            }
            addMarker(t3, e3) {
              if (this._assertWriterUsedCorrectly(), !e3 || "boolean" != typeof e3.usingOperation)
                throw new a("writer-addmarker-no-usingoperation", this);
              const n2 = e3.usingOperation, o2 = e3.range, i2 = void 0 !== e3.affectsData && e3.affectsData;
              if (this.model.markers.has(t3))
                throw new a("writer-addmarker-marker-exists", this);
              if (!o2)
                throw new a("writer-addmarker-no-range", this);
              return n2 ? (Bl(this, t3, null, o2, i2), this.model.markers.get(t3)) : this.model.markers._set(t3, o2, n2, i2);
            }
            updateMarker(t3, e3) {
              this._assertWriterUsedCorrectly();
              const n2 = "string" == typeof t3 ? t3 : t3.name, o2 = this.model.markers.get(n2);
              if (!o2)
                throw new a("writer-updatemarker-marker-not-exists", this);
              if (!e3)
                return c("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n2 }), void this.model.markers._refresh(o2);
              const i2 = "boolean" == typeof e3.usingOperation, r2 = "boolean" == typeof e3.affectsData, s2 = r2 ? e3.affectsData : o2.affectsData;
              if (!i2 && !e3.range && !r2)
                throw new a("writer-updatemarker-wrong-options", this);
              const l2 = o2.getRange(), d2 = e3.range ? e3.range : l2;
              i2 && e3.usingOperation !== o2.managedUsingOperations ? e3.usingOperation ? Bl(this, n2, null, d2, s2) : (Bl(this, n2, l2, null, s2), this.model.markers._set(n2, d2, void 0, s2)) : o2.managedUsingOperations ? Bl(this, n2, l2, d2, s2) : this.model.markers._set(n2, d2, void 0, s2);
            }
            removeMarker(t3) {
              this._assertWriterUsedCorrectly();
              const e3 = "string" == typeof t3 ? t3 : t3.name;
              if (!this.model.markers.has(e3))
                throw new a("writer-removemarker-no-marker", this);
              const n2 = this.model.markers.get(e3);
              if (!n2.managedUsingOperations)
                return void this.model.markers._remove(e3);
              Bl(this, e3, n2.getRange(), null, n2.affectsData);
            }
            setSelection(t3, e3, n2) {
              this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(t3, e3, n2);
            }
            setSelectionFocus(t3, e3) {
              this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t3, e3);
            }
            setSelectionAttribute(t3, e3) {
              if (this._assertWriterUsedCorrectly(), "string" == typeof t3)
                this._setSelectionAttribute(t3, e3);
              else
                for (const [e4, n2] of Uo(t3))
                  this._setSelectionAttribute(e4, n2);
            }
            removeSelectionAttribute(t3) {
              if (this._assertWriterUsedCorrectly(), "string" == typeof t3)
                this._removeSelectionAttribute(t3);
              else
                for (const e3 of t3)
                  this._removeSelectionAttribute(e3);
            }
            overrideSelectionGravity() {
              return this.model.document.selection._overrideGravity();
            }
            restoreSelectionGravity(t3) {
              this.model.document.selection._restoreGravity(t3);
            }
            _setSelectionAttribute(t3, e3) {
              const n2 = this.model.document.selection;
              if (n2.isCollapsed && n2.anchor.parent.isEmpty) {
                const o2 = lc._getStoreAttributeKey(t3);
                this.setAttribute(o2, e3, n2.anchor.parent);
              }
              n2._setAttribute(t3, e3);
            }
            _removeSelectionAttribute(t3) {
              const e3 = this.model.document.selection;
              if (e3.isCollapsed && e3.anchor.parent.isEmpty) {
                const n2 = lc._getStoreAttributeKey(t3);
                this.removeAttribute(n2, e3.anchor.parent);
              }
              e3._removeAttribute(t3);
            }
            _assertWriterUsedCorrectly() {
              if (this.model._currentWriter !== this)
                throw new a("writer-incorrect-use", this);
            }
            _addOperationForAffectedMarkers(t3, e3) {
              for (const n2 of this.model.markers) {
                if (!n2.managedUsingOperations)
                  continue;
                const o2 = n2.getRange();
                let i2 = false;
                if ("move" === t3)
                  i2 = e3.containsPosition(o2.start) || e3.start.isEqual(o2.start) || e3.containsPosition(o2.end) || e3.end.isEqual(o2.end);
                else {
                  const t4 = e3.nodeBefore, n3 = e3.nodeAfter, r2 = o2.start.parent == t4 && o2.start.isAtEnd, s2 = o2.end.parent == n3 && 0 == o2.end.offset, a2 = o2.end.nodeAfter == n3, c2 = o2.start.nodeAfter == n3;
                  i2 = r2 || s2 || a2 || c2;
                }
                i2 && this.updateMarker(n2.name, { range: o2 });
              }
            }
          }
          function Tl(t3, e3, n2, o2) {
            const i2 = t3.model, r2 = i2.document;
            let s2, a2, c2, l2 = o2.start;
            for (const t4 of o2.getWalker({ shallow: true }))
              c2 = t4.item.getAttribute(e3), s2 && a2 != c2 && (a2 != n2 && d2(), l2 = s2), s2 = t4.nextPosition, a2 = c2;
            function d2() {
              const o3 = new Ya(l2, s2), c3 = o3.root.document ? r2.version : null, d3 = new Cl(o3, e3, a2, n2, c3);
              t3.batch.addOperation(d3), i2.applyOperation(d3);
            }
            s2 instanceof Ha && s2 != l2 && a2 != n2 && d2();
          }
          function Nl(t3, e3, n2, o2) {
            const i2 = t3.model, r2 = i2.document, s2 = o2.getAttribute(e3);
            let a2, c2;
            if (s2 != n2) {
              if (o2.root === o2) {
                const t4 = o2.document ? r2.version : null;
                c2 = new El(o2, e3, s2, n2, t4);
              } else {
                a2 = new Ya(Ha._createBefore(o2), t3.createPositionAfter(o2));
                const i3 = a2.root.document ? r2.version : null;
                c2 = new Cl(a2, e3, s2, n2, i3);
              }
              t3.batch.addOperation(c2), i2.applyOperation(c2);
            }
          }
          function Bl(t3, e3, n2, o2, i2) {
            const r2 = t3.model, s2 = r2.document, a2 = new yl(e3, n2, o2, r2.markers, i2, s2.version);
            t3.batch.addOperation(a2), r2.applyOperation(a2);
          }
          function zl(t3, e3, n2, o2) {
            let i2;
            if (t3.root.document) {
              const n3 = o2.document, r2 = new Ha(n3.graveyard, [0]);
              i2 = new _l(t3, e3, r2, n3.version);
            } else
              i2 = new Al(t3, e3);
            n2.addOperation(i2), o2.applyOperation(i2);
          }
          function Pl(t3, e3) {
            return t3 === e3 || t3 instanceof Ml && e3 instanceof Ml;
          }
          class Ll {
            constructor(t3) {
              this._markerCollection = t3, this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set();
            }
            get isEmpty() {
              return 0 == this._changesInElement.size && 0 == this._changedMarkers.size;
            }
            bufferOperation(t3) {
              switch (t3.type) {
                case "insert":
                  if (this._isInInsertedElement(t3.position.parent))
                    return;
                  this._markInsert(t3.position.parent, t3.position.offset, t3.nodes.maxOffset);
                  break;
                case "addAttribute":
                case "removeAttribute":
                case "changeAttribute":
                  for (const e3 of t3.range.getItems({ shallow: true }))
                    this._isInInsertedElement(e3.parent) || this._markAttribute(e3);
                  break;
                case "remove":
                case "move":
                case "reinsert": {
                  if (t3.sourcePosition.isEqual(t3.targetPosition) || t3.sourcePosition.getShiftedBy(t3.howMany).isEqual(t3.targetPosition))
                    return;
                  const e3 = this._isInInsertedElement(t3.sourcePosition.parent), n2 = this._isInInsertedElement(t3.targetPosition.parent);
                  e3 || this._markRemove(t3.sourcePosition.parent, t3.sourcePosition.offset, t3.howMany), n2 || this._markInsert(t3.targetPosition.parent, t3.getMovedRangeStart().offset, t3.howMany);
                  break;
                }
                case "rename": {
                  if (this._isInInsertedElement(t3.position.parent))
                    return;
                  this._markRemove(t3.position.parent, t3.position.offset, 1), this._markInsert(t3.position.parent, t3.position.offset, 1);
                  const e3 = Ya._createFromPositionAndShift(t3.position, 1);
                  for (const t4 of this._markerCollection.getMarkersIntersectingRange(e3)) {
                    const e4 = t4.getData();
                    this.bufferMarkerChange(t4.name, e4, e4);
                  }
                  break;
                }
                case "split": {
                  const e3 = t3.splitPosition.parent;
                  this._isInInsertedElement(e3) || this._markRemove(e3, t3.splitPosition.offset, t3.howMany), this._isInInsertedElement(t3.insertionPosition.parent) || this._markInsert(t3.insertionPosition.parent, t3.insertionPosition.offset, 1), t3.graveyardPosition && this._markRemove(t3.graveyardPosition.parent, t3.graveyardPosition.offset, 1);
                  break;
                }
                case "merge": {
                  const e3 = t3.sourcePosition.parent;
                  this._isInInsertedElement(e3.parent) || this._markRemove(e3.parent, e3.startOffset, 1);
                  const n2 = t3.graveyardPosition.parent;
                  this._markInsert(n2, t3.graveyardPosition.offset, 1);
                  const o2 = t3.targetPosition.parent;
                  this._isInInsertedElement(o2) || this._markInsert(o2, t3.targetPosition.offset, e3.maxOffset);
                  break;
                }
              }
              this._cachedChanges = null;
            }
            bufferMarkerChange(t3, e3, n2) {
              const o2 = this._changedMarkers.get(t3);
              o2 ? (o2.newMarkerData = n2, null == o2.oldMarkerData.range && null == n2.range && this._changedMarkers.delete(t3)) : this._changedMarkers.set(t3, { newMarkerData: n2, oldMarkerData: e3 });
            }
            getMarkersToRemove() {
              const t3 = [];
              for (const [e3, n2] of this._changedMarkers)
                null != n2.oldMarkerData.range && t3.push({ name: e3, range: n2.oldMarkerData.range });
              return t3;
            }
            getMarkersToAdd() {
              const t3 = [];
              for (const [e3, n2] of this._changedMarkers)
                null != n2.newMarkerData.range && t3.push({ name: e3, range: n2.newMarkerData.range });
              return t3;
            }
            getChangedMarkers() {
              return Array.from(this._changedMarkers).map(([t3, e3]) => ({ name: t3, data: { oldRange: e3.oldMarkerData.range, newRange: e3.newMarkerData.range } }));
            }
            hasDataChanges() {
              for (const { newMarkerData: t3, oldMarkerData: e3 } of this._changedMarkers.values()) {
                if (t3.affectsData !== e3.affectsData)
                  return true;
                if (t3.affectsData)
                  return !(t3.range && e3.range && t3.range.isEqual(e3.range));
              }
              return this._changesInElement.size > 0;
            }
            getChanges(t3 = { includeChangesInGraveyard: false }) {
              if (this._cachedChanges)
                return t3.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
              let e3 = [];
              for (const t4 of this._changesInElement.keys()) {
                const n2 = this._changesInElement.get(t4).sort((t5, e4) => t5.offset === e4.offset ? t5.type != e4.type ? "remove" == t5.type ? -1 : 1 : 0 : t5.offset < e4.offset ? -1 : 1), o2 = this._elementSnapshots.get(t4), i2 = Ol(t4.getChildren()), r2 = Rl(o2.length, n2);
                let s2 = 0, a2 = 0;
                for (const n3 of r2)
                  if ("i" === n3)
                    e3.push(this._getInsertDiff(t4, s2, i2[s2].name)), s2++;
                  else if ("r" === n3)
                    e3.push(this._getRemoveDiff(t4, s2, o2[a2].name)), a2++;
                  else if ("a" === n3) {
                    const n4 = i2[s2].attributes, r3 = o2[a2].attributes;
                    let c2;
                    if ("$text" == i2[s2].name)
                      c2 = new Ya(Ha._createAt(t4, s2), Ha._createAt(t4, s2 + 1));
                    else {
                      const e4 = t4.offsetToIndex(s2);
                      c2 = new Ya(Ha._createAt(t4, s2), Ha._createAt(t4.getChild(e4), 0));
                    }
                    e3.push(...this._getAttributesDiff(c2, r3, n4)), s2++, a2++;
                  } else
                    s2++, a2++;
              }
              e3.sort((t4, e4) => t4.position.root != e4.position.root ? t4.position.root.rootName < e4.position.root.rootName ? -1 : 1 : t4.position.isEqual(e4.position) ? t4.changeCount - e4.changeCount : t4.position.isBefore(e4.position) ? -1 : 1);
              for (let t4 = 1, n2 = 0; t4 < e3.length; t4++) {
                const o2 = e3[n2], i2 = e3[t4], r2 = "remove" == o2.type && "remove" == i2.type && "$text" == o2.name && "$text" == i2.name && o2.position.isEqual(i2.position), s2 = "insert" == o2.type && "insert" == i2.type && "$text" == o2.name && "$text" == i2.name && o2.position.parent == i2.position.parent && o2.position.offset + o2.length == i2.position.offset, a2 = "attribute" == o2.type && "attribute" == i2.type && o2.position.parent == i2.position.parent && o2.range.isFlat && i2.range.isFlat && o2.position.offset + o2.length == i2.position.offset && o2.attributeKey == i2.attributeKey && o2.attributeOldValue == i2.attributeOldValue && o2.attributeNewValue == i2.attributeNewValue;
                r2 || s2 || a2 ? (o2.length++, a2 && (o2.range.end = o2.range.end.getShiftedBy(1)), e3[t4] = null) : n2 = t4;
              }
              e3 = e3.filter((t4) => t4);
              for (const t4 of e3)
                delete t4.changeCount, "attribute" == t4.type && (delete t4.position, delete t4.length);
              return this._changeCount = 0, this._cachedChangesWithGraveyard = e3, this._cachedChanges = e3.filter(jl), t3.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
            }
            getRefreshedItems() {
              return new Set(this._refreshedItems);
            }
            reset() {
              this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
            }
            _refreshItem(t3) {
              if (this._isInInsertedElement(t3.parent))
                return;
              this._markRemove(t3.parent, t3.startOffset, t3.offsetSize), this._markInsert(t3.parent, t3.startOffset, t3.offsetSize), this._refreshedItems.add(t3);
              const e3 = Ya._createOn(t3);
              for (const t4 of this._markerCollection.getMarkersIntersectingRange(e3)) {
                const e4 = t4.getData();
                this.bufferMarkerChange(t4.name, e4, e4);
              }
              this._cachedChanges = null;
            }
            _markInsert(t3, e3, n2) {
              const o2 = { type: "insert", offset: e3, howMany: n2, count: this._changeCount++ };
              this._markChange(t3, o2);
            }
            _markRemove(t3, e3, n2) {
              const o2 = { type: "remove", offset: e3, howMany: n2, count: this._changeCount++ };
              this._markChange(t3, o2), this._removeAllNestedChanges(t3, e3, n2);
            }
            _markAttribute(t3) {
              const e3 = { type: "attribute", offset: t3.startOffset, howMany: t3.offsetSize, count: this._changeCount++ };
              this._markChange(t3.parent, e3);
            }
            _markChange(t3, e3) {
              this._makeSnapshot(t3);
              const n2 = this._getChangesForElement(t3);
              this._handleChange(e3, n2), n2.push(e3);
              for (let t4 = 0; t4 < n2.length; t4++)
                n2[t4].howMany < 1 && (n2.splice(t4, 1), t4--);
            }
            _getChangesForElement(t3) {
              let e3;
              return this._changesInElement.has(t3) ? e3 = this._changesInElement.get(t3) : (e3 = [], this._changesInElement.set(t3, e3)), e3;
            }
            _makeSnapshot(t3) {
              this._elementSnapshots.has(t3) || this._elementSnapshots.set(t3, Ol(t3.getChildren()));
            }
            _handleChange(t3, e3) {
              t3.nodesToHandle = t3.howMany;
              for (const n2 of e3) {
                const o2 = t3.offset + t3.howMany, i2 = n2.offset + n2.howMany;
                if ("insert" == t3.type && ("insert" == n2.type && (t3.offset <= n2.offset ? n2.offset += t3.howMany : t3.offset < i2 && (n2.howMany += t3.nodesToHandle, t3.nodesToHandle = 0)), "remove" == n2.type && t3.offset < n2.offset && (n2.offset += t3.howMany), "attribute" == n2.type)) {
                  if (t3.offset <= n2.offset)
                    n2.offset += t3.howMany;
                  else if (t3.offset < i2) {
                    const i3 = n2.howMany;
                    n2.howMany = t3.offset - n2.offset, e3.unshift({ type: "attribute", offset: o2, howMany: i3 - n2.howMany, count: this._changeCount++ });
                  }
                }
                if ("remove" == t3.type) {
                  if ("insert" == n2.type) {
                    if (o2 <= n2.offset)
                      n2.offset -= t3.howMany;
                    else if (o2 <= i2)
                      if (t3.offset < n2.offset) {
                        const e4 = o2 - n2.offset;
                        n2.offset = t3.offset, n2.howMany -= e4, t3.nodesToHandle -= e4;
                      } else
                        n2.howMany -= t3.nodesToHandle, t3.nodesToHandle = 0;
                    else if (t3.offset <= n2.offset)
                      t3.nodesToHandle -= n2.howMany, n2.howMany = 0;
                    else if (t3.offset < i2) {
                      const e4 = i2 - t3.offset;
                      n2.howMany -= e4, t3.nodesToHandle -= e4;
                    }
                  }
                  if ("remove" == n2.type && (o2 <= n2.offset ? n2.offset -= t3.howMany : t3.offset < n2.offset && (t3.nodesToHandle += n2.howMany, n2.howMany = 0)), "attribute" == n2.type) {
                    if (o2 <= n2.offset)
                      n2.offset -= t3.howMany;
                    else if (t3.offset < n2.offset) {
                      const e4 = o2 - n2.offset;
                      n2.offset = t3.offset, n2.howMany -= e4;
                    } else if (t3.offset < i2)
                      if (o2 <= i2) {
                        const o3 = n2.howMany;
                        n2.howMany = t3.offset - n2.offset;
                        const i3 = o3 - n2.howMany - t3.nodesToHandle;
                        e3.unshift({ type: "attribute", offset: t3.offset, howMany: i3, count: this._changeCount++ });
                      } else
                        n2.howMany -= i2 - t3.offset;
                  }
                }
                if ("attribute" == t3.type) {
                  if ("insert" == n2.type)
                    if (t3.offset < n2.offset && o2 > n2.offset) {
                      if (o2 > i2) {
                        const t4 = { type: "attribute", offset: i2, howMany: o2 - i2, count: this._changeCount++ };
                        this._handleChange(t4, e3), e3.push(t4);
                      }
                      t3.nodesToHandle = n2.offset - t3.offset, t3.howMany = t3.nodesToHandle;
                    } else
                      t3.offset >= n2.offset && t3.offset < i2 && (o2 > i2 ? (t3.nodesToHandle = o2 - i2, t3.offset = i2) : t3.nodesToHandle = 0);
                  if ("remove" == n2.type && t3.offset < n2.offset && o2 > n2.offset) {
                    const i3 = { type: "attribute", offset: n2.offset, howMany: o2 - n2.offset, count: this._changeCount++ };
                    this._handleChange(i3, e3), e3.push(i3), t3.nodesToHandle = n2.offset - t3.offset, t3.howMany = t3.nodesToHandle;
                  }
                  "attribute" == n2.type && (t3.offset >= n2.offset && o2 <= i2 ? (t3.nodesToHandle = 0, t3.howMany = 0, t3.offset = 0) : t3.offset <= n2.offset && o2 >= i2 && (n2.howMany = 0));
                }
              }
              t3.howMany = t3.nodesToHandle, delete t3.nodesToHandle;
            }
            _getInsertDiff(t3, e3, n2) {
              return { type: "insert", position: Ha._createAt(t3, e3), name: n2, length: 1, changeCount: this._changeCount++ };
            }
            _getRemoveDiff(t3, e3, n2) {
              return { type: "remove", position: Ha._createAt(t3, e3), name: n2, length: 1, changeCount: this._changeCount++ };
            }
            _getAttributesDiff(t3, e3, n2) {
              const o2 = [];
              n2 = new Map(n2);
              for (const [i2, r2] of e3) {
                const e4 = n2.has(i2) ? n2.get(i2) : null;
                e4 !== r2 && o2.push({ type: "attribute", position: t3.start, range: t3.clone(), length: 1, attributeKey: i2, attributeOldValue: r2, attributeNewValue: e4, changeCount: this._changeCount++ }), n2.delete(i2);
              }
              for (const [e4, i2] of n2)
                o2.push({ type: "attribute", position: t3.start, range: t3.clone(), length: 1, attributeKey: e4, attributeOldValue: null, attributeNewValue: i2, changeCount: this._changeCount++ });
              return o2;
            }
            _isInInsertedElement(t3) {
              const e3 = t3.parent;
              if (!e3)
                return false;
              const n2 = this._changesInElement.get(e3), o2 = t3.startOffset;
              if (n2) {
                for (const t4 of n2)
                  if ("insert" == t4.type && o2 >= t4.offset && o2 < t4.offset + t4.howMany)
                    return true;
              }
              return this._isInInsertedElement(e3);
            }
            _removeAllNestedChanges(t3, e3, n2) {
              const o2 = new Ya(Ha._createAt(t3, e3), Ha._createAt(t3, e3 + n2));
              for (const t4 of o2.getItems({ shallow: true }))
                t4.is("element") && (this._elementSnapshots.delete(t4), this._changesInElement.delete(t4), this._removeAllNestedChanges(t4, 0, t4.maxOffset));
            }
          }
          function Ol(t3) {
            const e3 = [];
            for (const n2 of t3)
              if (n2.is("$text"))
                for (let t4 = 0; t4 < n2.data.length; t4++)
                  e3.push({ name: "$text", attributes: new Map(n2.getAttributes()) });
              else
                e3.push({ name: n2.name, attributes: new Map(n2.getAttributes()) });
            return e3;
          }
          function Rl(t3, e3) {
            const n2 = [];
            let o2 = 0, i2 = 0;
            for (const t4 of e3) {
              if (t4.offset > o2) {
                for (let e4 = 0; e4 < t4.offset - o2; e4++)
                  n2.push("e");
                i2 += t4.offset - o2;
              }
              if ("insert" == t4.type) {
                for (let e4 = 0; e4 < t4.howMany; e4++)
                  n2.push("i");
                o2 = t4.offset + t4.howMany;
              } else if ("remove" == t4.type) {
                for (let e4 = 0; e4 < t4.howMany; e4++)
                  n2.push("r");
                o2 = t4.offset, i2 += t4.howMany;
              } else
                n2.push(..."a".repeat(t4.howMany).split("")), o2 = t4.offset + t4.howMany, i2 += t4.howMany;
            }
            if (i2 < t3)
              for (let e4 = 0; e4 < t3 - i2 - o2; e4++)
                n2.push("e");
            return n2;
          }
          function jl(t3) {
            const e3 = t3.position && "$graveyard" == t3.position.root.rootName, n2 = t3.range && "$graveyard" == t3.range.root.rootName;
            return !e3 && !n2;
          }
          class Fl {
            constructor() {
              this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set();
            }
            addOperation(t3) {
              this._operations.includes(t3) || this._operations.push(t3);
            }
            getOperations(t3 = Number.NEGATIVE_INFINITY, e3 = Number.POSITIVE_INFINITY) {
              const n2 = [];
              for (const o2 of this._operations)
                o2.baseVersion >= t3 && o2.baseVersion < e3 && n2.push(o2);
              return n2;
            }
            getOperation(t3) {
              for (const e3 of this._operations)
                if (e3.baseVersion == t3)
                  return e3;
            }
            setOperationAsUndone(t3, e3) {
              this._undoPairs.set(e3, t3), this._undoneOperations.add(t3);
            }
            isUndoingOperation(t3) {
              return this._undoPairs.has(t3);
            }
            isUndoneOperation(t3) {
              return this._undoneOperations.has(t3);
            }
            getUndoneOperation(t3) {
              return this._undoPairs.get(t3);
            }
          }
          function Vl(t3, e3) {
            return !!(n2 = t3.charAt(e3 - 1)) && 1 == n2.length && /[\ud800-\udbff]/.test(n2) && function(t4) {
              return !!t4 && 1 == t4.length && /[\udc00-\udfff]/.test(t4);
            }(t3.charAt(e3));
            var n2;
          }
          function Ul(t3, e3) {
            return !!(n2 = t3.charAt(e3)) && 1 == n2.length && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n2);
            var n2;
          }
          const Hl = function() {
            const t3 = /\p{Regional_Indicator}{2}/u.source, e3 = "(?:" + [/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u, /\p{Emoji}\u{FE0F}?\u{20E3}/u, /\p{Emoji}\u{FE0F}/u, /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u].map((t4) => t4.source).join("|") + ")";
            return new RegExp(`${t3}|${e3}(?:\u200D${e3})*`, "ug");
          }();
          function ql(t3, e3) {
            const n2 = String(t3).matchAll(Hl);
            return Array.from(n2).some((t4) => t4.index < e3 && e3 < t4.index + t4[0].length);
          }
          const Wl = "$graveyard";
          class Gl {
            constructor(t3) {
              this.model = t3, this.version = 0, this.history = new Fl(this), this.selection = new lc(this), this.roots = new Io({ idProperty: "rootName" }), this.differ = new Ll(t3.markers), this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = false, this.createRoot("$root", Wl), this.listenTo(t3, "applyOperation", (t4, e3) => {
                const n2 = e3[0];
                if (n2.isDocumentOperation && n2.baseVersion !== this.version)
                  throw new a("model-document-applyoperation-wrong-version", this, { operation: n2 });
              }, { priority: "highest" }), this.listenTo(t3, "applyOperation", (t4, e3) => {
                const n2 = e3[0];
                n2.isDocumentOperation && this.differ.bufferOperation(n2);
              }, { priority: "high" }), this.listenTo(t3, "applyOperation", (t4, e3) => {
                const n2 = e3[0];
                n2.isDocumentOperation && (this.version++, this.history.addOperation(n2));
              }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
                this._hasSelectionChangedFromTheLastChangeBlock = true;
              }), this.listenTo(t3.markers, "update", (t4, e3, n2, o2, i2) => {
                const r2 = { ...e3.getData(), range: o2 };
                this.differ.bufferMarkerChange(e3.name, i2, r2), null === n2 && e3.on("change", (t5, n3) => {
                  const o3 = e3.getData();
                  this.differ.bufferMarkerChange(e3.name, { ...o3, range: n3 }, o3);
                });
              });
            }
            get graveyard() {
              return this.getRoot(Wl);
            }
            createRoot(t3 = "$root", e3 = "main") {
              if (this.roots.get(e3))
                throw new a("model-document-createroot-name-exists", this, { name: e3 });
              const n2 = new Ml(this, t3, e3);
              return this.roots.add(n2), n2;
            }
            destroy() {
              this.selection.destroy(), this.stopListening();
            }
            getRoot(t3 = "main") {
              return this.roots.get(t3);
            }
            getRootNames() {
              return Array.from(this.roots, (t3) => t3.rootName).filter((t3) => t3 != Wl);
            }
            registerPostFixer(t3) {
              this._postFixers.add(t3);
            }
            toJSON() {
              const t3 = Ro(this);
              return t3.selection = "[engine.model.DocumentSelection]", t3.model = "[engine.model.Model]", t3;
            }
            _handleChangeBlock(t3) {
              this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t3), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t3.batch) : this.fire("change", t3.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = false;
            }
            _hasDocumentChangedFromTheLastChangeBlock() {
              return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
            }
            _getDefaultRoot() {
              for (const t3 of this.roots)
                if (t3 !== this.graveyard)
                  return t3;
              return this.graveyard;
            }
            _getDefaultRange() {
              const t3 = this._getDefaultRoot(), e3 = this.model, n2 = e3.schema, o2 = e3.createPositionFromPath(t3, [0]);
              return n2.getNearestSelectionRange(o2) || e3.createRange(o2);
            }
            _validateSelectionRange(t3) {
              return Yl(t3.start) && Yl(t3.end);
            }
            _callPostFixers(t3) {
              let e3 = false;
              do {
                for (const n2 of this._postFixers)
                  if (this.selection.refresh(), e3 = n2(t3), e3)
                    break;
              } while (e3);
            }
          }
          function Yl(t3) {
            const e3 = t3.textNode;
            if (e3) {
              const n2 = e3.data, o2 = t3.offset - e3.startOffset;
              return !Vl(n2, o2) && !Ul(n2, o2);
            }
            return true;
          }
          he(Gl, f);
          class Ql {
            constructor() {
              this._markers = /* @__PURE__ */ new Map();
            }
            [Symbol.iterator]() {
              return this._markers.values();
            }
            has(t3) {
              const e3 = t3 instanceof Kl ? t3.name : t3;
              return this._markers.has(e3);
            }
            get(t3) {
              return this._markers.get(t3) || null;
            }
            _set(t3, e3, n2 = false, o2 = false) {
              const i2 = t3 instanceof Kl ? t3.name : t3;
              if (i2.includes(","))
                throw new a("markercollection-incorrect-marker-name", this);
              const r2 = this._markers.get(i2);
              if (r2) {
                const t4 = r2.getData(), s3 = r2.getRange();
                let a2 = false;
                return s3.isEqual(e3) || (r2._attachLiveRange(rc.fromRange(e3)), a2 = true), n2 != r2.managedUsingOperations && (r2._managedUsingOperations = n2, a2 = true), "boolean" == typeof o2 && o2 != r2.affectsData && (r2._affectsData = o2, a2 = true), a2 && this.fire("update:" + i2, r2, s3, e3, t4), r2;
              }
              const s2 = rc.fromRange(e3), c2 = new Kl(i2, s2, n2, o2);
              return this._markers.set(i2, c2), this.fire("update:" + i2, c2, null, e3, { ...c2.getData(), range: null }), c2;
            }
            _remove(t3) {
              const e3 = t3 instanceof Kl ? t3.name : t3, n2 = this._markers.get(e3);
              return !!n2 && (this._markers.delete(e3), this.fire("update:" + e3, n2, n2.getRange(), null, n2.getData()), this._destroyMarker(n2), true);
            }
            _refresh(t3) {
              const e3 = t3 instanceof Kl ? t3.name : t3, n2 = this._markers.get(e3);
              if (!n2)
                throw new a("markercollection-refresh-marker-not-exists", this);
              const o2 = n2.getRange();
              this.fire("update:" + e3, n2, o2, o2, n2.getData());
            }
            *getMarkersAtPosition(t3) {
              for (const e3 of this)
                e3.getRange().containsPosition(t3) && (yield e3);
            }
            *getMarkersIntersectingRange(t3) {
              for (const e3 of this)
                null !== e3.getRange().getIntersection(t3) && (yield e3);
            }
            destroy() {
              for (const t3 of this._markers.values())
                this._destroyMarker(t3);
              this._markers = null, this.stopListening();
            }
            *getMarkersGroup(t3) {
              for (const e3 of this._markers.values())
                e3.name.startsWith(t3 + ":") && (yield e3);
            }
            _destroyMarker(t3) {
              t3.stopListening(), t3._detachLiveRange();
            }
          }
          he(Ql, f);
          class Kl {
            constructor(t3, e3, n2, o2) {
              this.name = t3, this._liveRange = this._attachLiveRange(e3), this._managedUsingOperations = n2, this._affectsData = o2;
            }
            get managedUsingOperations() {
              if (!this._liveRange)
                throw new a("marker-destroyed", this);
              return this._managedUsingOperations;
            }
            get affectsData() {
              if (!this._liveRange)
                throw new a("marker-destroyed", this);
              return this._affectsData;
            }
            getData() {
              return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
            }
            getStart() {
              if (!this._liveRange)
                throw new a("marker-destroyed", this);
              return this._liveRange.start.clone();
            }
            getEnd() {
              if (!this._liveRange)
                throw new a("marker-destroyed", this);
              return this._liveRange.end.clone();
            }
            getRange() {
              if (!this._liveRange)
                throw new a("marker-destroyed", this);
              return this._liveRange.toRange();
            }
            is(t3) {
              return "marker" === t3 || "model:marker" === t3;
            }
            _attachLiveRange(t3) {
              return this._liveRange && this._detachLiveRange(), t3.delegate("change:range").to(this), t3.delegate("change:content").to(this), this._liveRange = t3, t3;
            }
            _detachLiveRange() {
              this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
            }
          }
          he(Kl, f);
          class $l extends dl {
            get type() {
              return "noop";
            }
            clone() {
              return new $l(this.baseVersion);
            }
            getReversed() {
              return new $l(this.baseVersion + 1);
            }
            _execute() {
            }
            static get className() {
              return "NoOperation";
            }
          }
          const Zl = {};
          Zl[Cl.className] = Cl, Zl[vl.className] = vl, Zl[yl.className] = yl, Zl[_l.className] = _l, Zl[$l.className] = $l, Zl[dl.className] = dl, Zl[xl.className] = xl, Zl[El.className] = El, Zl[Il.className] = Il, Zl[Dl.className] = Dl;
          class Jl extends Ha {
            constructor(t3, e3, n2 = "toNone") {
              if (super(t3, e3, n2), !this.root.is("rootElement"))
                throw new a("model-liveposition-root-not-rootelement", t3);
              Xl.call(this);
            }
            detach() {
              this.stopListening();
            }
            is(t3) {
              return "livePosition" === t3 || "model:livePosition" === t3 || "position" == t3 || "model:position" === t3;
            }
            toPosition() {
              return new Ha(this.root, this.path.slice(), this.stickiness);
            }
            static fromPosition(t3, e3) {
              return new this(t3.root, t3.path.slice(), e3 || t3.stickiness);
            }
          }
          function Xl() {
            this.listenTo(this.root.document.model, "applyOperation", (t3, e3) => {
              const n2 = e3[0];
              n2.isDocumentOperation && td.call(this, n2);
            }, { priority: "low" });
          }
          function td(t3) {
            const e3 = this.getTransformedByOperation(t3);
            if (!this.isEqual(e3)) {
              const t4 = this.toPosition();
              this.path = e3.path, this.root = e3.root, this.fire("change", t4);
            }
          }
          he(Jl, f);
          class ed {
            constructor(t3, e3, n2) {
              this.model = t3, this.writer = e3, this.position = n2, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = t3.schema, this._documentFragment = e3.createDocumentFragment(), this._documentFragmentPosition = e3.createPositionAt(this._documentFragment, 0), this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null;
            }
            handleNodes(t3) {
              for (const e3 of Array.from(t3))
                this._handleNode(e3);
              this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
            }
            _updateLastNodeFromAutoParagraph(t3) {
              const e3 = this.writer.createPositionAfter(this._lastNode), n2 = this.writer.createPositionAfter(t3);
              if (n2.isAfter(e3)) {
                if (this._lastNode = t3, this.position.parent != t3 || !this.position.isAtEnd)
                  throw new a("insertcontent-invalid-insertion-position", this);
                this.position = n2, this._setAffectedBoundaries(this.position);
              }
            }
            getSelectionRange() {
              return this.nodeToSelect ? Ya._createOn(this.nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
            }
            getAffectedRange() {
              return this._affectedStart ? new Ya(this._affectedStart, this._affectedEnd) : null;
            }
            destroy() {
              this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
            }
            _handleNode(t3) {
              if (this.schema.isObject(t3))
                return void this._handleObject(t3);
              let e3 = this._checkAndAutoParagraphToAllowedPosition(t3);
              e3 || (e3 = this._checkAndSplitToAllowedPosition(t3), e3) ? (this._appendToFragment(t3), this._firstNode || (this._firstNode = t3), this._lastNode = t3) : this._handleDisallowedNode(t3);
            }
            _insertPartialFragment() {
              if (this._documentFragment.isEmpty)
                return;
              const t3 = Jl.fromPosition(this.position, "toNext");
              this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = t3.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = t3.toPosition(), t3.detach();
            }
            _handleObject(t3) {
              this._checkAndSplitToAllowedPosition(t3) ? this._appendToFragment(t3) : this._tryAutoparagraphing(t3);
            }
            _handleDisallowedNode(t3) {
              t3.is("element") ? this.handleNodes(t3.getChildren()) : this._tryAutoparagraphing(t3);
            }
            _appendToFragment(t3) {
              if (!this.schema.checkChild(this.position, t3))
                throw new a("insertcontent-wrong-position", this, { node: t3, position: this.position });
              this.writer.insert(t3, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t3.offsetSize), this.schema.isObject(t3) && !this.schema.checkChild(this.position, "$text") ? this.nodeToSelect = t3 : this.nodeToSelect = null, this._filterAttributesOf.push(t3);
            }
            _setAffectedBoundaries(t3) {
              this._affectedStart || (this._affectedStart = Jl.fromPosition(t3, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(t3) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Jl.fromPosition(t3, "toNext"));
            }
            _mergeOnLeft() {
              const t3 = this._firstNode;
              if (!(t3 instanceof Fa))
                return;
              if (!this._canMergeLeft(t3))
                return;
              const e3 = Jl._createBefore(t3);
              e3.stickiness = "toNext";
              const n2 = Jl.fromPosition(this.position, "toNext");
              this._affectedStart.isEqual(e3) && (this._affectedStart.detach(), this._affectedStart = Jl._createAt(e3.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = e3.nodeBefore, this._lastNode = e3.nodeBefore), this.writer.merge(e3), e3.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Jl._createAt(e3.nodeBefore, "end", "toNext")), this.position = n2.toPosition(), n2.detach(), this._filterAttributesOf.push(this.position.parent), e3.detach();
            }
            _mergeOnRight() {
              const t3 = this._lastNode;
              if (!(t3 instanceof Fa))
                return;
              if (!this._canMergeRight(t3))
                return;
              const e3 = Jl._createAfter(t3);
              if (e3.stickiness = "toNext", !this.position.isEqual(e3))
                throw new a("insertcontent-invalid-insertion-position", this);
              this.position = Ha._createAt(e3.nodeBefore, "end");
              const n2 = Jl.fromPosition(this.position, "toPrevious");
              this._affectedEnd.isEqual(e3) && (this._affectedEnd.detach(), this._affectedEnd = Jl._createAt(e3.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = e3.nodeBefore, this._lastNode = e3.nodeBefore), this.writer.merge(e3), e3.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Jl._createAt(e3.nodeBefore, 0, "toPrevious")), this.position = n2.toPosition(), n2.detach(), this._filterAttributesOf.push(this.position.parent), e3.detach();
            }
            _canMergeLeft(t3) {
              const e3 = t3.previousSibling;
              return e3 instanceof Fa && this.canMergeWith.has(e3) && this.model.schema.checkMerge(e3, t3);
            }
            _canMergeRight(t3) {
              const e3 = t3.nextSibling;
              return e3 instanceof Fa && this.canMergeWith.has(e3) && this.model.schema.checkMerge(t3, e3);
            }
            _tryAutoparagraphing(t3) {
              const e3 = this.writer.createElement("paragraph");
              this._getAllowedIn(this.position.parent, e3) && this.schema.checkChild(e3, t3) && (e3._appendChild(t3), this._handleNode(e3));
            }
            _checkAndAutoParagraphToAllowedPosition(t3) {
              if (this.schema.checkChild(this.position.parent, t3))
                return true;
              if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t3))
                return false;
              this._insertPartialFragment();
              const e3 = this.writer.createElement("paragraph");
              return this.writer.insert(e3, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = e3, this.position = this.writer.createPositionAt(e3, 0), true;
            }
            _checkAndSplitToAllowedPosition(t3) {
              const e3 = this._getAllowedIn(this.position.parent, t3);
              if (!e3)
                return false;
              for (e3 != this.position.parent && this._insertPartialFragment(); e3 != this.position.parent; )
                if (this.position.isAtStart) {
                  const t4 = this.position.parent;
                  this.position = this.writer.createPositionBefore(t4), t4.isEmpty && t4.parent === e3 && this.writer.remove(t4);
                } else if (this.position.isAtEnd)
                  this.position = this.writer.createPositionAfter(this.position.parent);
                else {
                  const t4 = this.writer.createPositionAfter(this.position.parent);
                  this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = t4, this.canMergeWith.add(this.position.nodeAfter);
                }
              return true;
            }
            _getAllowedIn(t3, e3) {
              return this.schema.checkChild(t3, e3) ? t3 : this.schema.isLimit(t3) ? null : this._getAllowedIn(t3.parent, e3);
            }
          }
          function nd(t3, e3, n2 = {}) {
            if (e3.isCollapsed)
              return;
            const o2 = e3.getFirstRange();
            if ("$graveyard" == o2.root.rootName)
              return;
            const i2 = t3.schema;
            t3.change((t4) => {
              if (!n2.doNotResetEntireContent && function(t5, e4) {
                const n3 = t5.getLimitElement(e4);
                if (!e4.containsEntireContent(n3))
                  return false;
                const o3 = e4.getFirstRange();
                if (o3.start.parent == o3.end.parent)
                  return false;
                return t5.checkChild(n3, "paragraph");
              }(i2, e3))
                return void function(t5, e4) {
                  const n3 = t5.model.schema.getLimitElement(e4);
                  t5.remove(t5.createRangeIn(n3)), sd(t5, t5.createPositionAt(n3, 0), e4);
                }(t4, e3);
              const [r2, s2] = function(t5) {
                const e4 = t5.root.document.model, n3 = t5.start;
                let o3 = t5.end;
                if (e4.hasContent(t5, { ignoreMarkers: true })) {
                  const n4 = function(t6) {
                    const e5 = t6.parent, n5 = e5.root.document.model.schema, o4 = e5.getAncestors({ parentFirst: true, includeSelf: true });
                    for (const t7 of o4) {
                      if (n5.isLimit(t7))
                        return null;
                      if (n5.isBlock(t7))
                        return t7;
                    }
                  }(o3);
                  if (n4 && o3.isTouching(e4.createPositionAt(n4, 0))) {
                    const n5 = e4.createSelection(t5);
                    e4.modifySelection(n5, { direction: "backward" });
                    const i3 = n5.getLastPosition(), r3 = e4.createRange(i3, o3);
                    e4.hasContent(r3, { ignoreMarkers: true }) || (o3 = i3);
                  }
                }
                return [Jl.fromPosition(n3, "toPrevious"), Jl.fromPosition(o3, "toNext")];
              }(o2);
              r2.isTouching(s2) || t4.remove(t4.createRange(r2, s2)), n2.leaveUnmerged || (!function(t5, e4, n3) {
                const o3 = t5.model;
                if (!rd(t5.model.schema, e4, n3))
                  return;
                const [i3, r3] = function(t6, e5) {
                  const n4 = t6.getAncestors(), o4 = e5.getAncestors();
                  let i4 = 0;
                  for (; n4[i4] && n4[i4] == o4[i4]; )
                    i4++;
                  return [n4[i4], o4[i4]];
                }(e4, n3);
                if (!i3 || !r3)
                  return;
                !o3.hasContent(i3, { ignoreMarkers: true }) && o3.hasContent(r3, { ignoreMarkers: true }) ? id(t5, e4, n3, i3.parent) : od(t5, e4, n3, i3.parent);
              }(t4, r2, s2), i2.removeDisallowedAttributes(r2.parent.getChildren(), t4)), ad(t4, e3, r2), !n2.doNotAutoparagraph && function(t5, e4) {
                const n3 = t5.checkChild(e4, "$text"), o3 = t5.checkChild(e4, "paragraph");
                return !n3 && o3;
              }(i2, r2) && sd(t4, r2, e3), r2.detach(), s2.detach();
            });
          }
          function od(t3, e3, n2, o2) {
            const i2 = e3.parent, r2 = n2.parent;
            if (i2 != o2 && r2 != o2) {
              for (e3 = t3.createPositionAfter(i2), (n2 = t3.createPositionBefore(r2)).isEqual(e3) || t3.insert(r2, e3), t3.merge(e3); n2.parent.isEmpty; ) {
                const e4 = n2.parent;
                n2 = t3.createPositionBefore(e4), t3.remove(e4);
              }
              rd(t3.model.schema, e3, n2) && od(t3, e3, n2, o2);
            }
          }
          function id(t3, e3, n2, o2) {
            const i2 = e3.parent, r2 = n2.parent;
            if (i2 != o2 && r2 != o2) {
              for (e3 = t3.createPositionAfter(i2), (n2 = t3.createPositionBefore(r2)).isEqual(e3) || t3.insert(i2, n2); e3.parent.isEmpty; ) {
                const n3 = e3.parent;
                e3 = t3.createPositionBefore(n3), t3.remove(n3);
              }
              n2 = t3.createPositionBefore(r2), function(t4, e4) {
                const n3 = e4.nodeBefore, o3 = e4.nodeAfter;
                n3.name != o3.name && t4.rename(n3, o3.name);
                t4.clearAttributes(n3), t4.setAttributes(Object.fromEntries(o3.getAttributes()), n3), t4.merge(e4);
              }(t3, n2), rd(t3.model.schema, e3, n2) && id(t3, e3, n2, o2);
            }
          }
          function rd(t3, e3, n2) {
            const o2 = e3.parent, i2 = n2.parent;
            return o2 != i2 && (!t3.isLimit(o2) && !t3.isLimit(i2) && function(t4, e4, n3) {
              const o3 = new Ya(t4, e4);
              for (const t5 of o3.getWalker())
                if (n3.isLimit(t5.item))
                  return false;
              return true;
            }(e3, n2, t3));
          }
          function sd(t3, e3, n2) {
            const o2 = t3.createElement("paragraph");
            t3.insert(o2, e3), ad(t3, n2, t3.createPositionAt(o2, 0));
          }
          function ad(t3, e3, n2) {
            e3 instanceof lc ? t3.setSelection(n2) : e3.setTo(n2);
          }
          const cd = ' ,.?!:;"-()';
          function ld(t3, e3) {
            const { isForward: n2, walker: o2, unit: i2, schema: r2, treatEmojiAsSingleUnit: s2 } = t3, { type: a2, item: c2, nextPosition: l2 } = e3;
            if ("text" == a2)
              return "word" === t3.unit ? function(t4, e4) {
                let n3 = t4.position.textNode;
                if (n3) {
                  let o3 = t4.position.offset - n3.startOffset;
                  for (; !hd(n3.data, o3, e4) && !ud(n3, o3, e4); ) {
                    t4.next();
                    const i3 = e4 ? t4.position.nodeAfter : t4.position.nodeBefore;
                    if (i3 && i3.is("$text")) {
                      const o4 = i3.data.charAt(e4 ? 0 : i3.data.length - 1);
                      cd.includes(o4) || (t4.next(), n3 = t4.position.textNode);
                    }
                    o3 = t4.position.offset - n3.startOffset;
                  }
                }
                return t4.position;
              }(o2, n2) : function(t4, e4, n3) {
                const o3 = t4.position.textNode;
                if (o3) {
                  const i3 = o3.data;
                  let r3 = t4.position.offset - o3.startOffset;
                  for (; Vl(i3, r3) || "character" == e4 && Ul(i3, r3) || n3 && ql(i3, r3); )
                    t4.next(), r3 = t4.position.offset - o3.startOffset;
                }
                return t4.position;
              }(o2, i2, s2);
            if (a2 == (n2 ? "elementStart" : "elementEnd")) {
              if (r2.isSelectable(c2))
                return Ha._createAt(c2, n2 ? "after" : "before");
              if (r2.checkChild(l2, "$text"))
                return l2;
            } else {
              if (r2.isLimit(c2))
                return void o2.skip(() => true);
              if (r2.checkChild(l2, "$text"))
                return l2;
            }
          }
          function dd(t3, e3) {
            const n2 = t3.root, o2 = Ha._createAt(n2, e3 ? "end" : 0);
            return e3 ? new Ya(t3, o2) : new Ya(o2, t3);
          }
          function hd(t3, e3, n2) {
            const o2 = e3 + (n2 ? 0 : -1);
            return cd.includes(t3.charAt(o2));
          }
          function ud(t3, e3, n2) {
            return e3 === (n2 ? t3.endOffset : 0);
          }
          function gd(t3, e3) {
            const n2 = [];
            Array.from(t3.getItems({ direction: "backward" })).map((t4) => e3.createRangeOn(t4)).filter((e4) => (e4.start.isAfter(t3.start) || e4.start.isEqual(t3.start)) && (e4.end.isBefore(t3.end) || e4.end.isEqual(t3.end))).forEach((t4) => {
              n2.push(t4.start.parent), e3.remove(t4);
            }), n2.forEach((t4) => {
              let n3 = t4;
              for (; n3.parent && n3.isEmpty; ) {
                const t5 = e3.createRangeOn(n3);
                n3 = n3.parent, e3.remove(t5);
              }
            });
          }
          function md(t3) {
            t3.document.registerPostFixer((e3) => function(t4, e4) {
              const n2 = e4.document.selection, o2 = e4.schema, i2 = [];
              let r2 = false;
              for (const t5 of n2.getRanges()) {
                const e5 = pd(t5, o2);
                e5 && !e5.isEqual(t5) ? (i2.push(e5), r2 = true) : i2.push(t5);
              }
              r2 && t4.setSelection(function(t5) {
                const e5 = [...t5], n3 = /* @__PURE__ */ new Set();
                let o3 = 1;
                for (; o3 < e5.length; ) {
                  const t6 = e5[o3], i3 = e5.slice(0, o3);
                  for (const [r3, s2] of i3.entries())
                    if (!n3.has(r3)) {
                      if (t6.isEqual(s2))
                        n3.add(r3);
                      else if (t6.isIntersecting(s2)) {
                        n3.add(r3), n3.add(o3);
                        const i4 = t6.getJoined(s2);
                        e5.push(i4);
                      }
                    }
                  o3++;
                }
                return e5.filter((t6, e6) => !n3.has(e6));
              }(i2), { backward: n2.isBackward });
            }(e3, t3));
          }
          function pd(t3, e3) {
            return t3.isCollapsed ? function(t4, e4) {
              const n2 = t4.start, o2 = e4.getNearestSelectionRange(n2);
              if (!o2) {
                const t5 = n2.getAncestors().reverse().find((t6) => e4.isObject(t6));
                return t5 ? Ya._createOn(t5) : null;
              }
              if (!o2.isCollapsed)
                return o2;
              const i2 = o2.start;
              if (n2.isEqual(i2))
                return null;
              return new Ya(i2);
            }(t3, e3) : function(t4, e4) {
              const { start: n2, end: o2 } = t4, i2 = e4.checkChild(n2, "$text"), r2 = e4.checkChild(o2, "$text"), s2 = e4.getLimitElement(n2), a2 = e4.getLimitElement(o2);
              if (s2 === a2) {
                if (i2 && r2)
                  return null;
                if (function(t5, e5, n3) {
                  const o3 = t5.nodeAfter && !n3.isLimit(t5.nodeAfter) || n3.checkChild(t5, "$text"), i3 = e5.nodeBefore && !n3.isLimit(e5.nodeBefore) || n3.checkChild(e5, "$text");
                  return o3 || i3;
                }(n2, o2, e4)) {
                  const t5 = n2.nodeAfter && e4.isSelectable(n2.nodeAfter) ? null : e4.getNearestSelectionRange(n2, "forward"), i3 = o2.nodeBefore && e4.isSelectable(o2.nodeBefore) ? null : e4.getNearestSelectionRange(o2, "backward"), r3 = t5 ? t5.start : n2, s3 = i3 ? i3.end : o2;
                  return new Ya(r3, s3);
                }
              }
              const c2 = s2 && !s2.is("rootElement"), l2 = a2 && !a2.is("rootElement");
              if (c2 || l2) {
                const t5 = n2.nodeAfter && o2.nodeBefore && n2.nodeAfter.parent === o2.nodeBefore.parent, i3 = c2 && (!t5 || !kd(n2.nodeAfter, e4)), r3 = l2 && (!t5 || !kd(o2.nodeBefore, e4));
                let d2 = n2, h2 = o2;
                return i3 && (d2 = Ha._createBefore(fd(s2, e4))), r3 && (h2 = Ha._createAfter(fd(a2, e4))), new Ya(d2, h2);
              }
              return null;
            }(t3, e3);
          }
          function fd(t3, e3) {
            let n2 = t3, o2 = n2;
            for (; e3.isLimit(o2) && o2.parent; )
              n2 = o2, o2 = o2.parent;
            return n2;
          }
          function kd(t3, e3) {
            return t3 && e3.isSelectable(t3);
          }
          class bd {
            constructor() {
              this.markers = new Ql(), this.document = new Gl(this), this.schema = new Vc(), this._pendingChanges = [], this._currentWriter = null, ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t3) => this.decorate(t3)), this.on("applyOperation", (t3, e3) => {
                e3[0]._validate();
              }, { priority: "highest" }), this.schema.register("$root", { isLimit: true }), this.schema.register("$block", { allowIn: "$root", isBlock: true }), this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$marker"), this.schema.addChildCheck((t3, e3) => {
                if ("$marker" === e3.name)
                  return true;
              }), md(this), this.document.registerPostFixer(Dc);
            }
            change(t3) {
              try {
                return 0 === this._pendingChanges.length ? (this._pendingChanges.push({ batch: new ll(), callback: t3 }), this._runPendingChanges()[0]) : t3(this._currentWriter);
              } catch (t4) {
                a.rethrowUnexpectedError(t4, this);
              }
            }
            enqueueChange(t3, e3) {
              try {
                t3 ? "function" == typeof t3 ? (e3 = t3, t3 = new ll()) : t3 instanceof ll || (t3 = new ll(t3)) : t3 = new ll(), this._pendingChanges.push({ batch: t3, callback: e3 }), 1 == this._pendingChanges.length && this._runPendingChanges();
              } catch (t4) {
                a.rethrowUnexpectedError(t4, this);
              }
            }
            applyOperation(t3) {
              t3._execute();
            }
            insertContent(t3, e3, n2) {
              return function(t4, e4, n3, o2) {
                return t4.change((i2) => {
                  let r2;
                  r2 = n3 ? n3 instanceof tc || n3 instanceof lc ? n3 : i2.createSelection(n3, o2) : t4.document.selection, r2.isCollapsed || t4.deleteContent(r2, { doNotAutoparagraph: true });
                  const s2 = new ed(t4, i2, r2.anchor);
                  let a2;
                  a2 = e4.is("documentFragment") ? e4.getChildren() : [e4], s2.handleNodes(a2);
                  const c2 = s2.getSelectionRange();
                  c2 && (r2 instanceof lc ? i2.setSelection(c2) : r2.setTo(c2));
                  const l2 = s2.getAffectedRange() || t4.createRange(r2.anchor);
                  return s2.destroy(), l2;
                });
              }(this, t3, e3, n2);
            }
            deleteContent(t3, e3) {
              nd(this, t3, e3);
            }
            modifySelection(t3, e3) {
              !function(t4, e4, n2 = {}) {
                const o2 = t4.schema, i2 = "backward" != n2.direction, r2 = n2.unit ? n2.unit : "character", s2 = !!n2.treatEmojiAsSingleUnit, a2 = e4.focus, c2 = new Va({ boundaries: dd(a2, i2), singleCharacters: true, direction: i2 ? "forward" : "backward" }), l2 = { walker: c2, schema: o2, isForward: i2, unit: r2, treatEmojiAsSingleUnit: s2 };
                let d2;
                for (; d2 = c2.next(); ) {
                  if (d2.done)
                    return;
                  const n3 = ld(l2, d2.value);
                  if (n3)
                    return void (e4 instanceof lc ? t4.change((t5) => {
                      t5.setSelectionFocus(n3);
                    }) : e4.setFocus(n3));
                }
              }(this, t3, e3);
            }
            getSelectedContent(t3) {
              return function(t4, e3) {
                return t4.change((t5) => {
                  const n2 = t5.createDocumentFragment(), o2 = e3.getFirstRange();
                  if (!o2 || o2.isCollapsed)
                    return n2;
                  const i2 = o2.start.root, r2 = o2.start.getCommonPath(o2.end), s2 = i2.getNodeByPath(r2);
                  let a2;
                  a2 = o2.start.parent == o2.end.parent ? o2 : t5.createRange(t5.createPositionAt(s2, o2.start.path[r2.length]), t5.createPositionAt(s2, o2.end.path[r2.length] + 1));
                  const c2 = a2.end.offset - a2.start.offset;
                  for (const e4 of a2.getItems({ shallow: true }))
                    e4.is("$textProxy") ? t5.appendText(e4.data, e4.getAttributes(), n2) : t5.append(t5.cloneElement(e4, true), n2);
                  if (a2 != o2) {
                    const e4 = o2._getTransformedByMove(a2.start, t5.createPositionAt(n2, 0), c2)[0], i3 = t5.createRange(t5.createPositionAt(n2, 0), e4.start);
                    gd(t5.createRange(e4.end, t5.createPositionAt(n2, "end")), t5), gd(i3, t5);
                  }
                  return n2;
                });
              }(this, t3);
            }
            hasContent(t3, e3 = {}) {
              const n2 = t3 instanceof Fa ? Ya._createIn(t3) : t3;
              if (n2.isCollapsed)
                return false;
              const { ignoreWhitespaces: o2 = false, ignoreMarkers: i2 = false } = e3;
              if (!i2) {
                for (const t4 of this.markers.getMarkersIntersectingRange(n2))
                  if (t4.affectsData)
                    return true;
              }
              for (const t4 of n2.getItems())
                if (this.schema.isContent(t4)) {
                  if (!t4.is("$textProxy"))
                    return true;
                  if (!o2)
                    return true;
                  if (-1 !== t4.data.search(/\S/))
                    return true;
                }
              return false;
            }
            createPositionFromPath(t3, e3, n2) {
              return new Ha(t3, e3, n2);
            }
            createPositionAt(t3, e3) {
              return Ha._createAt(t3, e3);
            }
            createPositionAfter(t3) {
              return Ha._createAfter(t3);
            }
            createPositionBefore(t3) {
              return Ha._createBefore(t3);
            }
            createRange(t3, e3) {
              return new Ya(t3, e3);
            }
            createRangeIn(t3) {
              return Ya._createIn(t3);
            }
            createRangeOn(t3) {
              return Ya._createOn(t3);
            }
            createSelection(t3, e3, n2) {
              return new tc(t3, e3, n2);
            }
            createBatch(t3) {
              return new ll(t3);
            }
            createOperationFromJSON(t3) {
              return class {
                static fromJSON(t4, e3) {
                  return Zl[t4.__className].fromJSON(t4, e3);
                }
              }.fromJSON(t3, this.document);
            }
            destroy() {
              this.document.destroy(), this.stopListening();
            }
            _runPendingChanges() {
              const t3 = [];
              for (this.fire("_beforeChanges"); this._pendingChanges.length; ) {
                const e3 = this._pendingChanges[0].batch;
                this._currentWriter = new Sl(this, e3);
                const n2 = this._pendingChanges[0].callback(this._currentWriter);
                t3.push(n2), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
              }
              return this.fire("_afterChanges"), t3;
            }
          }
          he(bd, re);
          class wd extends va {
            constructor(t3) {
              super(), this.editor = t3;
            }
            set(t3, e3, n2 = {}) {
              if ("string" == typeof e3) {
                const t4 = e3;
                e3 = (e4, n3) => {
                  this.editor.execute(t4), n3();
                };
              }
              super.set(t3, e3, n2);
            }
          }
          class Cd {
            constructor(t3 = {}) {
              const e3 = t3.language || this.constructor.defaultConfig && this.constructor.defaultConfig.language;
              this._context = t3.context || new Po({ language: e3 }), this._context._addEditor(this, !t3.context);
              const n2 = Array.from(this.constructor.builtinPlugins || []);
              this.config = new yo(t3, this.constructor.defaultConfig), this.config.define("plugins", n2), this.config.define(this._context._getEditorConfig()), this.plugins = new Mo(this, n2, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this.commands = new Rc(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.set("isReadOnly", false), this.model = new bd();
              const o2 = new Di();
              this.data = new rl(this.model, o2), this.editing = new Oc(this.model, o2), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new sl([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new wd(this), this.keystrokes.listenTo(this.editing.view.document);
            }
            initPlugins() {
              const t3 = this.config, e3 = t3.get("plugins"), n2 = t3.get("removePlugins") || [], o2 = t3.get("extraPlugins") || [], i2 = t3.get("substitutePlugins") || [];
              return this.plugins.init(e3.concat(o2), n2, i2);
            }
            destroy() {
              let t3 = Promise.resolve();
              return "initializing" == this.state && (t3 = new Promise((t4) => this.once("ready", t4))), t3.then(() => {
                this.fire("destroy"), this.stopListening(), this.commands.destroy();
              }).then(() => this.plugins.destroy()).then(() => {
                this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
              }).then(() => this._context._removeEditor(this));
            }
            execute(...t3) {
              try {
                return this.commands.execute(...t3);
              } catch (t4) {
                a.rethrowUnexpectedError(t4, this);
              }
            }
            focus() {
              this.editing.view.focus();
            }
          }
          he(Cd, re);
          class Ad {
            constructor(t3) {
              this.editor = t3, this._components = /* @__PURE__ */ new Map();
            }
            *names() {
              for (const t3 of this._components.values())
                yield t3.originalName;
            }
            add(t3, e3) {
              this._components.set(_d(t3), { callback: e3, originalName: t3 });
            }
            create(t3) {
              if (!this.has(t3))
                throw new a("componentfactory-item-missing", this, { name: t3 });
              return this._components.get(_d(t3)).callback(this.editor.locale);
            }
            has(t3) {
              return this._components.has(_d(t3));
            }
          }
          function _d(t3) {
            return String(t3).toLowerCase();
          }
          class vd {
            constructor(t3) {
              this.editor = t3, this.componentFactory = new Ad(t3), this.focusTracker = new _a(), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this._editableElementsMap = /* @__PURE__ */ new Map(), this.listenTo(t3.editing.view.document, "layoutChanged", () => this.update());
            }
            get element() {
              return null;
            }
            update() {
              this.fire("update");
            }
            destroy() {
              this.stopListening(), this.focusTracker.destroy();
              for (const t3 of this._editableElementsMap.values())
                t3.ckeditorInstance = null;
              this._editableElementsMap = /* @__PURE__ */ new Map();
            }
            setEditableElement(t3, e3) {
              this._editableElementsMap.set(t3, e3), e3.ckeditorInstance || (e3.ckeditorInstance = this.editor);
            }
            getEditableElement(t3 = "main") {
              return this._editableElementsMap.get(t3);
            }
            getEditableElementsNames() {
              return this._editableElementsMap.keys();
            }
            get _editableElements() {
              return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
            }
            _readViewportOffsetFromConfig() {
              const t3 = this.editor, e3 = t3.config.get("ui.viewportOffset");
              if (e3)
                return e3;
              const n2 = t3.config.get("toolbar.viewportTopOffset");
              return n2 ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n2 }) : { top: 0 };
            }
          }
          he(vd, re);
          const yd = { setData(t3) {
            this.data.set(t3);
          }, getData(t3) {
            return this.data.get(t3);
          } }, xd = yd;
          const Ed = { updateSourceElement() {
            if (!this.sourceElement)
              throw new a("editor-missing-sourceelement", this);
            var t3, e3;
            t3 = this.sourceElement, e3 = this.data.get(), t3 instanceof HTMLTextAreaElement && (t3.value = e3), t3.innerHTML = e3;
          } };
          class Dd extends Lo {
            static get pluginName() {
              return "PendingActions";
            }
            init() {
              this.set("hasAny", false), this._actions = new Io({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
            }
            add(t3) {
              if ("string" != typeof t3)
                throw new a("pendingactions-add-invalid-message", this);
              const e3 = Object.create(re);
              return e3.set("message", t3), this._actions.add(e3), this.hasAny = true, e3;
            }
            remove(t3) {
              this._actions.remove(t3), this.hasAny = !!this._actions.length;
            }
            get first() {
              return this._actions.get(0);
            }
            [Symbol.iterator]() {
              return this._actions[Symbol.iterator]();
            }
          }
          const Id = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', Md = { cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: Id };
          function Sd({ emitter: t3, activator: e3, callback: n2, contextElements: o2 }) {
            t3.listenTo(document, "mousedown", (t4, i2) => {
              if (!e3())
                return;
              const r2 = "function" == typeof i2.composedPath ? i2.composedPath() : [];
              for (const t5 of o2)
                if (t5.contains(i2.target) || r2.includes(t5))
                  return;
              n2();
            });
          }
          function Td(t3) {
            t3.set("_isCssTransitionsDisabled", false), t3.disableCssTransitions = () => {
              t3._isCssTransitionsDisabled = true;
            }, t3.enableCssTransitions = () => {
              t3._isCssTransitionsDisabled = false;
            }, t3.extendTemplate({ attributes: { class: [t3.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
          }
          function Nd({ view: t3 }) {
            t3.listenTo(t3.element, "submit", (e3, n2) => {
              n2.preventDefault(), t3.fire("submit");
            }, { useCapture: true });
          }
          class Bd extends Io {
            constructor(t3 = []) {
              super(t3, { idProperty: "viewUid" }), this.on("add", (t4, e3, n2) => {
                this._renderViewIntoCollectionParent(e3, n2);
              }), this.on("remove", (t4, e3) => {
                e3.element && this._parentElement && e3.element.remove();
              }), this._parentElement = null;
            }
            destroy() {
              this.map((t3) => t3.destroy());
            }
            setParent(t3) {
              this._parentElement = t3;
              for (const t4 of this)
                this._renderViewIntoCollectionParent(t4);
            }
            delegate(...t3) {
              if (!t3.length || !t3.every((t4) => "string" == typeof t4))
                throw new a("ui-viewcollection-delegate-wrong-events", this);
              return { to: (e3) => {
                for (const n2 of this)
                  for (const o2 of t3)
                    n2.delegate(o2).to(e3);
                this.on("add", (n2, o2) => {
                  for (const n3 of t3)
                    o2.delegate(n3).to(e3);
                }), this.on("remove", (n2, o2) => {
                  for (const n3 of t3)
                    o2.stopDelegating(n3, e3);
                });
              } };
            }
            _renderViewIntoCollectionParent(t3, e3) {
              t3.isRendered || t3.render(), t3.element && this._parentElement && this._parentElement.insertBefore(t3.element, this._parentElement.children[e3]);
            }
          }
          var zd = n(4793), Pd = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(zd.Z, Pd);
          zd.Z.locals;
          class Ld {
            constructor(t3) {
              this.element = null, this.isRendered = false, this.locale = t3, this.t = t3 && t3.t, this._viewCollections = new Io(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (e3, n2) => {
                n2.locale = t3;
              }), this.decorate("render");
            }
            get bindTemplate() {
              return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Od.bind(this, this);
            }
            createCollection(t3) {
              const e3 = new Bd(t3);
              return this._viewCollections.add(e3), e3;
            }
            registerChild(t3) {
              Do(t3) || (t3 = [t3]);
              for (const e3 of t3)
                this._unboundChildren.add(e3);
            }
            deregisterChild(t3) {
              Do(t3) || (t3 = [t3]);
              for (const e3 of t3)
                this._unboundChildren.remove(e3);
            }
            setTemplate(t3) {
              this.template = new Od(t3);
            }
            extendTemplate(t3) {
              Od.extend(this.template, t3);
            }
            render() {
              if (this.isRendered)
                throw new a("ui-view-render-already-rendered", this);
              this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = true;
            }
            destroy() {
              this.stopListening(), this._viewCollections.map((t3) => t3.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
            }
          }
          he(Ld, ws), he(Ld, re);
          class Od {
            constructor(t3) {
              Object.assign(this, Yd(Gd(t3))), this._isRendered = false, this._revertData = null;
            }
            render() {
              const t3 = this._renderNode({ intoFragment: true });
              return this._isRendered = true, t3;
            }
            apply(t3) {
              return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: t3, isApplying: true, revertData: this._revertData }), t3;
            }
            revert(t3) {
              if (!this._revertData)
                throw new a("ui-template-revert-not-applied", [this, t3]);
              this._revertTemplateFromNode(t3, this._revertData);
            }
            *getViews() {
              yield* function* t3(e3) {
                if (e3.children)
                  for (const n2 of e3.children)
                    Xd(n2) ? yield n2 : th(n2) && (yield* t3(n2));
              }(this);
            }
            static bind(t3, e3) {
              return { to: (n2, o2) => new jd({ eventNameOrFunction: n2, attribute: n2, observable: t3, emitter: e3, callback: o2 }), if: (n2, o2, i2) => new Fd({ observable: t3, emitter: e3, attribute: n2, valueIfTrue: o2, callback: i2 }) };
            }
            static extend(t3, e3) {
              if (t3._isRendered)
                throw new a("template-extend-render", [this, t3]);
              Zd(t3, Yd(Gd(e3)));
            }
            _renderNode(t3) {
              let e3;
              if (e3 = t3.node ? this.tag && this.text : this.tag ? this.text : !this.text, e3)
                throw new a("ui-template-wrong-syntax", this);
              return this.text ? this._renderText(t3) : this._renderElement(t3);
            }
            _renderElement(t3) {
              let e3 = t3.node;
              return e3 || (e3 = t3.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t3), this._renderElementChildren(t3), this._setUpListeners(t3), e3;
            }
            _renderText(t3) {
              let e3 = t3.node;
              return e3 ? t3.revertData.text = e3.textContent : e3 = t3.node = document.createTextNode(""), Vd(this.text) ? this._bindToObservable({ schema: this.text, updater: Hd(e3), data: t3 }) : e3.textContent = this.text.join(""), e3;
            }
            _renderAttributes(t3) {
              let e3, n2, o2, i2;
              if (!this.attributes)
                return;
              const r2 = t3.node, s2 = t3.revertData;
              for (e3 in this.attributes)
                if (o2 = r2.getAttribute(e3), n2 = this.attributes[e3], s2 && (s2.attributes[e3] = o2), i2 = y(n2[0]) && n2[0].ns ? n2[0].ns : null, Vd(n2)) {
                  const a2 = i2 ? n2[0].value : n2;
                  s2 && nh(e3) && a2.unshift(o2), this._bindToObservable({ schema: a2, updater: qd(r2, e3, i2), data: t3 });
                } else
                  "style" == e3 && "string" != typeof n2[0] ? this._renderStyleAttribute(n2[0], t3) : (s2 && o2 && nh(e3) && n2.unshift(o2), n2 = n2.map((t4) => t4 && t4.value || t4).reduce((t4, e4) => t4.concat(e4), []).reduce(Kd, ""), Jd(n2) || r2.setAttributeNS(i2, e3, n2));
            }
            _renderStyleAttribute(t3, e3) {
              const n2 = e3.node;
              for (const o2 in t3) {
                const i2 = t3[o2];
                Vd(i2) ? this._bindToObservable({ schema: [i2], updater: Wd(n2, o2), data: e3 }) : n2.style[o2] = i2;
              }
            }
            _renderElementChildren(t3) {
              const e3 = t3.node, n2 = t3.intoFragment ? document.createDocumentFragment() : e3, o2 = t3.isApplying;
              let i2 = 0;
              for (const r2 of this.children)
                if (eh(r2)) {
                  if (!o2) {
                    r2.setParent(e3);
                    for (const t4 of r2)
                      n2.appendChild(t4.element);
                  }
                } else if (Xd(r2))
                  o2 || (r2.isRendered || r2.render(), n2.appendChild(r2.element));
                else if (Kr(r2))
                  n2.appendChild(r2);
                else if (o2) {
                  const e4 = { children: [], bindings: [], attributes: {} };
                  t3.revertData.children.push(e4), r2._renderNode({ node: n2.childNodes[i2++], isApplying: true, revertData: e4 });
                } else
                  n2.appendChild(r2.render());
              t3.intoFragment && e3.appendChild(n2);
            }
            _setUpListeners(t3) {
              if (this.eventListeners)
                for (const e3 in this.eventListeners) {
                  const n2 = this.eventListeners[e3].map((n3) => {
                    const [o2, i2] = e3.split("@");
                    return n3.activateDomEventListener(o2, i2, t3);
                  });
                  t3.revertData && t3.revertData.bindings.push(n2);
                }
            }
            _bindToObservable({ schema: t3, updater: e3, data: n2 }) {
              const o2 = n2.revertData;
              Ud(t3, e3, n2);
              const i2 = t3.filter((t4) => !Jd(t4)).filter((t4) => t4.observable).map((o3) => o3.activateAttributeListener(t3, e3, n2));
              o2 && o2.bindings.push(i2);
            }
            _revertTemplateFromNode(t3, e3) {
              for (const t4 of e3.bindings)
                for (const e4 of t4)
                  e4();
              if (e3.text)
                t3.textContent = e3.text;
              else {
                for (const n2 in e3.attributes) {
                  const o2 = e3.attributes[n2];
                  null === o2 ? t3.removeAttribute(n2) : t3.setAttribute(n2, o2);
                }
                for (let n2 = 0; n2 < e3.children.length; ++n2)
                  this._revertTemplateFromNode(t3.childNodes[n2], e3.children[n2]);
              }
            }
          }
          he(Od, f);
          class Rd {
            constructor(t3) {
              Object.assign(this, t3);
            }
            getValue(t3) {
              const e3 = this.observable[this.attribute];
              return this.callback ? this.callback(e3, t3) : e3;
            }
            activateAttributeListener(t3, e3, n2) {
              const o2 = () => Ud(t3, e3, n2);
              return this.emitter.listenTo(this.observable, "change:" + this.attribute, o2), () => {
                this.emitter.stopListening(this.observable, "change:" + this.attribute, o2);
              };
            }
          }
          class jd extends Rd {
            activateDomEventListener(t3, e3, n2) {
              const o2 = (t4, n3) => {
                e3 && !n3.target.matches(e3) || ("function" == typeof this.eventNameOrFunction ? this.eventNameOrFunction(n3) : this.observable.fire(this.eventNameOrFunction, n3));
              };
              return this.emitter.listenTo(n2.node, t3, o2), () => {
                this.emitter.stopListening(n2.node, t3, o2);
              };
            }
          }
          class Fd extends Rd {
            getValue(t3) {
              return !Jd(super.getValue(t3)) && (this.valueIfTrue || true);
            }
          }
          function Vd(t3) {
            return !!t3 && (t3.value && (t3 = t3.value), Array.isArray(t3) ? t3.some(Vd) : t3 instanceof Rd);
          }
          function Ud(t3, e3, { node: n2 }) {
            let o2 = function(t4, e4) {
              return t4.map((t5) => t5 instanceof Rd ? t5.getValue(e4) : t5);
            }(t3, n2);
            o2 = 1 == t3.length && t3[0] instanceof Fd ? o2[0] : o2.reduce(Kd, ""), Jd(o2) ? e3.remove() : e3.set(o2);
          }
          function Hd(t3) {
            return { set(e3) {
              t3.textContent = e3;
            }, remove() {
              t3.textContent = "";
            } };
          }
          function qd(t3, e3, n2) {
            return { set(o2) {
              t3.setAttributeNS(n2, e3, o2);
            }, remove() {
              t3.removeAttributeNS(n2, e3);
            } };
          }
          function Wd(t3, e3) {
            return { set(n2) {
              t3.style[e3] = n2;
            }, remove() {
              t3.style[e3] = null;
            } };
          }
          function Gd(t3) {
            return _o(t3, (t4) => {
              if (t4 && (t4 instanceof Rd || th(t4) || Xd(t4) || eh(t4)))
                return t4;
            });
          }
          function Yd(t3) {
            if ("string" == typeof t3 ? t3 = function(t4) {
              return { text: [t4] };
            }(t3) : t3.text && function(t4) {
              t4.text = So(t4.text);
            }(t3), t3.on && (t3.eventListeners = function(t4) {
              for (const e3 in t4)
                Qd(t4, e3);
              return t4;
            }(t3.on), delete t3.on), !t3.text) {
              t3.attributes && function(t4) {
                for (const e4 in t4)
                  t4[e4].value && (t4[e4].value = So(t4[e4].value)), Qd(t4, e4);
              }(t3.attributes);
              const e3 = [];
              if (t3.children)
                if (eh(t3.children))
                  e3.push(t3.children);
                else
                  for (const n2 of t3.children)
                    th(n2) || Xd(n2) || Kr(n2) ? e3.push(n2) : e3.push(new Od(n2));
              t3.children = e3;
            }
            return t3;
          }
          function Qd(t3, e3) {
            t3[e3] = So(t3[e3]);
          }
          function Kd(t3, e3) {
            return Jd(e3) ? t3 : Jd(t3) ? e3 : `${t3} ${e3}`;
          }
          function $d(t3, e3) {
            for (const n2 in e3)
              t3[n2] ? t3[n2].push(...e3[n2]) : t3[n2] = e3[n2];
          }
          function Zd(t3, e3) {
            if (e3.attributes && (t3.attributes || (t3.attributes = {}), $d(t3.attributes, e3.attributes)), e3.eventListeners && (t3.eventListeners || (t3.eventListeners = {}), $d(t3.eventListeners, e3.eventListeners)), e3.text && t3.text.push(...e3.text), e3.children && e3.children.length) {
              if (t3.children.length != e3.children.length)
                throw new a("ui-template-extend-children-mismatch", t3);
              let n2 = 0;
              for (const o2 of e3.children)
                Zd(t3.children[n2++], o2);
            }
          }
          function Jd(t3) {
            return !t3 && 0 !== t3;
          }
          function Xd(t3) {
            return t3 instanceof Ld;
          }
          function th(t3) {
            return t3 instanceof Od;
          }
          function eh(t3) {
            return t3 instanceof Bd;
          }
          function nh(t3) {
            return "class" == t3 || "style" == t3;
          }
          const oh = function(t3) {
            return "string" == typeof t3 || !Mt(t3) && _t(t3) && "[object String]" == O(t3);
          };
          class ih extends Bd {
            constructor(t3, e3 = []) {
              super(e3), this.locale = t3;
            }
            attachToDom() {
              this._bodyCollectionContainer = new Od({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
              let t3 = document.querySelector(".ck-body-wrapper");
              t3 || (t3 = function(t4, e3, n2 = {}, o2 = []) {
                const i2 = n2 && n2.xmlns, r2 = i2 ? t4.createElementNS(i2, e3) : t4.createElement(e3);
                for (const t5 in n2)
                  r2.setAttribute(t5, n2[t5]);
                !oh(o2) && Do(o2) || (o2 = [o2]);
                for (let e4 of o2)
                  oh(e4) && (e4 = t4.createTextNode(e4)), r2.appendChild(e4);
                return r2;
              }(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(t3)), t3.appendChild(this._bodyCollectionContainer);
            }
            detachFromDom() {
              super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
              const t3 = document.querySelector(".ck-body-wrapper");
              t3 && 0 == t3.childElementCount && t3.remove();
            }
          }
          var rh = n(6574), sh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(rh.Z, sh);
          rh.Z.locals;
          class ah extends Ld {
            constructor() {
              super();
              const t3 = this.bindTemplate;
              this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon"], viewBox: t3.to("viewBox") } });
            }
            render() {
              super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
                this._updateXMLContent(), this._colorFillPaths();
              }), this.on("change:fillColor", () => {
                this._colorFillPaths();
              });
            }
            _updateXMLContent() {
              if (this.content) {
                const t3 = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e3 = t3.getAttribute("viewBox");
                for (e3 && (this.viewBox = e3), this.element.innerHTML = ""; t3.childNodes.length > 0; )
                  this.element.appendChild(t3.childNodes[0]);
              }
            }
            _colorFillPaths() {
              this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((t3) => {
                t3.style.fill = this.fillColor;
              });
            }
          }
          var ch = n(3332), lh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(ch.Z, lh);
          ch.Z.locals;
          class dh extends Ld {
            constructor(t3) {
              super(t3), this.set("text", ""), this.set("position", "s");
              const e3 = this.bindTemplate;
              this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip", e3.to("position", (t4) => "ck-tooltip_" + t4), e3.if("text", "ck-hidden", (t4) => !t4.trim())] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: e3.to("text") }] }] });
            }
          }
          var hh = n(4906), uh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(hh.Z, uh);
          hh.Z.locals;
          class gh extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.bindTemplate, n2 = r();
              this.set("class"), this.set("labelStyle"), this.set("icon"), this.set("isEnabled", true), this.set("isOn", false), this.set("isVisible", true), this.set("isToggleable", false), this.set("keystroke"), this.set("label"), this.set("tabindex", -1), this.set("tooltip"), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.set("withKeystroke", false), this.children = this.createCollection(), this.tooltipView = this._createTooltipView(), this.labelView = this._createLabelView(n2), this.iconView = new ah(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this)), this.setTemplate({ tag: "button", attributes: { class: ["ck", "ck-button", e3.to("class"), e3.if("isEnabled", "ck-disabled", (t4) => !t4), e3.if("isVisible", "ck-hidden", (t4) => !t4), e3.to("isOn", (t4) => t4 ? "ck-on" : "ck-off"), e3.if("withText", "ck-button_with-text"), e3.if("withKeystroke", "ck-button_with-keystroke")], type: e3.to("type", (t4) => t4 || "button"), tabindex: e3.to("tabindex"), "aria-labelledby": `ck-editor__aria-label_${n2}`, "aria-disabled": e3.if("isEnabled", true, (t4) => !t4), "aria-pressed": e3.to("isOn", (t4) => !!this.isToggleable && String(t4)) }, children: this.children, on: { mousedown: e3.to((t4) => {
                t4.preventDefault();
              }), click: e3.to((t4) => {
                this.isEnabled ? this.fire("execute") : t4.preventDefault();
              }) } });
            }
            render() {
              super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.tooltipView), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
            }
            focus() {
              this.element.focus();
            }
            _createTooltipView() {
              const t3 = new dh();
              return t3.bind("text").to(this, "_tooltipString"), t3.bind("position").to(this, "tooltipPosition"), t3;
            }
            _createLabelView(t3) {
              const e3 = new Ld(), n2 = this.bindTemplate;
              return e3.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: n2.to("labelStyle"), id: `ck-editor__aria-label_${t3}` }, children: [{ text: this.bindTemplate.to("label") }] }), e3;
            }
            _createKeystrokeView() {
              const t3 = new Ld();
              return t3.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t4) => mr(t4)) }] }), t3;
            }
            _getTooltipString(t3, e3, n2) {
              return t3 ? "string" == typeof t3 ? t3 : (n2 && (n2 = mr(n2)), t3 instanceof Function ? t3(e3, n2) : `${e3}${n2 ? ` (${n2})` : ""}`) : "";
            }
          }
          var mh = n(5332), ph = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(mh.Z, ph);
          mh.Z.locals;
          class fh extends gh {
            constructor(t3) {
              super(t3), this.isToggleable = true, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
            }
            render() {
              super.render(), this.children.add(this.toggleSwitchView);
            }
            _createToggleView() {
              const t3 = new Ld();
              return t3.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), t3;
            }
          }
          var kh = n(6781), bh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(kh.Z, bh);
          kh.Z.locals;
          const wh = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
          class Ch extends gh {
            constructor(t3) {
              super(t3), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": true } }), this.delegate("execute").to(this, "open");
            }
            render() {
              super.render(), this.children.add(this.arrowView);
            }
            _createArrowView() {
              const t3 = new ah();
              return t3.content = wh, t3.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), t3;
            }
          }
          var Ah = n(7686), _h = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Ah.Z, _h);
          Ah.Z.locals;
          class vh extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.bindTemplate;
              this.set("class"), this.set("icon"), this.set("isEnabled", true), this.set("isOn", false), this.set("isToggleable", false), this.set("isVisible", true), this.set("keystroke"), this.set("label"), this.set("tabindex", -1), this.set("tooltip"), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new va(), this.focusTracker = new _a(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", e3.to("class"), e3.if("isVisible", "ck-hidden", (t4) => !t4), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
            }
            render() {
              super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (t3, e3) => {
                this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e3());
              }), this.keystrokes.set("arrowleft", (t3, e3) => {
                this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e3());
              });
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
            }
            focus() {
              this.actionView.focus();
            }
            _createActionView() {
              const t3 = new gh();
              return t3.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t3.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), t3.delegate("execute").to(this), t3;
            }
            _createArrowView() {
              const t3 = new gh(), e3 = t3.bindTemplate;
              return t3.icon = wh, t3.extendTemplate({ attributes: { class: "ck-splitbutton__arrow", "aria-haspopup": true, "aria-expanded": e3.to("isOn", (t4) => String(t4)) } }), t3.bind("isEnabled").to(this), t3.delegate("execute").to(this, "open"), t3;
            }
          }
          class yh extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.bindTemplate;
              this.set("isVisible", false), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e3.to("position", (t4) => `ck-dropdown__panel_${t4}`), e3.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: e3.to((t4) => t4.preventDefault()) } });
            }
            focus() {
              this.children.length && this.children.first.focus();
            }
            focusLast() {
              if (this.children.length) {
                const t3 = this.children.last;
                "function" == typeof t3.focusLast ? t3.focusLast() : t3.focus();
              }
            }
          }
          var xh = n(5485), Eh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(xh.Z, Eh);
          xh.Z.locals;
          function Dh({ element: t3, target: e3, positions: n2, limiter: o2, fitInViewport: i2, viewportOffsetConfig: r2 }) {
            R(e3) && (e3 = e3()), R(o2) && (o2 = o2());
            const s2 = function(t4) {
              return t4 && t4.parentNode ? t4.offsetParent === is.document.body ? null : t4.offsetParent : null;
            }(t3), a2 = new fa(t3);
            let c2;
            const l2 = { targetRect: new fa(e3), elementRect: a2, positionedElementAncestor: s2 };
            if (o2 || i2) {
              const t4 = o2 && new fa(o2).getVisible(), e4 = i2 && function(t5) {
                t5 = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t5);
                const e5 = new fa(is.window);
                return e5.top += t5.top, e5.height -= t5.top, e5.bottom -= t5.bottom, e5.height -= t5.bottom, e5;
              }(r2);
              Object.assign(l2, { limiterRect: t4, viewportRect: e4 }), c2 = function(t5, e5) {
                const { elementRect: n3 } = e5, o3 = n3.getArea(), i3 = t5.map((t6) => new Mh(t6, e5)).filter((t6) => !!t6.name);
                let r3 = 0, s3 = null;
                for (const t6 of i3) {
                  const { _limiterIntersectionArea: e6, _viewportIntersectionArea: n4 } = t6;
                  if (e6 === o3)
                    return t6;
                  const i4 = n4 ** 2 + e6 ** 2;
                  i4 > r3 && (r3 = i4, s3 = t6);
                }
                return s3;
              }(n2, l2) || new Mh(n2[0], l2);
            } else
              c2 = new Mh(n2[0], l2);
            return c2;
          }
          function Ih(t3) {
            const { scrollX: e3, scrollY: n2 } = is.window;
            return t3.clone().moveBy(e3, n2);
          }
          class Mh {
            constructor(t3, e3) {
              const n2 = t3(e3.targetRect, e3.elementRect, e3.viewportRect);
              if (!n2)
                return;
              const { left: o2, top: i2, name: r2, config: s2 } = n2;
              Object.assign(this, { name: r2, config: s2 }), this._positioningFunctionCorrdinates = { left: o2, top: i2 }, this._options = e3;
            }
            get left() {
              return this._absoluteRect.left;
            }
            get top() {
              return this._absoluteRect.top;
            }
            get _limiterIntersectionArea() {
              const t3 = this._options.limiterRect;
              if (t3) {
                const e3 = this._options.viewportRect;
                if (!e3)
                  return t3.getIntersectionArea(this._rect);
                {
                  const n2 = t3.getIntersection(e3);
                  if (n2)
                    return n2.getIntersectionArea(this._rect);
                }
              }
              return 0;
            }
            get _viewportIntersectionArea() {
              const t3 = this._options.viewportRect;
              return t3 ? t3.getIntersectionArea(this._rect) : 0;
            }
            get _rect() {
              return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top)), this._cachedRect;
            }
            get _absoluteRect() {
              return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = Ih(this._rect), this._options.positionedElementAncestor && function(t3, e3) {
                const n2 = Ih(new fa(e3)), o2 = ma(e3);
                let i2 = 0, r2 = 0;
                i2 -= n2.left, r2 -= n2.top, i2 += e3.scrollLeft, r2 += e3.scrollTop, i2 -= o2.left, r2 -= o2.top, t3.moveBy(i2, r2);
              }(this._cachedAbsoluteRect, this._options.positionedElementAncestor)), this._cachedAbsoluteRect;
            }
          }
          class Sh extends Ld {
            constructor(t3, e3, n2) {
              super(t3);
              const o2 = this.bindTemplate;
              this.buttonView = e3, this.panelView = n2, this.set("isOpen", false), this.set("isEnabled", true), this.set("class"), this.set("id"), this.set("panelPosition", "auto"), this.keystrokes = new va(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", o2.to("class"), o2.if("isEnabled", "ck-disabled", (t4) => !t4)], id: o2.to("id"), "aria-describedby": o2.to("ariaDescribedById") }, children: [e3, n2] }), e3.extendTemplate({ attributes: { class: ["ck-dropdown__button"] } });
            }
            render() {
              super.render(), this.listenTo(this.buttonView, "open", () => {
                this.isOpen = !this.isOpen;
              }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", () => {
                this.isOpen && ("auto" === this.panelPosition ? this.panelView.position = Sh._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions }).name : this.panelView.position = this.panelPosition);
              }), this.keystrokes.listenTo(this.element);
              const t3 = (t4, e3) => {
                this.isOpen && (this.buttonView.focus(), this.isOpen = false, e3());
              };
              this.keystrokes.set("arrowdown", (t4, e3) => {
                this.buttonView.isEnabled && !this.isOpen && (this.isOpen = true, e3());
              }), this.keystrokes.set("arrowright", (t4, e3) => {
                this.isOpen && e3();
              }), this.keystrokes.set("arrowleft", t3), this.keystrokes.set("esc", t3);
            }
            focus() {
              this.buttonView.focus();
            }
            get _panelPositions() {
              const { south: t3, north: e3, southEast: n2, southWest: o2, northEast: i2, northWest: r2, southMiddleEast: s2, southMiddleWest: a2, northMiddleEast: c2, northMiddleWest: l2 } = Sh.defaultPanelPositions;
              return "rtl" !== this.locale.uiLanguageDirection ? [n2, o2, s2, a2, t3, i2, r2, c2, l2, e3] : [o2, n2, a2, s2, t3, r2, i2, l2, c2, e3];
            }
          }
          function Th(t3) {
            return !!(t3 && t3.getClientRects && t3.getClientRects().length);
          }
          Sh.defaultPanelPositions = { south: (t3, e3) => ({ top: t3.bottom, left: t3.left - (e3.width - t3.width) / 2, name: "s" }), southEast: (t3) => ({ top: t3.bottom, left: t3.left, name: "se" }), southWest: (t3, e3) => ({ top: t3.bottom, left: t3.left - e3.width + t3.width, name: "sw" }), southMiddleEast: (t3, e3) => ({ top: t3.bottom, left: t3.left - (e3.width - t3.width) / 4, name: "sme" }), southMiddleWest: (t3, e3) => ({ top: t3.bottom, left: t3.left - 3 * (e3.width - t3.width) / 4, name: "smw" }), north: (t3, e3) => ({ top: t3.top - e3.height, left: t3.left - (e3.width - t3.width) / 2, name: "n" }), northEast: (t3, e3) => ({ top: t3.top - e3.height, left: t3.left, name: "ne" }), northWest: (t3, e3) => ({ top: t3.top - e3.height, left: t3.left - e3.width + t3.width, name: "nw" }), northMiddleEast: (t3, e3) => ({ top: t3.top - e3.height, left: t3.left - (e3.width - t3.width) / 4, name: "nme" }), northMiddleWest: (t3, e3) => ({ top: t3.top - e3.height, left: t3.left - 3 * (e3.width - t3.width) / 4, name: "nmw" }) }, Sh._getOptimalPosition = Dh;
          class Nh {
            constructor(t3) {
              if (Object.assign(this, t3), t3.actions && t3.keystrokeHandler)
                for (const e3 in t3.actions) {
                  let n2 = t3.actions[e3];
                  "string" == typeof n2 && (n2 = [n2]);
                  for (const o2 of n2)
                    t3.keystrokeHandler.set(o2, (t4, n3) => {
                      this[e3](), n3();
                    });
                }
            }
            get first() {
              return this.focusables.find(Bh) || null;
            }
            get last() {
              return this.focusables.filter(Bh).slice(-1)[0] || null;
            }
            get next() {
              return this._getFocusableItem(1);
            }
            get previous() {
              return this._getFocusableItem(-1);
            }
            get current() {
              let t3 = null;
              return null === this.focusTracker.focusedElement ? null : (this.focusables.find((e3, n2) => {
                const o2 = e3.element === this.focusTracker.focusedElement;
                return o2 && (t3 = n2), o2;
              }), t3);
            }
            focusFirst() {
              this._focus(this.first);
            }
            focusLast() {
              this._focus(this.last);
            }
            focusNext() {
              this._focus(this.next);
            }
            focusPrevious() {
              this._focus(this.previous);
            }
            _focus(t3) {
              t3 && t3.focus();
            }
            _getFocusableItem(t3) {
              const e3 = this.current, n2 = this.focusables.length;
              if (!n2)
                return null;
              if (null === e3)
                return this[1 === t3 ? "first" : "last"];
              let o2 = (e3 + n2 + t3) % n2;
              do {
                const e4 = this.focusables.get(o2);
                if (Bh(e4))
                  return e4;
                o2 = (o2 + n2 + t3) % n2;
              } while (o2 !== e3);
              return null;
            }
          }
          function Bh(t3) {
            return !(!t3.focus || !Th(t3.element));
          }
          class zh extends Ld {
            constructor(t3) {
              super(t3), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
            }
          }
          class Ph extends Ld {
            constructor(t3) {
              super(t3), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
            }
          }
          function Lh(t3) {
            return Array.isArray(t3) ? { items: t3, removeItems: [] } : t3 ? Object.assign({ items: [], removeItems: [] }, t3) : { items: [], removeItems: [] };
          }
          var Oh = n(5542), Rh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Oh.Z, Rh);
          Oh.Z.locals;
          class jh extends Ld {
            constructor(t3, e3) {
              super(t3);
              const n2 = this.bindTemplate, o2 = this.t;
              this.options = e3 || {}, this.set("ariaLabel", o2("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new _a(), this.keystrokes = new va(), this.set("class"), this.set("isCompact", false), this.itemsView = new Fh(t3), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
              const i2 = "rtl" === t3.uiLanguageDirection;
              this._focusCycler = new Nh({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [i2 ? "arrowright" : "arrowleft", "arrowup"], focusNext: [i2 ? "arrowleft" : "arrowright", "arrowdown"] } });
              const r2 = ["ck", "ck-toolbar", n2.to("class"), n2.if("isCompact", "ck-toolbar_compact")];
              var s2;
              this.options.shouldGroupWhenFull && this.options.isFloating && r2.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: r2, role: "toolbar", "aria-label": n2.to("ariaLabel"), style: { maxWidth: n2.to("maxWidth") } }, children: this.children, on: { mousedown: (s2 = this, s2.bindTemplate.to((t4) => {
                t4.target === s2.element && t4.preventDefault();
              })) } }), this._behavior = this.options.shouldGroupWhenFull ? new Uh(this) : new Vh(this);
            }
            render() {
              super.render();
              for (const t3 of this.items)
                this.focusTracker.add(t3.element);
              this.items.on("add", (t3, e3) => {
                this.focusTracker.add(e3.element);
              }), this.items.on("remove", (t3, e3) => {
                this.focusTracker.remove(e3.element);
              }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
            }
            destroy() {
              return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            focusLast() {
              this._focusCycler.focusLast();
            }
            fillFromConfig(t3, e3) {
              const n2 = Lh(t3), o2 = n2.items.filter((t4, o3, i3) => "|" === t4 || -1 === n2.removeItems.indexOf(t4) && ("-" === t4 ? !this.options.shouldGroupWhenFull || (c("toolbarview-line-break-ignored-when-grouping-items", i3), false) : !!e3.has(t4) || (c("toolbarview-item-unavailable", { name: t4 }), false))), i2 = this._cleanSeparators(o2).map((t4) => "|" === t4 ? new zh() : "-" === t4 ? new Ph() : e3.create(t4));
              this.items.addMany(i2);
            }
            _cleanSeparators(t3) {
              const e3 = (t4) => "-" !== t4 && "|" !== t4, n2 = t3.length, o2 = t3.findIndex(e3), i2 = n2 - t3.slice().reverse().findIndex(e3);
              return t3.slice(o2, i2).filter((t4, n3, o3) => {
                if (e3(t4))
                  return true;
                return !(n3 > 0 && o3[n3 - 1] === t4);
              });
            }
          }
          class Fh extends Ld {
            constructor(t3) {
              super(t3), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
            }
          }
          class Vh {
            constructor(t3) {
              const e3 = t3.bindTemplate;
              t3.set("isVertical", false), t3.itemsView.children.bindTo(t3.items).using((t4) => t4), t3.focusables.bindTo(t3.items).using((t4) => t4), t3.extendTemplate({ attributes: { class: [e3.if("isVertical", "ck-toolbar_vertical")] } });
            }
            render() {
            }
            destroy() {
            }
          }
          class Uh {
            constructor(t3) {
              this.view = t3, this.viewChildren = t3.children, this.viewFocusables = t3.focusables, this.viewItemsView = t3.itemsView, this.viewFocusTracker = t3.focusTracker, this.viewLocale = t3.locale, this.ungroupedItems = t3.createCollection(), this.groupedItems = t3.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = false, t3.itemsView.children.bindTo(this.ungroupedItems).using((t4) => t4), this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this)), this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this)), t3.children.on("add", this._updateFocusCycleableItems.bind(this)), t3.children.on("remove", this._updateFocusCycleableItems.bind(this)), t3.items.on("change", (t4, e3) => {
                const n2 = e3.index;
                for (const t5 of e3.removed)
                  n2 >= this.ungroupedItems.length ? this.groupedItems.remove(t5) : this.ungroupedItems.remove(t5);
                for (let t5 = n2; t5 < n2 + e3.added.length; t5++) {
                  const o2 = e3.added[t5 - n2];
                  t5 > this.ungroupedItems.length ? this.groupedItems.add(o2, t5 - this.ungroupedItems.length) : this.ungroupedItems.add(o2, t5);
                }
                this._updateGrouping();
              }), t3.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
            }
            render(t3) {
              this.viewElement = t3.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t3);
            }
            destroy() {
              this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
            }
            _updateGrouping() {
              if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
                return;
              if (!Th(this.viewElement))
                return void (this.shouldUpdateGroupingOnNextResize = true);
              const t3 = this.groupedItems.length;
              let e3;
              for (; this._areItemsOverflowing; )
                this._groupLastItem(), e3 = true;
              if (!e3 && this.groupedItems.length) {
                for (; this.groupedItems.length && !this._areItemsOverflowing; )
                  this._ungroupFirstItem();
                this._areItemsOverflowing && this._groupLastItem();
              }
              this.groupedItems.length !== t3 && this.view.fire("groupedItemsUpdate");
            }
            get _areItemsOverflowing() {
              if (!this.ungroupedItems.length)
                return false;
              const t3 = this.viewElement, e3 = this.viewLocale.uiLanguageDirection, n2 = new fa(t3.lastChild), o2 = new fa(t3);
              if (!this.cachedPadding) {
                const n3 = is.window.getComputedStyle(t3), o3 = "ltr" === e3 ? "paddingRight" : "paddingLeft";
                this.cachedPadding = Number.parseInt(n3[o3]);
              }
              return "ltr" === e3 ? n2.right > o2.right - this.cachedPadding : n2.left < o2.left + this.cachedPadding;
            }
            _enableGroupingOnResize() {
              let t3;
              this.resizeObserver = new wa(this.viewElement, (e3) => {
                t3 && t3 === e3.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = false, this._updateGrouping(), t3 = e3.contentRect.width);
              }), this._updateGrouping();
            }
            _enableGroupingOnMaxWidthChange(t3) {
              t3.on("change:maxWidth", () => {
                this._updateGrouping();
              });
            }
            _groupLastItem() {
              this.groupedItems.length || (this.viewChildren.add(new zh()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
            }
            _ungroupFirstItem() {
              this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
            }
            _createGroupedItemsDropdown() {
              const t3 = this.viewLocale, e3 = t3.t, n2 = Jh(t3);
              return n2.class = "ck-toolbar__grouped-dropdown", n2.panelPosition = "ltr" === t3.uiLanguageDirection ? "sw" : "se", Xh(n2, []), n2.buttonView.set({ label: e3("Show more items"), tooltip: true, tooltipPosition: "rtl" === t3.uiLanguageDirection ? "se" : "sw", icon: Id }), n2.toolbarView.items.bindTo(this.groupedItems).using((t4) => t4), n2;
            }
            _updateFocusCycleableItems() {
              this.viewFocusables.clear(), this.ungroupedItems.map((t3) => {
                this.viewFocusables.add(t3);
              }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
            }
          }
          var Hh = n(1046), qh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Hh.Z, qh);
          Hh.Z.locals;
          class Wh extends Ld {
            constructor() {
              super(), this.items = this.createCollection(), this.focusTracker = new _a(), this.keystrokes = new va(), this._focusCycler = new Nh({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"] }, children: this.items });
            }
            render() {
              super.render();
              for (const t3 of this.items)
                this.focusTracker.add(t3.element);
              this.items.on("add", (t3, e3) => {
                this.focusTracker.add(e3.element);
              }), this.items.on("remove", (t3, e3) => {
                this.focusTracker.remove(e3.element);
              }), this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            focusLast() {
              this._focusCycler.focusLast();
            }
          }
          class Gh extends Ld {
            constructor(t3) {
              super(t3), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item"] }, children: this.children });
            }
            focus() {
              this.children.first.focus();
            }
          }
          class Yh extends Ld {
            constructor(t3) {
              super(t3), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
            }
          }
          var Qh = n(7339), Kh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Qh.Z, Kh);
          Qh.Z.locals;
          var $h = n(3949), Zh = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()($h.Z, Zh);
          $h.Z.locals;
          function Jh(t3, e3 = Ch) {
            const n2 = new e3(t3), o2 = new yh(t3), i2 = new Sh(t3, n2, o2);
            return n2.bind("isEnabled").to(i2), n2 instanceof Ch ? n2.bind("isOn").to(i2, "isOpen") : n2.arrowView.bind("isOn").to(i2, "isOpen"), function(t4) {
              (function(t5) {
                t5.on("render", () => {
                  Sd({ emitter: t5, activator: () => t5.isOpen, callback: () => {
                    t5.isOpen = false;
                  }, contextElements: [t5.element] });
                });
              })(t4), function(t5) {
                t5.on("execute", (e4) => {
                  e4.source instanceof fh || (t5.isOpen = false);
                });
              }(t4), function(t5) {
                t5.keystrokes.set("arrowdown", (e4, n3) => {
                  t5.isOpen && (t5.panelView.focus(), n3());
                }), t5.keystrokes.set("arrowup", (e4, n3) => {
                  t5.isOpen && (t5.panelView.focusLast(), n3());
                });
              }(t4);
            }(i2), i2;
          }
          function Xh(t3, e3) {
            const n2 = t3.locale, o2 = n2.t, i2 = t3.toolbarView = new jh(n2);
            i2.set("ariaLabel", o2("Dropdown toolbar")), t3.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), e3.map((t4) => i2.items.add(t4)), t3.panelView.children.add(i2), i2.items.delegate("execute").to(t3);
          }
          function tu(t3, e3) {
            const n2 = t3.locale, o2 = t3.listView = new Wh(n2);
            o2.items.bindTo(e3).using(({ type: t4, model: e4 }) => {
              if ("separator" === t4)
                return new Yh(n2);
              if ("button" === t4 || "switchbutton" === t4) {
                const o3 = new Gh(n2);
                let i2;
                return i2 = "button" === t4 ? new gh(n2) : new fh(n2), i2.bind(...Object.keys(e4)).to(e4), i2.delegate("execute").to(o3), o3.children.add(i2), o3;
              }
            }), t3.panelView.children.add(o2), o2.items.delegate("execute").to(t3);
          }
          var eu = n(9688), nu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(eu.Z, nu);
          eu.Z.locals;
          class ou extends Ld {
            constructor(t3) {
              super(t3), this.body = new ih(t3);
            }
            render() {
              super.render(), this.body.attachToDom();
            }
            destroy() {
              return this.body.detachFromDom(), super.destroy();
            }
          }
          var iu = n(3662), ru = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(iu.Z, ru);
          iu.Z.locals;
          class su extends Ld {
            constructor(t3) {
              super(t3), this.set("text"), this.set("for"), this.id = `ck-editor__label_${r()}`;
              const e3 = this.bindTemplate;
              this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e3.to("for") }, children: [{ text: e3.to("text") }] });
            }
          }
          class au extends ou {
            constructor(t3) {
              super(t3), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: t3.uiLanguageDirection, lang: t3.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
            }
            _createVoiceLabel() {
              const t3 = this.t, e3 = new su();
              return e3.text = t3("Rich Text Editor"), e3.extendTemplate({ attributes: { class: "ck-voice-label" } }), e3;
            }
          }
          class cu extends Ld {
            constructor(t3, e3, n2) {
              super(t3), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t3.contentLanguage, dir: t3.contentLanguageDirection } }), this.name = null, this.set("isFocused", false), this._editableElement = n2, this._hasExternalElement = !!this._editableElement, this._editingView = e3;
            }
            render() {
              super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
            }
            destroy() {
              this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
            }
            _updateIsFocusedClasses() {
              const t3 = this._editingView;
              function e3(e4) {
                t3.change((n2) => {
                  const o2 = t3.document.getRoot(e4.name);
                  n2.addClass(e4.isFocused ? "ck-focused" : "ck-blurred", o2), n2.removeClass(e4.isFocused ? "ck-blurred" : "ck-focused", o2);
                });
              }
              t3.isRenderingInProgress ? function n2(o2) {
                t3.once("change:isRenderingInProgress", (t4, i2, r2) => {
                  r2 ? n2(o2) : e3(o2);
                });
              }(this) : e3(this);
            }
          }
          class lu extends cu {
            constructor(t3, e3, n2) {
              super(t3, e3, n2), this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } });
            }
            render() {
              super.render();
              const t3 = this._editingView, e3 = this.t;
              t3.change((n2) => {
                const o2 = t3.document.getRoot(this.name);
                n2.setAttribute("aria-label", e3("Rich Text Editor, %0", this.name), o2);
              });
            }
          }
          var du = n(8847), hu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(du.Z, hu);
          du.Z.locals;
          var uu = n(4879), gu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(uu.Z, gu);
          uu.Z.locals;
          class mu extends Ld {
            constructor(t3) {
              super(t3), this.set("value"), this.set("id"), this.set("placeholder"), this.set("isReadOnly", false), this.set("hasError", false), this.set("ariaDescribedById"), this.focusTracker = new _a(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", true), this.set("inputMode", "text");
              const e3 = this.bindTemplate;
              this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", e3.if("isFocused", "ck-input_focused"), e3.if("isEmpty", "ck-input-text_empty"), e3.if("hasError", "ck-error")], id: e3.to("id"), placeholder: e3.to("placeholder"), readonly: e3.to("isReadOnly"), inputmode: e3.to("inputMode"), "aria-invalid": e3.if("hasError", true), "aria-describedby": e3.to("ariaDescribedById") }, on: { input: e3.to((...t4) => {
                this.fire("input", ...t4), this._updateIsEmpty();
              }), change: e3.to(this._updateIsEmpty.bind(this)) } });
            }
            render() {
              super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (t3, e3, n2) => {
                this._setDomElementValue(n2), this._updateIsEmpty();
              });
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy();
            }
            select() {
              this.element.select();
            }
            focus() {
              this.element.focus();
            }
            _updateIsEmpty() {
              this.isEmpty = !this.element.value;
            }
            _setDomElementValue(t3) {
              this.element.value = t3 || 0 === t3 ? t3 : "";
            }
          }
          class pu extends mu {
            constructor(t3) {
              super(t3), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
            }
          }
          var fu = n(2577), ku = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(fu.Z, ku);
          fu.Z.locals;
          class bu extends Ld {
            constructor(t3, e3) {
              super(t3);
              const n2 = `ck-labeled-field-view-${r()}`, o2 = `ck-labeled-field-view-status-${r()}`;
              this.fieldView = e3(this, n2, o2), this.set("label"), this.set("isEnabled", true), this.set("isEmpty", true), this.set("isFocused", false), this.set("errorText", null), this.set("infoText", null), this.set("class"), this.set("placeholder"), this.labelView = this._createLabelView(n2), this.statusView = this._createStatusView(o2), this.bind("_statusText").to(this, "errorText", this, "infoText", (t4, e4) => t4 || e4);
              const i2 = this.bindTemplate;
              this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", i2.to("class"), i2.if("isEnabled", "ck-disabled", (t4) => !t4), i2.if("isEmpty", "ck-labeled-field-view_empty"), i2.if("isFocused", "ck-labeled-field-view_focused"), i2.if("placeholder", "ck-labeled-field-view_placeholder"), i2.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: [this.fieldView, this.labelView] }, this.statusView] });
            }
            _createLabelView(t3) {
              const e3 = new su(this.locale);
              return e3.for = t3, e3.bind("text").to(this, "label"), e3;
            }
            _createStatusView(t3) {
              const e3 = new Ld(this.locale), n2 = this.bindTemplate;
              return e3.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n2.if("errorText", "ck-labeled-field-view__status_error"), n2.if("_statusText", "ck-hidden", (t4) => !t4)], id: t3, role: n2.if("errorText", "alert") }, children: [{ text: n2.to("_statusText") }] }), e3;
            }
            focus() {
              this.fieldView.focus();
            }
          }
          function wu(t3, e3, n2) {
            const o2 = new pu(t3.locale);
            return o2.set({ id: e3, ariaDescribedById: n2 }), o2.bind("isReadOnly").to(t3, "isEnabled", (t4) => !t4), o2.bind("hasError").to(t3, "errorText", (t4) => !!t4), o2.on("input", () => {
              t3.errorText = null;
            }), t3.bind("isEmpty", "isFocused", "placeholder").to(o2), o2;
          }
          class Cu extends Lo {
            static get pluginName() {
              return "Notification";
            }
            init() {
              this.on("show:warning", (t3, e3) => {
                window.alert(e3.message);
              }, { priority: "lowest" });
            }
            showSuccess(t3, e3 = {}) {
              this._showNotification({ message: t3, type: "success", namespace: e3.namespace, title: e3.title });
            }
            showInfo(t3, e3 = {}) {
              this._showNotification({ message: t3, type: "info", namespace: e3.namespace, title: e3.title });
            }
            showWarning(t3, e3 = {}) {
              this._showNotification({ message: t3, type: "warning", namespace: e3.namespace, title: e3.title });
            }
            _showNotification(t3) {
              const e3 = `show:${t3.type}` + (t3.namespace ? `:${t3.namespace}` : "");
              this.fire(e3, { message: t3.message, type: t3.type, title: t3.title || "" });
            }
          }
          class Au {
            constructor(t3, e3) {
              e3 && Jt(this, e3), t3 && this.set(t3);
            }
          }
          function _u(t3) {
            return (e3) => e3 + t3;
          }
          he(Au, re);
          var vu = n(8793), yu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(vu.Z, yu);
          vu.Z.locals;
          const xu = _u("px"), Eu = is.document.body;
          class Du extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.bindTemplate;
              this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", false), this.set("withArrow", true), this.set("class"), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e3.to("position", (t4) => `ck-balloon-panel_${t4}`), e3.if("isVisible", "ck-balloon-panel_visible"), e3.if("withArrow", "ck-balloon-panel_with-arrow"), e3.to("class")], style: { top: e3.to("top", xu), left: e3.to("left", xu) } }, children: this.content });
            }
            show() {
              this.isVisible = true;
            }
            hide() {
              this.isVisible = false;
            }
            attachTo(t3) {
              this.show();
              const e3 = Du.defaultPositions, n2 = Object.assign({}, { element: this.element, positions: [e3.southArrowNorth, e3.southArrowNorthMiddleWest, e3.southArrowNorthMiddleEast, e3.southArrowNorthWest, e3.southArrowNorthEast, e3.northArrowSouth, e3.northArrowSouthMiddleWest, e3.northArrowSouthMiddleEast, e3.northArrowSouthWest, e3.northArrowSouthEast, e3.viewportStickyNorth], limiter: Eu, fitInViewport: true }, t3), o2 = Du._getOptimalPosition(n2), i2 = parseInt(o2.left), r2 = parseInt(o2.top), { name: s2, config: a2 = {} } = o2, { withArrow: c2 = true } = a2;
              Object.assign(this, { top: r2, left: i2, position: s2, withArrow: c2 });
            }
            pin(t3) {
              this.unpin(), this._pinWhenIsVisibleCallback = () => {
                this.isVisible ? this._startPinning(t3) : this._stopPinning();
              }, this._startPinning(t3), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
            }
            unpin() {
              this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
            }
            _startPinning(t3) {
              this.attachTo(t3);
              const e3 = Iu(t3.target), n2 = t3.limiter ? Iu(t3.limiter) : Eu;
              this.listenTo(is.document, "scroll", (o2, i2) => {
                const r2 = i2.target, s2 = e3 && r2.contains(e3), a2 = n2 && r2.contains(n2);
                !s2 && !a2 && e3 && n2 || this.attachTo(t3);
              }, { useCapture: true }), this.listenTo(is.window, "resize", () => {
                this.attachTo(t3);
              });
            }
            _stopPinning() {
              this.stopListening(is.document, "scroll"), this.stopListening(is.window, "resize");
            }
          }
          function Iu(t3) {
            return vo(t3) ? t3 : ga(t3) ? t3.commonAncestorContainer : "function" == typeof t3 ? Iu(t3()) : null;
          }
          Du.arrowHorizontalOffset = 25, Du.arrowVerticalOffset = 10, Du.stickyVerticalOffset = 20, Du._getOptimalPosition = Dh, Du.defaultPositions = function({ horizontalOffset: t3 = Du.arrowHorizontalOffset, verticalOffset: e3 = Du.arrowVerticalOffset, stickyVerticalOffset: n2 = Du.stickyVerticalOffset, config: o2 } = {}) {
            return { northWestArrowSouthWest: (e4, n3) => ({ top: i2(e4, n3), left: e4.left - t3, name: "arrow_sw", ...o2 && { config: o2 } }), northWestArrowSouthMiddleWest: (e4, n3) => ({ top: i2(e4, n3), left: e4.left - 0.25 * n3.width - t3, name: "arrow_smw", ...o2 && { config: o2 } }), northWestArrowSouth: (t4, e4) => ({ top: i2(t4, e4), left: t4.left - e4.width / 2, name: "arrow_s", ...o2 && { config: o2 } }), northWestArrowSouthMiddleEast: (e4, n3) => ({ top: i2(e4, n3), left: e4.left - 0.75 * n3.width + t3, name: "arrow_sme", ...o2 && { config: o2 } }), northWestArrowSouthEast: (e4, n3) => ({ top: i2(e4, n3), left: e4.left - n3.width + t3, name: "arrow_se", ...o2 && { config: o2 } }), northArrowSouthWest: (e4, n3) => ({ top: i2(e4, n3), left: e4.left + e4.width / 2 - t3, name: "arrow_sw", ...o2 && { config: o2 } }), northArrowSouthMiddleWest: (e4, n3) => ({ top: i2(e4, n3), left: e4.left + e4.width / 2 - 0.25 * n3.width - t3, name: "arrow_smw", ...o2 && { config: o2 } }), northArrowSouth: (t4, e4) => ({ top: i2(t4, e4), left: t4.left + t4.width / 2 - e4.width / 2, name: "arrow_s", ...o2 && { config: o2 } }), northArrowSouthMiddleEast: (e4, n3) => ({ top: i2(e4, n3), left: e4.left + e4.width / 2 - 0.75 * n3.width + t3, name: "arrow_sme", ...o2 && { config: o2 } }), northArrowSouthEast: (e4, n3) => ({ top: i2(e4, n3), left: e4.left + e4.width / 2 - n3.width + t3, name: "arrow_se", ...o2 && { config: o2 } }), northEastArrowSouthWest: (e4, n3) => ({ top: i2(e4, n3), left: e4.right - t3, name: "arrow_sw", ...o2 && { config: o2 } }), northEastArrowSouthMiddleWest: (e4, n3) => ({ top: i2(e4, n3), left: e4.right - 0.25 * n3.width - t3, name: "arrow_smw", ...o2 && { config: o2 } }), northEastArrowSouth: (t4, e4) => ({ top: i2(t4, e4), left: t4.right - e4.width / 2, name: "arrow_s", ...o2 && { config: o2 } }), northEastArrowSouthMiddleEast: (e4, n3) => ({ top: i2(e4, n3), left: e4.right - 0.75 * n3.width + t3, name: "arrow_sme", ...o2 && { config: o2 } }), northEastArrowSouthEast: (e4, n3) => ({ top: i2(e4, n3), left: e4.right - n3.width + t3, name: "arrow_se", ...o2 && { config: o2 } }), southWestArrowNorthWest: (e4, n3) => ({ top: r2(e4), left: e4.left - t3, name: "arrow_nw", ...o2 && { config: o2 } }), southWestArrowNorthMiddleWest: (e4, n3) => ({ top: r2(e4), left: e4.left - 0.25 * n3.width - t3, name: "arrow_nmw", ...o2 && { config: o2 } }), southWestArrowNorth: (t4, e4) => ({ top: r2(t4), left: t4.left - e4.width / 2, name: "arrow_n", ...o2 && { config: o2 } }), southWestArrowNorthMiddleEast: (e4, n3) => ({ top: r2(e4), left: e4.left - 0.75 * n3.width + t3, name: "arrow_nme", ...o2 && { config: o2 } }), southWestArrowNorthEast: (e4, n3) => ({ top: r2(e4), left: e4.left - n3.width + t3, name: "arrow_ne", ...o2 && { config: o2 } }), southArrowNorthWest: (e4, n3) => ({ top: r2(e4), left: e4.left + e4.width / 2 - t3, name: "arrow_nw", ...o2 && { config: o2 } }), southArrowNorthMiddleWest: (e4, n3) => ({ top: r2(e4), left: e4.left + e4.width / 2 - 0.25 * n3.width - t3, name: "arrow_nmw", ...o2 && { config: o2 } }), southArrowNorth: (t4, e4) => ({ top: r2(t4), left: t4.left + t4.width / 2 - e4.width / 2, name: "arrow_n", ...o2 && { config: o2 } }), southArrowNorthMiddleEast: (e4, n3) => ({ top: r2(e4), left: e4.left + e4.width / 2 - 0.75 * n3.width + t3, name: "arrow_nme", ...o2 && { config: o2 } }), southArrowNorthEast: (e4, n3) => ({ top: r2(e4), left: e4.left + e4.width / 2 - n3.width + t3, name: "arrow_ne", ...o2 && { config: o2 } }), southEastArrowNorthWest: (e4, n3) => ({ top: r2(e4), left: e4.right - t3, name: "arrow_nw", ...o2 && { config: o2 } }), southEastArrowNorthMiddleWest: (e4, n3) => ({ top: r2(e4), left: e4.right - 0.25 * n3.width - t3, name: "arrow_nmw", ...o2 && { config: o2 } }), southEastArrowNorth: (t4, e4) => ({ top: r2(t4), left: t4.right - e4.width / 2, name: "arrow_n", ...o2 && { config: o2 } }), southEastArrowNorthMiddleEast: (e4, n3) => ({ top: r2(e4), left: e4.right - 0.75 * n3.width + t3, name: "arrow_nme", ...o2 && { config: o2 } }), southEastArrowNorthEast: (e4, n3) => ({ top: r2(e4), left: e4.right - n3.width + t3, name: "arrow_ne", ...o2 && { config: o2 } }), viewportStickyNorth: (t4, e4, i3) => t4.getIntersection(i3) ? { top: i3.top + n2, left: t4.left + t4.width / 2 - e4.width / 2, name: "arrowless", config: { withArrow: false, ...o2 } } : null };
            function i2(t4, n3) {
              return t4.top - n3.height - e3;
            }
            function r2(t4) {
              return t4.bottom + e3;
            }
          }();
          var Mu = n(4650), Su = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Mu.Z, Su);
          Mu.Z.locals;
          var Tu = n(7676), Nu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Tu.Z, Nu);
          Tu.Z.locals;
          const Bu = _u("px");
          class zu extends ue {
            static get pluginName() {
              return "ContextualBalloon";
            }
            constructor(t3) {
              super(t3), this.positionLimiter = () => {
                const t4 = this.editor.editing.view, e3 = t4.document.selection.editableElement;
                return e3 ? t4.domConverter.mapViewToDom(e3.root) : null;
              }, this.set("visibleView", null), this.view = new Du(t3.locale), t3.ui.view.body.add(this.view), t3.ui.focusTracker.add(this.view.element), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this.set("_numberOfStacks", 0), this.set("_singleViewMode", false), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
            }
            destroy() {
              super.destroy(), this.view.destroy(), this._rotatorView.destroy(), this._fakePanelsView.destroy();
            }
            hasView(t3) {
              return Array.from(this._viewToStack.keys()).includes(t3);
            }
            add(t3) {
              if (this.hasView(t3.view))
                throw new a("contextualballoon-add-view-exist", [this, t3]);
              const e3 = t3.stackId || "main";
              if (!this._idToStack.has(e3))
                return this._idToStack.set(e3, /* @__PURE__ */ new Map([[t3.view, t3]])), this._viewToStack.set(t3.view, this._idToStack.get(e3)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !t3.singleViewMode || this.showStack(e3));
              const n2 = this._idToStack.get(e3);
              t3.singleViewMode && this.showStack(e3), n2.set(t3.view, t3), this._viewToStack.set(t3.view, n2), n2 === this._visibleStack && this._showView(t3);
            }
            remove(t3) {
              if (!this.hasView(t3))
                throw new a("contextualballoon-remove-view-not-exist", [this, t3]);
              const e3 = this._viewToStack.get(t3);
              this._singleViewMode && this.visibleView === t3 && (this._singleViewMode = false), this.visibleView === t3 && (1 === e3.size ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e3.values())[e3.size - 2])), 1 === e3.size ? (this._idToStack.delete(this._getStackId(e3)), this._numberOfStacks = this._idToStack.size) : e3.delete(t3), this._viewToStack.delete(t3);
            }
            updatePosition(t3) {
              t3 && (this._visibleStack.get(this.visibleView).position = t3), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
            }
            showStack(t3) {
              this.visibleStack = t3;
              const e3 = this._idToStack.get(t3);
              if (!e3)
                throw new a("contextualballoon-showstack-stack-not-exist", this);
              this._visibleStack !== e3 && this._showView(Array.from(e3.values()).pop());
            }
            get _visibleStack() {
              return this._viewToStack.get(this.visibleView);
            }
            _getStackId(t3) {
              return Array.from(this._idToStack.entries()).find((e3) => e3[1] === t3)[0];
            }
            _showNextStack() {
              const t3 = Array.from(this._idToStack.values());
              let e3 = t3.indexOf(this._visibleStack) + 1;
              t3[e3] || (e3 = 0), this.showStack(this._getStackId(t3[e3]));
            }
            _showPrevStack() {
              const t3 = Array.from(this._idToStack.values());
              let e3 = t3.indexOf(this._visibleStack) - 1;
              t3[e3] || (e3 = t3.length - 1), this.showStack(this._getStackId(t3[e3]));
            }
            _createRotatorView() {
              const t3 = new Pu(this.editor.locale), e3 = this.editor.locale.t;
              return this.view.content.add(t3), t3.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (t4, e4) => !e4 && t4 > 1), t3.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), t3.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t4, n2) => {
                if (n2 < 2)
                  return "";
                const o2 = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                return e3("%0 of %1", [o2, n2]);
              }), t3.buttonNextView.on("execute", () => {
                t3.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
              }), t3.buttonPrevView.on("execute", () => {
                t3.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
              }), t3;
            }
            _createFakePanelsView() {
              const t3 = new Lu(this.editor.locale, this.view);
              return t3.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t4, e3) => !e3 && t4 >= 2 ? Math.min(t4 - 1, 2) : 0), t3.listenTo(this.view, "change:top", () => t3.updatePosition()), t3.listenTo(this.view, "change:left", () => t3.updatePosition()), this.editor.ui.view.body.add(t3), t3;
            }
            _showView({ view: t3, balloonClassName: e3 = "", withArrow: n2 = true, singleViewMode: o2 = false }) {
              this.view.class = e3, this.view.withArrow = n2, this._rotatorView.showView(t3), this.visibleView = t3, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), o2 && (this._singleViewMode = true);
            }
            _getBalloonPosition() {
              let t3 = Array.from(this._visibleStack.values()).pop().position;
              return t3 && (t3.limiter || (t3 = Object.assign({}, t3, { limiter: this.positionLimiter })), t3 = Object.assign({}, t3, { viewportOffsetConfig: this.editor.ui.viewportOffset })), t3;
            }
          }
          class Pu extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = t3.t, n2 = this.bindTemplate;
              this.set("isNavigationVisible", true), this.focusTracker = new _a(), this.buttonPrevView = this._createButtonView(e3("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(e3("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n2.to("isNavigationVisible", (t4) => t4 ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n2.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
            }
            render() {
              super.render(), this.focusTracker.add(this.element);
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy();
            }
            showView(t3) {
              this.hideView(), this.content.add(t3);
            }
            hideView() {
              this.content.clear();
            }
            _createButtonView(t3, e3) {
              const n2 = new gh(this.locale);
              return n2.set({ label: t3, icon: e3, tooltip: true }), n2;
            }
          }
          class Lu extends Ld {
            constructor(t3, e3) {
              super(t3);
              const n2 = this.bindTemplate;
              this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e3, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n2.to("numberOfPanels", (t4) => t4 ? "" : "ck-hidden")], style: { top: n2.to("top", Bu), left: n2.to("left", Bu), width: n2.to("width", Bu), height: n2.to("height", Bu) } }, children: this.content }), this.on("change:numberOfPanels", (t4, e4, n3, o2) => {
                n3 > o2 ? this._addPanels(n3 - o2) : this._removePanels(o2 - n3), this.updatePosition();
              });
            }
            _addPanels(t3) {
              for (; t3--; ) {
                const t4 = new Ld();
                t4.setTemplate({ tag: "div" }), this.content.add(t4), this.registerChild(t4);
              }
            }
            _removePanels(t3) {
              for (; t3--; ) {
                const t4 = this.content.last;
                this.content.remove(t4), this.deregisterChild(t4), t4.destroy();
              }
            }
            updatePosition() {
              if (this.numberOfPanels) {
                const { top: t3, left: e3 } = this._balloonPanelView, { width: n2, height: o2 } = new fa(this._balloonPanelView.element);
                Object.assign(this, { top: t3, left: e3, width: n2, height: o2 });
              }
            }
          }
          var Ou = n(5868), Ru = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Ou.Z, Ru);
          Ou.Z.locals;
          const ju = _u("px");
          class Fu extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.bindTemplate;
              this.set("isActive", false), this.set("isSticky", false), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheLimiter", false), this.set("_hasViewportTopOffset", false), this.content = this.createCollection(), this._contentPanelPlaceholder = new Od({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: e3.to("isSticky", (t4) => t4 ? "block" : "none"), height: e3.to("isSticky", (t4) => t4 ? ju(this._panelRect.height) : null) } } }).render(), this._contentPanel = new Od({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", e3.if("isSticky", "ck-sticky-panel__content_sticky"), e3.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: e3.to("isSticky", (t4) => t4 ? ju(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: e3.to("_hasViewportTopOffset", (t4) => t4 ? ju(this.viewportTopOffset) : null), bottom: e3.to("_isStickyToTheLimiter", (t4) => t4 ? ju(this.limiterBottomOffset) : null), marginLeft: e3.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
            }
            render() {
              super.render(), this._checkIfShouldBeSticky(), this.listenTo(is.window, "scroll", () => {
                this._checkIfShouldBeSticky();
              }), this.listenTo(this, "change:isActive", () => {
                this._checkIfShouldBeSticky();
              });
            }
            _checkIfShouldBeSticky() {
              const t3 = this._panelRect = this._contentPanel.getBoundingClientRect();
              let e3;
              this.limiterElement ? (e3 = this._limiterRect = this.limiterElement.getBoundingClientRect(), this.isSticky = this.isActive && e3.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e3.height) : this.isSticky = false, this.isSticky ? (this._isStickyToTheLimiter = e3.bottom < t3.height + this.limiterBottomOffset + this.viewportTopOffset, this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset, this._marginLeft = this._isStickyToTheLimiter ? null : ju(-is.window.scrollX)) : (this._isStickyToTheLimiter = false, this._hasViewportTopOffset = false, this._marginLeft = null);
            }
          }
          _u("px");
          var Vu = n(9695), Uu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Vu.Z, Uu);
          Vu.Z.locals, _u("px");
          _u("px");
          var Hu = n(4717), qu = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Hu.Z, qu);
          Hu.Z.locals;
          const Wu = /* @__PURE__ */ new WeakMap();
          function Gu(t3) {
            const { view: e3, element: n2, text: o2, isDirectHost: i2 = true, keepOnFocus: r2 = false } = t3, s2 = e3.document;
            Wu.has(s2) || (Wu.set(s2, /* @__PURE__ */ new Map()), s2.registerPostFixer((t4) => Qu(s2, t4))), Wu.get(s2).set(n2, { text: o2, isDirectHost: i2, keepOnFocus: r2, hostElement: i2 ? n2 : null }), e3.change((t4) => Qu(s2, t4));
          }
          function Yu(t3, e3) {
            return !!e3.hasClass("ck-placeholder") && (t3.removeClass("ck-placeholder", e3), true);
          }
          function Qu(t3, e3) {
            const n2 = Wu.get(t3), o2 = [];
            let i2 = false;
            for (const [t4, r2] of n2)
              r2.isDirectHost && (o2.push(t4), Ku(e3, t4, r2) && (i2 = true));
            for (const [t4, r2] of n2) {
              if (r2.isDirectHost)
                continue;
              const n3 = $u(t4);
              n3 && (o2.includes(n3) || (r2.hostElement = n3, Ku(e3, t4, r2) && (i2 = true)));
            }
            return i2;
          }
          function Ku(t3, e3, n2) {
            const { text: o2, isDirectHost: i2, hostElement: r2 } = n2;
            let s2 = false;
            r2.getAttribute("data-placeholder") !== o2 && (t3.setAttribute("data-placeholder", o2, r2), s2 = true);
            return (i2 || 1 == e3.childCount) && function(t4, e4) {
              if (!t4.isAttached())
                return false;
              const n3 = Array.from(t4.getChildren()).some((t5) => !t5.is("uiElement"));
              if (n3)
                return false;
              if (e4)
                return true;
              const o3 = t4.document;
              if (!o3.isFocused)
                return true;
              const i3 = o3.selection.anchor;
              return i3 && i3.parent !== t4;
            }(r2, n2.keepOnFocus) ? function(t4, e4) {
              return !e4.hasClass("ck-placeholder") && (t4.addClass("ck-placeholder", e4), true);
            }(t3, r2) && (s2 = true) : Yu(t3, r2) && (s2 = true), s2;
          }
          function $u(t3) {
            if (t3.childCount) {
              const e3 = t3.getChild(0);
              if (e3.is("element") && !e3.is("uiElement"))
                return e3;
            }
            return null;
          }
          const Zu = /* @__PURE__ */ new Map();
          function Ju(t3, e3, n2) {
            let o2 = Zu.get(t3);
            o2 || (o2 = /* @__PURE__ */ new Map(), Zu.set(t3, o2)), o2.set(e3, n2);
          }
          function Xu(t3) {
            return [t3];
          }
          function tg(t3, e3, n2 = {}) {
            const o2 = function(t4, e4) {
              const n3 = Zu.get(t4);
              return n3 && n3.has(e4) ? n3.get(e4) : Xu;
            }(t3.constructor, e3.constructor);
            try {
              return o2(t3 = t3.clone(), e3, n2);
            } catch (t4) {
              throw t4;
            }
          }
          function eg(t3, e3, n2) {
            t3 = t3.slice(), e3 = e3.slice();
            const o2 = new ng(n2.document, n2.useRelations, n2.forceWeakRemove);
            o2.setOriginalOperations(t3), o2.setOriginalOperations(e3);
            const i2 = o2.originalOperations;
            if (0 == t3.length || 0 == e3.length)
              return { operationsA: t3, operationsB: e3, originalOperations: i2 };
            const r2 = /* @__PURE__ */ new WeakMap();
            for (const e4 of t3)
              r2.set(e4, 0);
            const s2 = { nextBaseVersionA: t3[t3.length - 1].baseVersion + 1, nextBaseVersionB: e3[e3.length - 1].baseVersion + 1, originalOperationsACount: t3.length, originalOperationsBCount: e3.length };
            let a2 = 0;
            for (; a2 < t3.length; ) {
              const n3 = t3[a2], i3 = r2.get(n3);
              if (i3 == e3.length) {
                a2++;
                continue;
              }
              const s3 = e3[i3], c2 = tg(n3, s3, o2.getContext(n3, s3, true)), l2 = tg(s3, n3, o2.getContext(s3, n3, false));
              o2.updateRelation(n3, s3), o2.setOriginalOperations(c2, n3), o2.setOriginalOperations(l2, s3);
              for (const t4 of c2)
                r2.set(t4, i3 + l2.length);
              t3.splice(a2, 1, ...c2), e3.splice(i3, 1, ...l2);
            }
            if (n2.padWithNoOps) {
              const n3 = t3.length - s2.originalOperationsACount, o3 = e3.length - s2.originalOperationsBCount;
              ig(t3, o3 - n3), ig(e3, n3 - o3);
            }
            return og(t3, s2.nextBaseVersionB), og(e3, s2.nextBaseVersionA), { operationsA: t3, operationsB: e3, originalOperations: i2 };
          }
          class ng {
            constructor(t3, e3, n2 = false) {
              this.originalOperations = /* @__PURE__ */ new Map(), this._history = t3.history, this._useRelations = e3, this._forceWeakRemove = !!n2, this._relations = /* @__PURE__ */ new Map();
            }
            setOriginalOperations(t3, e3 = null) {
              const n2 = e3 ? this.originalOperations.get(e3) : null;
              for (const e4 of t3)
                this.originalOperations.set(e4, n2 || e4);
            }
            updateRelation(t3, e3) {
              switch (t3.constructor) {
                case _l:
                  switch (e3.constructor) {
                    case Dl:
                      t3.targetPosition.isEqual(e3.sourcePosition) || e3.movedRange.containsPosition(t3.targetPosition) ? this._setRelation(t3, e3, "insertAtSource") : t3.targetPosition.isEqual(e3.deletionPosition) ? this._setRelation(t3, e3, "insertBetween") : t3.targetPosition.isAfter(e3.sourcePosition) && this._setRelation(t3, e3, "moveTargetAfter");
                      break;
                    case _l:
                      t3.targetPosition.isEqual(e3.sourcePosition) || t3.targetPosition.isBefore(e3.sourcePosition) ? this._setRelation(t3, e3, "insertBefore") : this._setRelation(t3, e3, "insertAfter");
                  }
                  break;
                case Il:
                  switch (e3.constructor) {
                    case Dl:
                      t3.splitPosition.isBefore(e3.sourcePosition) && this._setRelation(t3, e3, "splitBefore");
                      break;
                    case _l:
                      if (t3.splitPosition.isEqual(e3.sourcePosition) || t3.splitPosition.isBefore(e3.sourcePosition))
                        this._setRelation(t3, e3, "splitBefore");
                      else {
                        const n2 = Ya._createFromPositionAndShift(e3.sourcePosition, e3.howMany);
                        if (t3.splitPosition.hasSameParentAs(e3.sourcePosition) && n2.containsPosition(t3.splitPosition)) {
                          const o2 = n2.end.offset - t3.splitPosition.offset, i2 = t3.splitPosition.offset - n2.start.offset;
                          this._setRelation(t3, e3, { howMany: o2, offset: i2 });
                        }
                      }
                  }
                  break;
                case Dl:
                  switch (e3.constructor) {
                    case Dl:
                      t3.targetPosition.isEqual(e3.sourcePosition) || this._setRelation(t3, e3, "mergeTargetNotMoved"), t3.sourcePosition.isEqual(e3.targetPosition) && this._setRelation(t3, e3, "mergeSourceNotMoved"), t3.sourcePosition.isEqual(e3.sourcePosition) && this._setRelation(t3, e3, "mergeSameElement");
                      break;
                    case Il:
                      t3.sourcePosition.isEqual(e3.splitPosition) && this._setRelation(t3, e3, "splitAtSource");
                  }
                  break;
                case yl: {
                  const n2 = t3.newRange;
                  if (!n2)
                    return;
                  switch (e3.constructor) {
                    case _l: {
                      const o2 = Ya._createFromPositionAndShift(e3.sourcePosition, e3.howMany), i2 = o2.containsPosition(n2.start) || o2.start.isEqual(n2.start), r2 = o2.containsPosition(n2.end) || o2.end.isEqual(n2.end);
                      !i2 && !r2 || o2.containsRange(n2) || this._setRelation(t3, e3, { side: i2 ? "left" : "right", path: i2 ? n2.start.path.slice() : n2.end.path.slice() });
                      break;
                    }
                    case Dl: {
                      const o2 = n2.start.isEqual(e3.targetPosition), i2 = n2.start.isEqual(e3.deletionPosition), r2 = n2.end.isEqual(e3.deletionPosition), s2 = n2.end.isEqual(e3.sourcePosition);
                      (o2 || i2 || r2 || s2) && this._setRelation(t3, e3, { wasInLeftElement: o2, wasStartBeforeMergedElement: i2, wasEndBeforeMergedElement: r2, wasInRightElement: s2 });
                      break;
                    }
                  }
                  break;
                }
              }
            }
            getContext(t3, e3, n2) {
              return { aIsStrong: n2, aWasUndone: this._wasUndone(t3), bWasUndone: this._wasUndone(e3), abRelation: this._useRelations ? this._getRelation(t3, e3) : null, baRelation: this._useRelations ? this._getRelation(e3, t3) : null, forceWeakRemove: this._forceWeakRemove };
            }
            _wasUndone(t3) {
              const e3 = this.originalOperations.get(t3);
              return e3.wasUndone || this._history.isUndoneOperation(e3);
            }
            _getRelation(t3, e3) {
              const n2 = this.originalOperations.get(e3), o2 = this._history.getUndoneOperation(n2);
              if (!o2)
                return null;
              const i2 = this.originalOperations.get(t3), r2 = this._relations.get(i2);
              return r2 && r2.get(o2) || null;
            }
            _setRelation(t3, e3, n2) {
              const o2 = this.originalOperations.get(t3), i2 = this.originalOperations.get(e3);
              let r2 = this._relations.get(o2);
              r2 || (r2 = /* @__PURE__ */ new Map(), this._relations.set(o2, r2)), r2.set(i2, n2);
            }
          }
          function og(t3, e3) {
            for (const n2 of t3)
              n2.baseVersion = e3++;
          }
          function ig(t3, e3) {
            for (let n2 = 0; n2 < e3; n2++)
              t3.push(new $l(0));
          }
          function rg(t3, e3, n2) {
            const o2 = t3.nodes.getNode(0).getAttribute(e3);
            if (o2 == n2)
              return null;
            const i2 = new Ya(t3.position, t3.position.getShiftedBy(t3.howMany));
            return new Cl(i2, e3, o2, n2, 0);
          }
          function sg(t3, e3) {
            return null === t3.targetPosition._getTransformedByDeletion(e3.sourcePosition, e3.howMany);
          }
          function ag(t3, e3) {
            const n2 = [];
            for (let o2 = 0; o2 < t3.length; o2++) {
              const i2 = t3[o2], r2 = new _l(i2.start, i2.end.offset - i2.start.offset, e3, 0);
              n2.push(r2);
              for (let e4 = o2 + 1; e4 < t3.length; e4++)
                t3[e4] = t3[e4]._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany)[0];
              e3 = e3._getTransformedByMove(r2.sourcePosition, r2.targetPosition, r2.howMany);
            }
            return n2;
          }
          Ju(Cl, Cl, (t3, e3, n2) => {
            if (t3.key === e3.key && t3.range.start.hasSameParentAs(e3.range.start)) {
              const o2 = t3.range.getDifference(e3.range).map((e4) => new Cl(e4, t3.key, t3.oldValue, t3.newValue, 0)), i2 = t3.range.getIntersection(e3.range);
              return i2 && n2.aIsStrong && o2.push(new Cl(i2, e3.key, e3.newValue, t3.newValue, 0)), 0 == o2.length ? [new $l(0)] : o2;
            }
            return [t3];
          }), Ju(Cl, vl, (t3, e3) => {
            if (t3.range.start.hasSameParentAs(e3.position) && t3.range.containsPosition(e3.position)) {
              const n2 = t3.range._getTransformedByInsertion(e3.position, e3.howMany, !e3.shouldReceiveAttributes).map((e4) => new Cl(e4, t3.key, t3.oldValue, t3.newValue, t3.baseVersion));
              if (e3.shouldReceiveAttributes) {
                const o2 = rg(e3, t3.key, t3.oldValue);
                o2 && n2.unshift(o2);
              }
              return n2;
            }
            return t3.range = t3.range._getTransformedByInsertion(e3.position, e3.howMany, false)[0], [t3];
          }), Ju(Cl, Dl, (t3, e3) => {
            const n2 = [];
            t3.range.start.hasSameParentAs(e3.deletionPosition) && (t3.range.containsPosition(e3.deletionPosition) || t3.range.start.isEqual(e3.deletionPosition)) && n2.push(Ya._createFromPositionAndShift(e3.graveyardPosition, 1));
            const o2 = t3.range._getTransformedByMergeOperation(e3);
            return o2.isCollapsed || n2.push(o2), n2.map((e4) => new Cl(e4, t3.key, t3.oldValue, t3.newValue, t3.baseVersion));
          }), Ju(Cl, _l, (t3, e3) => {
            const n2 = function(t4, e4) {
              const n3 = Ya._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
              let o2 = null, i2 = [];
              n3.containsRange(t4, true) ? o2 = t4 : t4.start.hasSameParentAs(n3.start) ? (i2 = t4.getDifference(n3), o2 = t4.getIntersection(n3)) : i2 = [t4];
              const r2 = [];
              for (let t5 of i2) {
                t5 = t5._getTransformedByDeletion(e4.sourcePosition, e4.howMany);
                const n4 = e4.getMovedRangeStart(), o3 = t5.start.hasSameParentAs(n4);
                t5 = t5._getTransformedByInsertion(n4, e4.howMany, o3), r2.push(...t5);
              }
              o2 && r2.push(o2._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany, false)[0]);
              return r2;
            }(t3.range, e3);
            return n2.map((e4) => new Cl(e4, t3.key, t3.oldValue, t3.newValue, t3.baseVersion));
          }), Ju(Cl, Il, (t3, e3) => {
            if (t3.range.end.isEqual(e3.insertionPosition))
              return e3.graveyardPosition || t3.range.end.offset++, [t3];
            if (t3.range.start.hasSameParentAs(e3.splitPosition) && t3.range.containsPosition(e3.splitPosition)) {
              const n2 = t3.clone();
              return n2.range = new Ya(e3.moveTargetPosition.clone(), t3.range.end._getCombined(e3.splitPosition, e3.moveTargetPosition)), t3.range.end = e3.splitPosition.clone(), t3.range.end.stickiness = "toPrevious", [t3, n2];
            }
            return t3.range = t3.range._getTransformedBySplitOperation(e3), [t3];
          }), Ju(vl, Cl, (t3, e3) => {
            const n2 = [t3];
            if (t3.shouldReceiveAttributes && t3.position.hasSameParentAs(e3.range.start) && e3.range.containsPosition(t3.position)) {
              const o2 = rg(t3, e3.key, e3.newValue);
              o2 && n2.push(o2);
            }
            return n2;
          }), Ju(vl, vl, (t3, e3, n2) => (t3.position.isEqual(e3.position) && n2.aIsStrong || (t3.position = t3.position._getTransformedByInsertOperation(e3)), [t3])), Ju(vl, _l, (t3, e3) => (t3.position = t3.position._getTransformedByMoveOperation(e3), [t3])), Ju(vl, Il, (t3, e3) => (t3.position = t3.position._getTransformedBySplitOperation(e3), [t3])), Ju(vl, Dl, (t3, e3) => (t3.position = t3.position._getTransformedByMergeOperation(e3), [t3])), Ju(yl, vl, (t3, e3) => (t3.oldRange && (t3.oldRange = t3.oldRange._getTransformedByInsertOperation(e3)[0]), t3.newRange && (t3.newRange = t3.newRange._getTransformedByInsertOperation(e3)[0]), [t3])), Ju(yl, yl, (t3, e3, n2) => {
            if (t3.name == e3.name) {
              if (!n2.aIsStrong)
                return [new $l(0)];
              t3.oldRange = e3.newRange ? e3.newRange.clone() : null;
            }
            return [t3];
          }), Ju(yl, Dl, (t3, e3) => (t3.oldRange && (t3.oldRange = t3.oldRange._getTransformedByMergeOperation(e3)), t3.newRange && (t3.newRange = t3.newRange._getTransformedByMergeOperation(e3)), [t3])), Ju(yl, _l, (t3, e3, n2) => {
            if (t3.oldRange && (t3.oldRange = Ya._createFromRanges(t3.oldRange._getTransformedByMoveOperation(e3))), t3.newRange) {
              if (n2.abRelation) {
                const o2 = Ya._createFromRanges(t3.newRange._getTransformedByMoveOperation(e3));
                if ("left" == n2.abRelation.side && e3.targetPosition.isEqual(t3.newRange.start))
                  return t3.newRange.start.path = n2.abRelation.path, t3.newRange.end = o2.end, [t3];
                if ("right" == n2.abRelation.side && e3.targetPosition.isEqual(t3.newRange.end))
                  return t3.newRange.start = o2.start, t3.newRange.end.path = n2.abRelation.path, [t3];
              }
              t3.newRange = Ya._createFromRanges(t3.newRange._getTransformedByMoveOperation(e3));
            }
            return [t3];
          }), Ju(yl, Il, (t3, e3, n2) => {
            if (t3.oldRange && (t3.oldRange = t3.oldRange._getTransformedBySplitOperation(e3)), t3.newRange) {
              if (n2.abRelation) {
                const o2 = t3.newRange._getTransformedBySplitOperation(e3);
                return t3.newRange.start.isEqual(e3.splitPosition) && n2.abRelation.wasStartBeforeMergedElement ? t3.newRange.start = Ha._createAt(e3.insertionPosition) : t3.newRange.start.isEqual(e3.splitPosition) && !n2.abRelation.wasInLeftElement && (t3.newRange.start = Ha._createAt(e3.moveTargetPosition)), t3.newRange.end.isEqual(e3.splitPosition) && n2.abRelation.wasInRightElement ? t3.newRange.end = Ha._createAt(e3.moveTargetPosition) : t3.newRange.end.isEqual(e3.splitPosition) && n2.abRelation.wasEndBeforeMergedElement ? t3.newRange.end = Ha._createAt(e3.insertionPosition) : t3.newRange.end = o2.end, [t3];
              }
              t3.newRange = t3.newRange._getTransformedBySplitOperation(e3);
            }
            return [t3];
          }), Ju(Dl, vl, (t3, e3) => (t3.sourcePosition.hasSameParentAs(e3.position) && (t3.howMany += e3.howMany), t3.sourcePosition = t3.sourcePosition._getTransformedByInsertOperation(e3), t3.targetPosition = t3.targetPosition._getTransformedByInsertOperation(e3), [t3])), Ju(Dl, Dl, (t3, e3, n2) => {
            if (t3.sourcePosition.isEqual(e3.sourcePosition) && t3.targetPosition.isEqual(e3.targetPosition)) {
              if (n2.bWasUndone) {
                const n3 = e3.graveyardPosition.path.slice();
                return n3.push(0), t3.sourcePosition = new Ha(e3.graveyardPosition.root, n3), t3.howMany = 0, [t3];
              }
              return [new $l(0)];
            }
            if (t3.sourcePosition.isEqual(e3.sourcePosition) && !t3.targetPosition.isEqual(e3.targetPosition) && !n2.bWasUndone && "splitAtSource" != n2.abRelation) {
              const o2 = "$graveyard" == t3.targetPosition.root.rootName, i2 = "$graveyard" == e3.targetPosition.root.rootName, r2 = o2 && !i2;
              if (i2 && !o2 || !r2 && n2.aIsStrong) {
                const n3 = e3.targetPosition._getTransformedByMergeOperation(e3), o3 = t3.targetPosition._getTransformedByMergeOperation(e3);
                return [new _l(n3, t3.howMany, o3, 0)];
              }
              return [new $l(0)];
            }
            return t3.sourcePosition.hasSameParentAs(e3.targetPosition) && (t3.howMany += e3.howMany), t3.sourcePosition = t3.sourcePosition._getTransformedByMergeOperation(e3), t3.targetPosition = t3.targetPosition._getTransformedByMergeOperation(e3), t3.graveyardPosition.isEqual(e3.graveyardPosition) && n2.aIsStrong || (t3.graveyardPosition = t3.graveyardPosition._getTransformedByMergeOperation(e3)), [t3];
          }), Ju(Dl, _l, (t3, e3, n2) => {
            const o2 = Ya._createFromPositionAndShift(e3.sourcePosition, e3.howMany);
            return "remove" == e3.type && !n2.bWasUndone && !n2.forceWeakRemove && t3.deletionPosition.hasSameParentAs(e3.sourcePosition) && o2.containsPosition(t3.sourcePosition) ? [new $l(0)] : (t3.sourcePosition.hasSameParentAs(e3.targetPosition) && (t3.howMany += e3.howMany), t3.sourcePosition.hasSameParentAs(e3.sourcePosition) && (t3.howMany -= e3.howMany), t3.sourcePosition = t3.sourcePosition._getTransformedByMoveOperation(e3), t3.targetPosition = t3.targetPosition._getTransformedByMoveOperation(e3), t3.graveyardPosition.isEqual(e3.targetPosition) || (t3.graveyardPosition = t3.graveyardPosition._getTransformedByMoveOperation(e3)), [t3]);
          }), Ju(Dl, Il, (t3, e3, n2) => {
            if (e3.graveyardPosition && (t3.graveyardPosition = t3.graveyardPosition._getTransformedByDeletion(e3.graveyardPosition, 1), t3.deletionPosition.isEqual(e3.graveyardPosition) && (t3.howMany = e3.howMany)), t3.targetPosition.isEqual(e3.splitPosition)) {
              const o2 = 0 != e3.howMany, i2 = e3.graveyardPosition && t3.deletionPosition.isEqual(e3.graveyardPosition);
              if (o2 || i2 || "mergeTargetNotMoved" == n2.abRelation)
                return t3.sourcePosition = t3.sourcePosition._getTransformedBySplitOperation(e3), [t3];
            }
            if (t3.sourcePosition.isEqual(e3.splitPosition)) {
              if ("mergeSourceNotMoved" == n2.abRelation)
                return t3.howMany = 0, t3.targetPosition = t3.targetPosition._getTransformedBySplitOperation(e3), [t3];
              if ("mergeSameElement" == n2.abRelation || t3.sourcePosition.offset > 0)
                return t3.sourcePosition = e3.moveTargetPosition.clone(), t3.targetPosition = t3.targetPosition._getTransformedBySplitOperation(e3), [t3];
            }
            return t3.sourcePosition.hasSameParentAs(e3.splitPosition) && (t3.howMany = e3.splitPosition.offset), t3.sourcePosition = t3.sourcePosition._getTransformedBySplitOperation(e3), t3.targetPosition = t3.targetPosition._getTransformedBySplitOperation(e3), [t3];
          }), Ju(_l, vl, (t3, e3) => {
            const n2 = Ya._createFromPositionAndShift(t3.sourcePosition, t3.howMany)._getTransformedByInsertOperation(e3, false)[0];
            return t3.sourcePosition = n2.start, t3.howMany = n2.end.offset - n2.start.offset, t3.targetPosition.isEqual(e3.position) || (t3.targetPosition = t3.targetPosition._getTransformedByInsertOperation(e3)), [t3];
          }), Ju(_l, _l, (t3, e3, n2) => {
            const o2 = Ya._createFromPositionAndShift(t3.sourcePosition, t3.howMany), i2 = Ya._createFromPositionAndShift(e3.sourcePosition, e3.howMany);
            let r2, s2 = n2.aIsStrong, a2 = !n2.aIsStrong;
            if ("insertBefore" == n2.abRelation || "insertAfter" == n2.baRelation ? a2 = true : "insertAfter" != n2.abRelation && "insertBefore" != n2.baRelation || (a2 = false), r2 = t3.targetPosition.isEqual(e3.targetPosition) && a2 ? t3.targetPosition._getTransformedByDeletion(e3.sourcePosition, e3.howMany) : t3.targetPosition._getTransformedByMove(e3.sourcePosition, e3.targetPosition, e3.howMany), sg(t3, e3) && sg(e3, t3))
              return [e3.getReversed()];
            if (o2.containsPosition(e3.targetPosition) && o2.containsRange(i2, true))
              return o2.start = o2.start._getTransformedByMove(e3.sourcePosition, e3.targetPosition, e3.howMany), o2.end = o2.end._getTransformedByMove(e3.sourcePosition, e3.targetPosition, e3.howMany), ag([o2], r2);
            if (i2.containsPosition(t3.targetPosition) && i2.containsRange(o2, true))
              return o2.start = o2.start._getCombined(e3.sourcePosition, e3.getMovedRangeStart()), o2.end = o2.end._getCombined(e3.sourcePosition, e3.getMovedRangeStart()), ag([o2], r2);
            const c2 = Oo(t3.sourcePosition.getParentPath(), e3.sourcePosition.getParentPath());
            if ("prefix" == c2 || "extension" == c2)
              return o2.start = o2.start._getTransformedByMove(e3.sourcePosition, e3.targetPosition, e3.howMany), o2.end = o2.end._getTransformedByMove(e3.sourcePosition, e3.targetPosition, e3.howMany), ag([o2], r2);
            "remove" != t3.type || "remove" == e3.type || n2.aWasUndone || n2.forceWeakRemove ? "remove" == t3.type || "remove" != e3.type || n2.bWasUndone || n2.forceWeakRemove || (s2 = false) : s2 = true;
            const l2 = [], d2 = o2.getDifference(i2);
            for (const t4 of d2) {
              t4.start = t4.start._getTransformedByDeletion(e3.sourcePosition, e3.howMany), t4.end = t4.end._getTransformedByDeletion(e3.sourcePosition, e3.howMany);
              const n3 = "same" == Oo(t4.start.getParentPath(), e3.getMovedRangeStart().getParentPath()), o3 = t4._getTransformedByInsertion(e3.getMovedRangeStart(), e3.howMany, n3);
              l2.push(...o3);
            }
            const h2 = o2.getIntersection(i2);
            return null !== h2 && s2 && (h2.start = h2.start._getCombined(e3.sourcePosition, e3.getMovedRangeStart()), h2.end = h2.end._getCombined(e3.sourcePosition, e3.getMovedRangeStart()), 0 === l2.length ? l2.push(h2) : 1 == l2.length ? i2.start.isBefore(o2.start) || i2.start.isEqual(o2.start) ? l2.unshift(h2) : l2.push(h2) : l2.splice(1, 0, h2)), 0 === l2.length ? [new $l(t3.baseVersion)] : ag(l2, r2);
          }), Ju(_l, Il, (t3, e3, n2) => {
            let o2 = t3.targetPosition.clone();
            t3.targetPosition.isEqual(e3.insertionPosition) && e3.graveyardPosition && "moveTargetAfter" != n2.abRelation || (o2 = t3.targetPosition._getTransformedBySplitOperation(e3));
            const i2 = Ya._createFromPositionAndShift(t3.sourcePosition, t3.howMany);
            if (i2.end.isEqual(e3.insertionPosition))
              return e3.graveyardPosition || t3.howMany++, t3.targetPosition = o2, [t3];
            if (i2.start.hasSameParentAs(e3.splitPosition) && i2.containsPosition(e3.splitPosition)) {
              let t4 = new Ya(e3.splitPosition, i2.end);
              t4 = t4._getTransformedBySplitOperation(e3);
              return ag([new Ya(i2.start, e3.splitPosition), t4], o2);
            }
            t3.targetPosition.isEqual(e3.splitPosition) && "insertAtSource" == n2.abRelation && (o2 = e3.moveTargetPosition), t3.targetPosition.isEqual(e3.insertionPosition) && "insertBetween" == n2.abRelation && (o2 = t3.targetPosition);
            const r2 = [i2._getTransformedBySplitOperation(e3)];
            if (e3.graveyardPosition) {
              const o3 = i2.start.isEqual(e3.graveyardPosition) || i2.containsPosition(e3.graveyardPosition);
              t3.howMany > 1 && o3 && !n2.aWasUndone && r2.push(Ya._createFromPositionAndShift(e3.insertionPosition, 1));
            }
            return ag(r2, o2);
          }), Ju(_l, Dl, (t3, e3, n2) => {
            const o2 = Ya._createFromPositionAndShift(t3.sourcePosition, t3.howMany);
            if (e3.deletionPosition.hasSameParentAs(t3.sourcePosition) && o2.containsPosition(e3.sourcePosition)) {
              if ("remove" != t3.type || n2.forceWeakRemove) {
                if (1 == t3.howMany)
                  return n2.bWasUndone ? (t3.sourcePosition = e3.graveyardPosition.clone(), t3.targetPosition = t3.targetPosition._getTransformedByMergeOperation(e3), [t3]) : [new $l(0)];
              } else if (!n2.aWasUndone) {
                const n3 = [];
                let o3 = e3.graveyardPosition.clone(), i3 = e3.targetPosition._getTransformedByMergeOperation(e3);
                t3.howMany > 1 && (n3.push(new _l(t3.sourcePosition, t3.howMany - 1, t3.targetPosition, 0)), o3 = o3._getTransformedByMove(t3.sourcePosition, t3.targetPosition, t3.howMany - 1), i3 = i3._getTransformedByMove(t3.sourcePosition, t3.targetPosition, t3.howMany - 1));
                const r2 = e3.deletionPosition._getCombined(t3.sourcePosition, t3.targetPosition), s2 = new _l(o3, 1, r2, 0), a2 = s2.getMovedRangeStart().path.slice();
                a2.push(0);
                const c2 = new Ha(s2.targetPosition.root, a2);
                i3 = i3._getTransformedByMove(o3, r2, 1);
                const l2 = new _l(i3, e3.howMany, c2, 0);
                return n3.push(s2), n3.push(l2), n3;
              }
            }
            const i2 = Ya._createFromPositionAndShift(t3.sourcePosition, t3.howMany)._getTransformedByMergeOperation(e3);
            return t3.sourcePosition = i2.start, t3.howMany = i2.end.offset - i2.start.offset, t3.targetPosition = t3.targetPosition._getTransformedByMergeOperation(e3), [t3];
          }), Ju(xl, vl, (t3, e3) => (t3.position = t3.position._getTransformedByInsertOperation(e3), [t3])), Ju(xl, Dl, (t3, e3) => t3.position.isEqual(e3.deletionPosition) ? (t3.position = e3.graveyardPosition.clone(), t3.position.stickiness = "toNext", [t3]) : (t3.position = t3.position._getTransformedByMergeOperation(e3), [t3])), Ju(xl, _l, (t3, e3) => (t3.position = t3.position._getTransformedByMoveOperation(e3), [t3])), Ju(xl, xl, (t3, e3, n2) => {
            if (t3.position.isEqual(e3.position)) {
              if (!n2.aIsStrong)
                return [new $l(0)];
              t3.oldName = e3.newName;
            }
            return [t3];
          }), Ju(xl, Il, (t3, e3) => {
            if ("same" == Oo(t3.position.path, e3.splitPosition.getParentPath()) && !e3.graveyardPosition) {
              const e4 = new xl(t3.position.getShiftedBy(1), t3.oldName, t3.newName, 0);
              return [t3, e4];
            }
            return t3.position = t3.position._getTransformedBySplitOperation(e3), [t3];
          }), Ju(El, El, (t3, e3, n2) => {
            if (t3.root === e3.root && t3.key === e3.key) {
              if (!n2.aIsStrong || t3.newValue === e3.newValue)
                return [new $l(0)];
              t3.oldValue = e3.newValue;
            }
            return [t3];
          }), Ju(Il, vl, (t3, e3) => (t3.splitPosition.hasSameParentAs(e3.position) && t3.splitPosition.offset < e3.position.offset && (t3.howMany += e3.howMany), t3.splitPosition = t3.splitPosition._getTransformedByInsertOperation(e3), t3.insertionPosition = t3.insertionPosition._getTransformedByInsertOperation(e3), [t3])), Ju(Il, Dl, (t3, e3, n2) => {
            if (!t3.graveyardPosition && !n2.bWasUndone && t3.splitPosition.hasSameParentAs(e3.sourcePosition)) {
              const n3 = e3.graveyardPosition.path.slice();
              n3.push(0);
              const o2 = new Ha(e3.graveyardPosition.root, n3), i2 = Il.getInsertionPosition(new Ha(e3.graveyardPosition.root, n3)), r2 = new Il(o2, 0, i2, null, 0);
              return t3.splitPosition = t3.splitPosition._getTransformedByMergeOperation(e3), t3.insertionPosition = Il.getInsertionPosition(t3.splitPosition), t3.graveyardPosition = r2.insertionPosition.clone(), t3.graveyardPosition.stickiness = "toNext", [r2, t3];
            }
            return t3.splitPosition.hasSameParentAs(e3.deletionPosition) && !t3.splitPosition.isAfter(e3.deletionPosition) && t3.howMany--, t3.splitPosition.hasSameParentAs(e3.targetPosition) && (t3.howMany += e3.howMany), t3.splitPosition = t3.splitPosition._getTransformedByMergeOperation(e3), t3.insertionPosition = Il.getInsertionPosition(t3.splitPosition), t3.graveyardPosition && (t3.graveyardPosition = t3.graveyardPosition._getTransformedByMergeOperation(e3)), [t3];
          }), Ju(Il, _l, (t3, e3, n2) => {
            const o2 = Ya._createFromPositionAndShift(e3.sourcePosition, e3.howMany);
            if (t3.graveyardPosition) {
              const i3 = o2.start.isEqual(t3.graveyardPosition) || o2.containsPosition(t3.graveyardPosition);
              if (!n2.bWasUndone && i3) {
                const n3 = t3.splitPosition._getTransformedByMoveOperation(e3), o3 = t3.graveyardPosition._getTransformedByMoveOperation(e3), i4 = o3.path.slice();
                i4.push(0);
                const r2 = new Ha(o3.root, i4);
                return [new _l(n3, t3.howMany, r2, 0)];
              }
              t3.graveyardPosition = t3.graveyardPosition._getTransformedByMoveOperation(e3);
            }
            const i2 = t3.splitPosition.isEqual(e3.targetPosition);
            if (i2 && ("insertAtSource" == n2.baRelation || "splitBefore" == n2.abRelation))
              return t3.howMany += e3.howMany, t3.splitPosition = t3.splitPosition._getTransformedByDeletion(e3.sourcePosition, e3.howMany), t3.insertionPosition = Il.getInsertionPosition(t3.splitPosition), [t3];
            if (i2 && n2.abRelation && n2.abRelation.howMany) {
              const { howMany: e4, offset: o3 } = n2.abRelation;
              return t3.howMany += e4, t3.splitPosition = t3.splitPosition.getShiftedBy(o3), [t3];
            }
            if (t3.splitPosition.hasSameParentAs(e3.sourcePosition) && o2.containsPosition(t3.splitPosition)) {
              const n3 = e3.howMany - (t3.splitPosition.offset - e3.sourcePosition.offset);
              return t3.howMany -= n3, t3.splitPosition.hasSameParentAs(e3.targetPosition) && t3.splitPosition.offset < e3.targetPosition.offset && (t3.howMany += e3.howMany), t3.splitPosition = e3.sourcePosition.clone(), t3.insertionPosition = Il.getInsertionPosition(t3.splitPosition), [t3];
            }
            return e3.sourcePosition.isEqual(e3.targetPosition) || (t3.splitPosition.hasSameParentAs(e3.sourcePosition) && t3.splitPosition.offset <= e3.sourcePosition.offset && (t3.howMany -= e3.howMany), t3.splitPosition.hasSameParentAs(e3.targetPosition) && t3.splitPosition.offset < e3.targetPosition.offset && (t3.howMany += e3.howMany)), t3.splitPosition.stickiness = "toNone", t3.splitPosition = t3.splitPosition._getTransformedByMoveOperation(e3), t3.splitPosition.stickiness = "toNext", t3.graveyardPosition ? t3.insertionPosition = t3.insertionPosition._getTransformedByMoveOperation(e3) : t3.insertionPosition = Il.getInsertionPosition(t3.splitPosition), [t3];
          }), Ju(Il, Il, (t3, e3, n2) => {
            if (t3.splitPosition.isEqual(e3.splitPosition)) {
              if (!t3.graveyardPosition && !e3.graveyardPosition)
                return [new $l(0)];
              if (t3.graveyardPosition && e3.graveyardPosition && t3.graveyardPosition.isEqual(e3.graveyardPosition))
                return [new $l(0)];
              if ("splitBefore" == n2.abRelation)
                return t3.howMany = 0, t3.graveyardPosition = t3.graveyardPosition._getTransformedBySplitOperation(e3), [t3];
            }
            if (t3.graveyardPosition && e3.graveyardPosition && t3.graveyardPosition.isEqual(e3.graveyardPosition)) {
              const o2 = "$graveyard" == t3.splitPosition.root.rootName, i2 = "$graveyard" == e3.splitPosition.root.rootName, r2 = o2 && !i2;
              if (i2 && !o2 || !r2 && n2.aIsStrong) {
                const n3 = [];
                return e3.howMany && n3.push(new _l(e3.moveTargetPosition, e3.howMany, e3.splitPosition, 0)), t3.howMany && n3.push(new _l(t3.splitPosition, t3.howMany, t3.moveTargetPosition, 0)), n3;
              }
              return [new $l(0)];
            }
            if (t3.graveyardPosition && (t3.graveyardPosition = t3.graveyardPosition._getTransformedBySplitOperation(e3)), t3.splitPosition.isEqual(e3.insertionPosition) && "splitBefore" == n2.abRelation)
              return t3.howMany++, [t3];
            if (e3.splitPosition.isEqual(t3.insertionPosition) && "splitBefore" == n2.baRelation) {
              const n3 = e3.insertionPosition.path.slice();
              n3.push(0);
              const o2 = new Ha(e3.insertionPosition.root, n3);
              return [t3, new _l(t3.insertionPosition, 1, o2, 0)];
            }
            return t3.splitPosition.hasSameParentAs(e3.splitPosition) && t3.splitPosition.offset < e3.splitPosition.offset && (t3.howMany -= e3.howMany), t3.splitPosition = t3.splitPosition._getTransformedBySplitOperation(e3), t3.insertionPosition = Il.getInsertionPosition(t3.splitPosition), [t3];
          });
          class cg extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = "click";
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3);
            }
          }
          class lg extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3);
            }
          }
          class dg {
            constructor(t3) {
              this.document = t3;
            }
            createDocumentFragment(t3) {
              return new Ar(this.document, t3);
            }
            createElement(t3, e3, n2) {
              return new Si(this.document, t3, e3, n2);
            }
            createText(t3) {
              return new Fo(this.document, t3);
            }
            clone(t3, e3 = false) {
              return t3._clone(e3);
            }
            appendChild(t3, e3) {
              return e3._appendChild(t3);
            }
            insertChild(t3, e3, n2) {
              return n2._insertChild(t3, e3);
            }
            removeChildren(t3, e3, n2) {
              return n2._removeChildren(t3, e3);
            }
            remove(t3) {
              const e3 = t3.parent;
              return e3 ? this.removeChildren(e3.getChildIndex(t3), 1, e3) : [];
            }
            replace(t3, e3) {
              const n2 = t3.parent;
              if (n2) {
                const o2 = n2.getChildIndex(t3);
                return this.removeChildren(o2, 1, n2), this.insertChild(o2, e3, n2), true;
              }
              return false;
            }
            unwrapElement(t3) {
              const e3 = t3.parent;
              if (e3) {
                const n2 = e3.getChildIndex(t3);
                this.remove(t3), this.insertChild(n2, t3.getChildren(), e3);
              }
            }
            rename(t3, e3) {
              const n2 = new Si(this.document, t3, e3.getAttributes(), e3.getChildren());
              return this.replace(e3, n2) ? n2 : null;
            }
            setAttribute(t3, e3, n2) {
              n2._setAttribute(t3, e3);
            }
            removeAttribute(t3, e3) {
              e3._removeAttribute(t3);
            }
            addClass(t3, e3) {
              e3._addClass(t3);
            }
            removeClass(t3, e3) {
              e3._removeClass(t3);
            }
            setStyle(t3, e3, n2) {
              ye(t3) && void 0 === n2 && (n2 = e3), n2._setStyle(t3, e3);
            }
            removeStyle(t3, e3) {
              e3._removeStyle(t3);
            }
            setCustomProperty(t3, e3, n2) {
              n2._setCustomProperty(t3, e3);
            }
            removeCustomProperty(t3, e3) {
              return e3._removeCustomProperty(t3);
            }
            createPositionAt(t3, e3) {
              return Ri._createAt(t3, e3);
            }
            createPositionAfter(t3) {
              return Ri._createAfter(t3);
            }
            createPositionBefore(t3) {
              return Ri._createBefore(t3);
            }
            createRange(t3, e3) {
              return new ji(t3, e3);
            }
            createRangeOn(t3) {
              return ji._createOn(t3);
            }
            createRangeIn(t3) {
              return ji._createIn(t3);
            }
            createSelection(t3, e3, n2) {
              return new Ui(t3, e3, n2);
            }
          }
          /* @__PURE__ */ new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);
          class hg extends vd {
            constructor(t3, e3) {
              super(t3), this.view = e3, this._toolbarConfig = Lh(t3.config.get("toolbar")), this._elementReplacer = new ua();
            }
            get element() {
              return this.view.element;
            }
            init(t3) {
              const e3 = this.editor, n2 = this.view, o2 = e3.editing.view, i2 = n2.editable, r2 = o2.document.getRoot();
              i2.name = r2.rootName, n2.render();
              const s2 = i2.element;
              this.setEditableElement(i2.name, s2), this.focusTracker.add(s2), n2.editable.bind("isFocused").to(this.focusTracker), o2.attachDomRoot(s2), t3 && this._elementReplacer.replace(t3, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
            }
            destroy() {
              const t3 = this.view, e3 = this.editor.editing.view;
              this._elementReplacer.restore(), e3.detachDomRoot(t3.editable.name), t3.destroy(), super.destroy();
            }
            _initToolbar() {
              const t3 = this.editor, e3 = this.view, n2 = t3.editing.view;
              e3.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e3.stickyPanel.limiterElement = e3.element, e3.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t4 }) => t4), e3.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), function({ origin: t4, originKeystrokeHandler: e4, originFocusTracker: n3, toolbar: o2, beforeFocus: i2, afterBlur: r2 }) {
                n3.add(o2.element), e4.set("Alt+F10", (t5, e5) => {
                  n3.isFocused && !o2.focusTracker.isFocused && (i2 && i2(), o2.focus(), e5());
                }), o2.keystrokes.set("Esc", (e5, n4) => {
                  o2.focusTracker.isFocused && (t4.focus(), r2 && r2(), n4());
                });
              }({ origin: n2, originFocusTracker: this.focusTracker, originKeystrokeHandler: t3.keystrokes, toolbar: e3.toolbar });
            }
            _initPlaceholder() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = e3.document.getRoot(), o2 = t3.sourceElement, i2 = t3.config.get("placeholder") || o2 && "textarea" === o2.tagName.toLowerCase() && o2.getAttribute("placeholder");
              i2 && Gu({ view: e3, element: n2, text: i2, isDirectHost: false, keepOnFocus: true });
            }
          }
          var ug = n(3143), gg = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(ug.Z, gg);
          ug.Z.locals;
          class mg extends au {
            constructor(t3, e3, n2 = {}) {
              super(t3), this.stickyPanel = new Fu(t3), this.toolbar = new jh(t3, { shouldGroupWhenFull: n2.shouldToolbarGroupWhenFull }), this.editable = new lu(t3, e3);
            }
            render() {
              super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
            }
          }
          class pg extends Cd {
            constructor(t3, e3 = {}) {
              if (!vo(t3) && void 0 !== e3.initialData)
                throw new a("editor-create-initial-data", null);
              super(e3), void 0 === this.config.get("initialData") && this.config.set("initialData", function(t4) {
                return vo(t4) ? (e4 = t4, e4 instanceof HTMLTextAreaElement ? e4.value : e4.innerHTML) : t4;
                var e4;
              }(t3)), vo(t3) && (this.sourceElement = t3), this.model.document.createRoot();
              const n2 = !this.config.get("toolbar.shouldNotGroupWhenFull"), o2 = new mg(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n2 });
              this.ui = new hg(this, o2), function(t4) {
                if (!R(t4.updateSourceElement))
                  throw new a("attachtoform-missing-elementapi-interface", t4);
                const e4 = t4.sourceElement;
                if (e4 && "textarea" === e4.tagName.toLowerCase() && e4.form) {
                  let n3;
                  const o3 = e4.form, i2 = () => t4.updateSourceElement();
                  R(o3.submit) && (n3 = o3.submit, o3.submit = () => {
                    i2(), n3.apply(o3);
                  }), o3.addEventListener("submit", i2), t4.on("destroy", () => {
                    o3.removeEventListener("submit", i2), n3 && (o3.submit = n3);
                  });
                }
              }(this);
            }
            destroy() {
              return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
            }
            static create(t3, e3 = {}) {
              return new Promise((n2) => {
                const o2 = new this(t3, e3);
                n2(o2.initPlugins().then(() => o2.ui.init(vo(t3) ? t3 : null)).then(() => o2.data.init(o2.config.get("initialData"))).then(() => o2.fire("ready")).then(() => o2));
              });
            }
          }
          he(pg, xd), he(pg, Ed);
          class fg {
            constructor(t3) {
              this.files = function(t4) {
                const e3 = Array.from(t4.files || []), n2 = Array.from(t4.items || []);
                if (e3.length)
                  return e3;
                return n2.filter((t5) => "file" === t5.kind).map((t5) => t5.getAsFile());
              }(t3), this._native = t3;
            }
            get types() {
              return this._native.types;
            }
            getData(t3) {
              return this._native.getData(t3);
            }
            setData(t3, e3) {
              this._native.setData(t3, e3);
            }
            set effectAllowed(t3) {
              this._native.effectAllowed = t3;
            }
            get effectAllowed() {
              return this._native.effectAllowed;
            }
            set dropEffect(t3) {
              this._native.dropEffect = t3;
            }
            get dropEffect() {
              return this._native.dropEffect;
            }
            get isCanceled() {
              return "none" == this._native.dropEffect || !!this._native.mozUserCancelled;
            }
          }
          class kg extends Gs {
            constructor(t3) {
              super(t3);
              const n2 = this.document;
              function o2(t4) {
                return (o3, i2) => {
                  i2.preventDefault();
                  const r2 = i2.dropRange ? [i2.dropRange] : null, s2 = new e2(n2, t4);
                  n2.fire(s2, { dataTransfer: i2.dataTransfer, method: o3.name, targetRanges: r2, target: i2.target }), s2.stop.called && i2.stopPropagation();
                };
              }
              this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"], this.listenTo(n2, "paste", o2("clipboardInput"), { priority: "low" }), this.listenTo(n2, "drop", o2("clipboardInput"), { priority: "low" }), this.listenTo(n2, "dragover", o2("dragging"), { priority: "low" });
            }
            onDomEvent(t3) {
              const e3 = { dataTransfer: new fg(t3.clipboardData ? t3.clipboardData : t3.dataTransfer) };
              "drop" != t3.type && "dragover" != t3.type || (e3.dropRange = function(t4, e4) {
                const n2 = e4.target.ownerDocument, o2 = e4.clientX, i2 = e4.clientY;
                let r2;
                n2.caretRangeFromPoint && n2.caretRangeFromPoint(o2, i2) ? r2 = n2.caretRangeFromPoint(o2, i2) : e4.rangeParent && (r2 = n2.createRange(), r2.setStart(e4.rangeParent, e4.rangeOffset), r2.collapse(true));
                if (r2)
                  return t4.domConverter.domRangeToView(r2);
                return null;
              }(this.view, t3)), this.fire(t3.type, t3, e3);
            }
          }
          const bg = ["figcaption", "li"];
          function wg(t3) {
            let e3 = "";
            if (t3.is("$text") || t3.is("$textProxy"))
              e3 = t3.data;
            else if (t3.is("element", "img") && t3.hasAttribute("alt"))
              e3 = t3.getAttribute("alt");
            else if (t3.is("element", "br"))
              e3 = "\n";
            else {
              let n2 = null;
              for (const o2 of t3.getChildren()) {
                const t4 = wg(o2);
                n2 && (n2.is("containerElement") || o2.is("containerElement")) && (bg.includes(n2.name) || bg.includes(o2.name) ? e3 += "\n" : e3 += "\n\n"), e3 += t4, n2 = o2;
              }
            }
            return e3;
          }
          class Cg extends ue {
            static get pluginName() {
              return "ClipboardPipeline";
            }
            init() {
              this.editor.editing.view.addObserver(kg), this._setupPasteDrop(), this._setupCopyCut();
            }
            _setupPasteDrop() {
              const t3 = this.editor, n2 = t3.model, o2 = t3.editing.view, i2 = o2.document;
              this.listenTo(i2, "clipboardInput", (e3) => {
                t3.isReadOnly && e3.stop();
              }, { priority: "highest" }), this.listenTo(i2, "clipboardInput", (t4, n3) => {
                const i3 = n3.dataTransfer;
                let r2 = n3.content || "";
                var s2;
                r2 || (i3.getData("text/html") ? r2 = function(t5) {
                  return t5.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t6, e3) => 1 == e3.length ? " " : e3).replace(/<!--[\s\S]*?-->/g, "");
                }(i3.getData("text/html")) : i3.getData("text/plain") && (((s2 = (s2 = i3.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || s2.includes("<br>")) && (s2 = `<p>${s2}</p>`), r2 = s2), r2 = this.editor.data.htmlProcessor.toView(r2));
                const a2 = new e2(this, "inputTransformation");
                this.fire(a2, { content: r2, dataTransfer: i3, targetRanges: n3.targetRanges, method: n3.method }), a2.stop.called && t4.stop(), o2.scrollToTheSelection();
              }, { priority: "low" }), this.listenTo(this, "inputTransformation", (t4, e3) => {
                if (e3.content.isEmpty)
                  return;
                const o3 = this.editor.data.toModel(e3.content, "$clipboardHolder");
                0 != o3.childCount && (t4.stop(), n2.change(() => {
                  this.fire("contentInsertion", { content: o3, method: e3.method, dataTransfer: e3.dataTransfer, targetRanges: e3.targetRanges });
                }));
              }, { priority: "low" }), this.listenTo(this, "contentInsertion", (t4, e3) => {
                e3.resultRange = n2.insertContent(e3.content);
              }, { priority: "low" });
            }
            _setupCopyCut() {
              const t3 = this.editor, e3 = t3.model.document, n2 = t3.editing.view.document;
              function o2(o3, i2) {
                const r2 = i2.dataTransfer;
                i2.preventDefault();
                const s2 = t3.data.toView(t3.model.getSelectedContent(e3.selection));
                n2.fire("clipboardOutput", { dataTransfer: r2, content: s2, method: o3.name });
              }
              this.listenTo(n2, "copy", o2, { priority: "low" }), this.listenTo(n2, "cut", (e4, n3) => {
                t3.isReadOnly ? n3.preventDefault() : o2(e4, n3);
              }, { priority: "low" }), this.listenTo(n2, "clipboardOutput", (n3, o3) => {
                o3.content.isEmpty || (o3.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(o3.content)), o3.dataTransfer.setData("text/plain", wg(o3.content))), "cut" == o3.method && t3.model.deleteContent(e3.selection);
              }, { priority: "low" });
            }
          }
          function* Ag(t3, e3) {
            for (const n2 of e3)
              n2 && t3.getAttributeProperties(n2[0]).copyOnEnter && (yield n2);
          }
          class _g extends me {
            execute() {
              const t3 = this.editor.model, e3 = t3.document;
              t3.change((n2) => {
                !function(t4, e4, n3, o2) {
                  const i2 = n3.isCollapsed, r2 = n3.getFirstRange(), s2 = r2.start.parent, a2 = r2.end.parent;
                  if (o2.isLimit(s2) || o2.isLimit(a2))
                    return void (i2 || s2 != a2 || t4.deleteContent(n3));
                  if (i2) {
                    const t5 = Ag(e4.model.schema, n3.getAttributes());
                    vg(e4, r2.start), e4.setSelectionAttribute(t5);
                  } else {
                    const o3 = !(r2.start.isAtStart && r2.end.isAtEnd), i3 = s2 == a2;
                    t4.deleteContent(n3, { leaveUnmerged: o3 }), o3 && (i3 ? vg(e4, n3.focus) : e4.setSelection(a2, 0));
                  }
                }(this.editor.model, n2, e3.selection, t3.schema), this.fire("afterExecute", { writer: n2 });
              });
            }
          }
          function vg(t3, e3) {
            t3.split(e3), t3.setSelection(e3.parent.nextSibling, 0);
          }
          class yg extends _s {
            constructor(t3) {
              super(t3);
              const e3 = this.document;
              e3.on("keydown", (t4, n2) => {
                if (this.isEnabled && n2.keyCode == dr.enter) {
                  const o2 = new qi(e3, "enter", e3.selection.getFirstRange());
                  e3.fire(o2, new Ws(e3, n2.domEvent, { isSoft: n2.shiftKey })), o2.stop.called && t4.stop();
                }
              });
            }
            observe() {
            }
          }
          class xg extends ue {
            static get pluginName() {
              return "Enter";
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = e3.document;
              e3.addObserver(yg), t3.commands.add("enter", new _g(t3)), this.listenTo(n2, "enter", (n3, o2) => {
                o2.preventDefault(), o2.isSoft || (t3.execute("enter"), e3.scrollToTheSelection());
              }, { priority: "low" });
            }
          }
          class Eg {
            constructor(t3, e3 = 20) {
              this.model = t3, this.size = 0, this.limit = e3, this.isLocked = false, this._changeCallback = (t4, e4) => {
                e4.isLocal && e4.isUndoable && e4 !== this._batch && this._reset(true);
              }, this._selectionChangeCallback = () => {
                this._reset();
              }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
            }
            get batch() {
              return this._batch || (this._batch = this.model.createBatch({ isTyping: true })), this._batch;
            }
            input(t3) {
              this.size += t3, this.size >= this.limit && this._reset(true);
            }
            lock() {
              this.isLocked = true;
            }
            unlock() {
              this.isLocked = false;
            }
            destroy() {
              this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
            }
            _reset(t3) {
              this.isLocked && !t3 || (this._batch = null, this.size = 0);
            }
          }
          class Dg extends me {
            constructor(t3, e3) {
              super(t3), this.direction = e3, this._buffer = new Eg(t3.model, t3.config.get("typing.undoStep"));
            }
            get buffer() {
              return this._buffer;
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.document;
              e3.enqueueChange(this._buffer.batch, (o2) => {
                this._buffer.lock();
                const i2 = o2.createSelection(t3.selection || n2.selection), r2 = t3.sequence || 1, s2 = i2.isCollapsed;
                if (i2.isCollapsed && e3.modifySelection(i2, { direction: this.direction, unit: t3.unit, treatEmojiAsSingleUnit: true }), this._shouldEntireContentBeReplacedWithParagraph(r2))
                  return void this._replaceEntireContentWithParagraph(o2);
                if (this._shouldReplaceFirstBlockWithParagraph(i2, r2))
                  return void this.editor.execute("paragraph", { selection: i2 });
                if (i2.isCollapsed)
                  return;
                let a2 = 0;
                i2.getFirstRange().getMinimalFlatRanges().forEach((t4) => {
                  a2 += Vi(t4.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
                }), e3.deleteContent(i2, { doNotResetEntireContent: s2, direction: this.direction }), this._buffer.input(a2), o2.setSelection(i2), this._buffer.unlock();
              });
            }
            _shouldEntireContentBeReplacedWithParagraph(t3) {
              if (t3 > 1)
                return false;
              const e3 = this.editor.model, n2 = e3.document.selection, o2 = e3.schema.getLimitElement(n2);
              if (!(n2.isCollapsed && n2.containsEntireContent(o2)))
                return false;
              if (!e3.schema.checkChild(o2, "paragraph"))
                return false;
              const i2 = o2.getChild(0);
              return !i2 || "paragraph" !== i2.name;
            }
            _replaceEntireContentWithParagraph(t3) {
              const e3 = this.editor.model, n2 = e3.document.selection, o2 = e3.schema.getLimitElement(n2), i2 = t3.createElement("paragraph");
              t3.remove(t3.createRangeIn(o2)), t3.insert(i2, o2), t3.setSelection(i2, 0);
            }
            _shouldReplaceFirstBlockWithParagraph(t3, e3) {
              const n2 = this.editor.model;
              if (e3 > 1 || "backward" != this.direction)
                return false;
              if (!t3.isCollapsed)
                return false;
              const o2 = t3.getFirstPosition(), i2 = n2.schema.getLimitElement(o2), r2 = i2.getChild(0);
              return o2.parent == r2 && (!!t3.containsEntireContent(r2) && (!!n2.schema.checkChild(i2, "paragraph") && "paragraph" != r2.name));
            }
          }
          function Ig(t3) {
            if (t3.newChildren.length - t3.oldChildren.length != 1)
              return;
            const e3 = function(t4, e4) {
              const n3 = [];
              let o2, i2 = 0;
              return t4.forEach((t5) => {
                "equal" == t5 ? (r2(), i2++) : "insert" == t5 ? (s2("insert") ? o2.values.push(e4[i2]) : (r2(), o2 = { type: "insert", index: i2, values: [e4[i2]] }), i2++) : s2("delete") ? o2.howMany++ : (r2(), o2 = { type: "delete", index: i2, howMany: 1 });
              }), r2(), n3;
              function r2() {
                o2 && (n3.push(o2), o2 = null);
              }
              function s2(t5) {
                return o2 && o2.type == t5;
              }
            }(Wr(t3.oldChildren, t3.newChildren, Mg), t3.newChildren);
            if (e3.length > 1)
              return;
            const n2 = e3[0];
            return n2.values[0] && n2.values[0].is("$text") ? n2 : void 0;
          }
          function Mg(t3, e3) {
            return t3 && t3.is("$text") && e3 && e3.is("$text") ? t3.data === e3.data : t3 === e3;
          }
          function Sg(t3, e3) {
            const n2 = e3.selection, o2 = t3.shiftKey && t3.keyCode === dr.delete, i2 = !n2.isCollapsed;
            return o2 && i2;
          }
          class Tg extends _s {
            constructor(t3) {
              super(t3);
              const e3 = t3.document;
              let n2 = 0;
              function o2(t4, n3, o3) {
                const i2 = new qi(e3, "delete", e3.selection.getFirstRange());
                e3.fire(i2, new Ws(e3, n3, o3)), i2.stop.called && t4.stop();
              }
              e3.on("keyup", (t4, e4) => {
                e4.keyCode != dr.delete && e4.keyCode != dr.backspace || (n2 = 0);
              }), e3.on("keydown", (t4, i2) => {
                if (sr.isWindows && Sg(i2, e3))
                  return;
                const r2 = {};
                if (i2.keyCode == dr.delete)
                  r2.direction = "forward", r2.unit = "character";
                else {
                  if (i2.keyCode != dr.backspace)
                    return;
                  r2.direction = "backward", r2.unit = "codePoint";
                }
                const s2 = sr.isMac ? i2.altKey : i2.ctrlKey;
                r2.unit = s2 ? "word" : r2.unit, r2.sequence = ++n2, o2(t4, i2.domEvent, r2);
              }), sr.isAndroid && e3.on("beforeinput", (e4, n3) => {
                if ("deleteContentBackward" != n3.domEvent.inputType)
                  return;
                const i2 = { unit: "codepoint", direction: "backward", sequence: 1 }, r2 = n3.domTarget.ownerDocument.defaultView.getSelection();
                r2.anchorNode == r2.focusNode && r2.anchorOffset + 1 != r2.focusOffset && (i2.selectionToRemove = t3.domConverter.domSelectionToView(r2)), o2(e4, n3.domEvent, i2);
              });
            }
            observe() {
            }
          }
          class Ng extends ue {
            static get pluginName() {
              return "Delete";
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = e3.document, o2 = t3.model.document;
              e3.addObserver(Tg), this._undoOnBackspace = false;
              const i2 = new Dg(t3, "forward");
              if (t3.commands.add("deleteForward", i2), t3.commands.add("forwardDelete", i2), t3.commands.add("delete", new Dg(t3, "backward")), this.listenTo(n2, "delete", (n3, o3) => {
                const i3 = { unit: o3.unit, sequence: o3.sequence };
                if (o3.selectionToRemove) {
                  const e4 = t3.model.createSelection(), n4 = [];
                  for (const e5 of o3.selectionToRemove.getRanges())
                    n4.push(t3.editing.mapper.toModelRange(e5));
                  e4.setTo(n4), i3.selection = e4;
                }
                t3.execute("forward" == o3.direction ? "deleteForward" : "delete", i3), o3.preventDefault(), e3.scrollToTheSelection();
              }, { priority: "low" }), sr.isAndroid) {
                let t4 = null;
                this.listenTo(n2, "delete", (e4, n3) => {
                  const o3 = n3.domTarget.ownerDocument.defaultView.getSelection();
                  t4 = { anchorNode: o3.anchorNode, anchorOffset: o3.anchorOffset, focusNode: o3.focusNode, focusOffset: o3.focusOffset };
                }, { priority: "lowest" }), this.listenTo(n2, "keyup", (e4, n3) => {
                  if (t4) {
                    const e5 = n3.domTarget.ownerDocument.defaultView.getSelection();
                    e5.collapse(t4.anchorNode, t4.anchorOffset), e5.extend(t4.focusNode, t4.focusOffset), t4 = null;
                  }
                });
              }
              this.editor.plugins.has("UndoEditing") && (this.listenTo(n2, "delete", (e4, n3) => {
                this._undoOnBackspace && "backward" == n3.direction && 1 == n3.sequence && "codePoint" == n3.unit && (this._undoOnBackspace = false, t3.execute("undo"), n3.preventDefault(), e4.stop());
              }, { context: "$capture" }), this.listenTo(o2, "change", () => {
                this._undoOnBackspace = false;
              }));
            }
            requestUndoOnBackspace() {
              this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = true);
            }
          }
          class Bg {
            constructor() {
              this._stack = [];
            }
            add(t3, e3) {
              const n2 = this._stack, o2 = n2[0];
              this._insertDescriptor(t3);
              const i2 = n2[0];
              o2 === i2 || zg(o2, i2) || this.fire("change:top", { oldDescriptor: o2, newDescriptor: i2, writer: e3 });
            }
            remove(t3, e3) {
              const n2 = this._stack, o2 = n2[0];
              this._removeDescriptor(t3);
              const i2 = n2[0];
              o2 === i2 || zg(o2, i2) || this.fire("change:top", { oldDescriptor: o2, newDescriptor: i2, writer: e3 });
            }
            _insertDescriptor(t3) {
              const e3 = this._stack, n2 = e3.findIndex((e4) => e4.id === t3.id);
              if (zg(t3, e3[n2]))
                return;
              n2 > -1 && e3.splice(n2, 1);
              let o2 = 0;
              for (; e3[o2] && Pg(e3[o2], t3); )
                o2++;
              e3.splice(o2, 0, t3);
            }
            _removeDescriptor(t3) {
              const e3 = this._stack, n2 = e3.findIndex((e4) => e4.id === t3);
              n2 > -1 && e3.splice(n2, 1);
            }
          }
          function zg(t3, e3) {
            return t3 && e3 && t3.priority == e3.priority && Lg(t3.classes) == Lg(e3.classes);
          }
          function Pg(t3, e3) {
            return t3.priority > e3.priority || !(t3.priority < e3.priority) && Lg(t3.classes) > Lg(e3.classes);
          }
          function Lg(t3) {
            return Array.isArray(t3) ? t3.sort().join(",") : t3;
          }
          he(Bg, f);
          const Og = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', Rg = "ck-widget_selected";
          function jg(t3) {
            return !!t3.is("element") && !!t3.getCustomProperty("widget");
          }
          function Fg(t3, e3, n2 = {}) {
            if (!t3.is("containerElement"))
              throw new a("widget-to-widget-wrong-element-type", null, { element: t3 });
            return e3.setAttribute("contenteditable", "false", t3), e3.addClass("ck-widget", t3), e3.setCustomProperty("widget", true, t3), t3.getFillerOffset = Yg, n2.label && function(t4, e4, n3) {
              n3.setCustomProperty("widgetLabel", e4, t4);
            }(t3, n2.label, e3), n2.hasSelectionHandle && function(t4, e4) {
              const n3 = e4.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(t5) {
                const e5 = this.toDomElement(t5), n4 = new ah();
                return n4.set("content", Og), n4.render(), e5.appendChild(n4.element), e5;
              });
              e4.insert(e4.createPositionAt(t4, 0), n3), e4.addClass(["ck-widget_with-selection-handle"], t4);
            }(t3, e3), Hg(t3, e3), t3;
          }
          function Vg(t3, e3, n2) {
            if (e3.classes && n2.addClass(So(e3.classes), t3), e3.attributes)
              for (const o2 in e3.attributes)
                n2.setAttribute(o2, e3.attributes[o2], t3);
          }
          function Ug(t3, e3, n2) {
            if (e3.classes && n2.removeClass(So(e3.classes), t3), e3.attributes)
              for (const o2 in e3.attributes)
                n2.removeAttribute(o2, t3);
          }
          function Hg(t3, e3, n2 = Vg, o2 = Ug) {
            const i2 = new Bg();
            i2.on("change:top", (e4, i3) => {
              i3.oldDescriptor && o2(t3, i3.oldDescriptor, i3.writer), i3.newDescriptor && n2(t3, i3.newDescriptor, i3.writer);
            }), e3.setCustomProperty("addHighlight", (t4, e4, n3) => i2.add(e4, n3), t3), e3.setCustomProperty("removeHighlight", (t4, e4, n3) => i2.remove(e4, n3), t3);
          }
          function qg(t3) {
            const e3 = t3.getCustomProperty("widgetLabel");
            return e3 ? "function" == typeof e3 ? e3() : e3 : "";
          }
          function Wg(t3, e3) {
            return e3.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t3), e3.setAttribute("contenteditable", t3.isReadOnly ? "false" : "true", t3), t3.on("change:isReadOnly", (n2, o2, i2) => {
              e3.setAttribute("contenteditable", i2 ? "false" : "true", t3);
            }), t3.on("change:isFocused", (n2, o2, i2) => {
              i2 ? e3.addClass("ck-editor__nested-editable_focused", t3) : e3.removeClass("ck-editor__nested-editable_focused", t3);
            }), Hg(t3, e3), t3;
          }
          function Gg(t3, e3) {
            const n2 = t3.getSelectedElement();
            if (n2) {
              const o3 = $g(t3);
              if (o3)
                return e3.createRange(e3.createPositionAt(n2, o3));
              if (e3.schema.isObject(n2) && !e3.schema.isInline(n2))
                return e3.createRangeOn(n2);
            }
            const o2 = t3.getSelectedBlocks().next().value;
            if (o2) {
              if (o2.isEmpty)
                return e3.createRange(e3.createPositionAt(o2, 0));
              const n3 = e3.createPositionAfter(o2);
              return t3.focus.isTouching(n3) ? e3.createRange(n3) : e3.createRange(e3.createPositionBefore(o2));
            }
            return e3.createRange(t3.focus);
          }
          function Yg() {
            return null;
          }
          const Qg = "widget-type-around";
          function Kg(t3, e3, n2) {
            return t3 && jg(t3) && !n2.isInline(e3);
          }
          function $g(t3) {
            return t3.getAttribute(Qg);
          }
          const Zg = [ur("arrowUp"), ur("arrowRight"), ur("arrowDown"), ur("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
          for (let t3 = 112; t3 <= 135; t3++)
            Zg.push(t3);
          function Jg(t3) {
            return !(!t3.ctrlKey && !t3.metaKey) || Zg.includes(t3.keyCode);
          }
          var Xg = n(4921), tm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Xg.Z, tm);
          Xg.Z.locals;
          const em = ["before", "after"], nm = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild, om = "ck-widget__type-around_disabled";
          class im extends ue {
            static get pluginName() {
              return "WidgetTypeAround";
            }
            static get requires() {
              return [xg, Ng];
            }
            constructor(t3) {
              super(t3), this._currentFakeCaretModelElement = null;
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view;
              this.on("change:isEnabled", (n2, o2, i2) => {
                e3.change((t4) => {
                  for (const n3 of e3.document.roots)
                    i2 ? t4.removeClass(om, n3) : t4.addClass(om, n3);
                }), i2 || t3.model.change((t4) => {
                  t4.removeSelectionAttribute(Qg);
                });
              }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableDeleteContentIntegration();
            }
            destroy() {
              this._currentFakeCaretModelElement = null;
            }
            _insertParagraph(t3, e3) {
              const n2 = this.editor, o2 = n2.editing.view;
              n2.execute("insertParagraph", { position: n2.model.createPositionAt(t3, e3) }), o2.focus(), o2.scrollToTheSelection();
            }
            _listenToIfEnabled(t3, e3, n2, o2) {
              this.listenTo(t3, e3, (...t4) => {
                this.isEnabled && n2(...t4);
              }, o2);
            }
            _insertParagraphAccordingToFakeCaretPosition() {
              const t3 = this.editor.model.document.selection, e3 = $g(t3);
              if (!e3)
                return false;
              const n2 = t3.getSelectedElement();
              return this._insertParagraph(n2, e3), true;
            }
            _enableTypeAroundUIInjection() {
              const t3 = this.editor, e3 = t3.model.schema, n2 = t3.locale.t, o2 = { before: n2("Insert paragraph before block"), after: n2("Insert paragraph after block") };
              t3.editing.downcastDispatcher.on("insert", (t4, n3, i2) => {
                const r2 = i2.mapper.toViewElement(n3.item);
                Kg(r2, n3.item, e3) && function(t5, e4, n4) {
                  const o3 = t5.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(t6) {
                    const n5 = this.toDomElement(t6);
                    return function(t7, e5) {
                      for (const n6 of em) {
                        const o4 = new Od({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n6}`], title: e5[n6] }, children: [t7.ownerDocument.importNode(nm, true)] });
                        t7.appendChild(o4.render());
                      }
                    }(n5, e4), function(t7) {
                      const e5 = new Od({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                      t7.appendChild(e5.render());
                    }(n5), n5;
                  });
                  t5.insert(t5.createPositionAt(n4, "end"), o3);
                }(i2.writer, o2, r2);
              }, { priority: "low" });
            }
            _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
              const t3 = this.editor, e3 = t3.model, n2 = e3.document.selection, o2 = e3.schema, i2 = t3.editing.view;
              function r2(t4) {
                return `ck-widget_type-around_show-fake-caret_${t4}`;
              }
              this._listenToIfEnabled(i2.document, "arrowKey", (t4, e4) => {
                this._handleArrowKeyPress(t4, e4);
              }, { context: [jg, "$text"], priority: "high" }), this._listenToIfEnabled(n2, "change:range", (e4, n3) => {
                n3.directChange && t3.model.change((t4) => {
                  t4.removeSelectionAttribute(Qg);
                });
              }), this._listenToIfEnabled(e3.document, "change:data", () => {
                const e4 = n2.getSelectedElement();
                if (e4) {
                  if (Kg(t3.editing.mapper.toViewElement(e4), e4, o2))
                    return;
                }
                t3.model.change((t4) => {
                  t4.removeSelectionAttribute(Qg);
                });
              }), this._listenToIfEnabled(t3.editing.downcastDispatcher, "selection", (t4, e4, n3) => {
                const i3 = n3.writer;
                if (this._currentFakeCaretModelElement) {
                  const t5 = n3.mapper.toViewElement(this._currentFakeCaretModelElement);
                  t5 && (i3.removeClass(em.map(r2), t5), this._currentFakeCaretModelElement = null);
                }
                const s2 = e4.selection.getSelectedElement();
                if (!s2)
                  return;
                const a2 = n3.mapper.toViewElement(s2);
                if (!Kg(a2, s2, o2))
                  return;
                const c2 = $g(e4.selection);
                c2 && (i3.addClass(r2(c2), a2), this._currentFakeCaretModelElement = s2);
              }), this._listenToIfEnabled(t3.ui.focusTracker, "change:isFocused", (e4, n3, o3) => {
                o3 || t3.model.change((t4) => {
                  t4.removeSelectionAttribute(Qg);
                });
              });
            }
            _handleArrowKeyPress(t3, e3) {
              const n2 = this.editor, o2 = n2.model, i2 = o2.document.selection, r2 = o2.schema, s2 = n2.editing.view, a2 = function(t4, e4) {
                const n3 = pr(t4, e4);
                return "down" === n3 || "right" === n3;
              }(e3.keyCode, n2.locale.contentLanguageDirection), c2 = s2.document.selection.getSelectedElement();
              let l2;
              Kg(c2, n2.editing.mapper.toModelElement(c2), r2) ? l2 = this._handleArrowKeyPressOnSelectedWidget(a2) : i2.isCollapsed ? l2 = this._handleArrowKeyPressWhenSelectionNextToAWidget(a2) : e3.shiftKey || (l2 = this._handleArrowKeyPressWhenNonCollapsedSelection(a2)), l2 && (e3.preventDefault(), t3.stop());
            }
            _handleArrowKeyPressOnSelectedWidget(t3) {
              const e3 = this.editor.model, n2 = $g(e3.document.selection);
              return e3.change((e4) => {
                if (!n2)
                  return e4.setSelectionAttribute(Qg, t3 ? "after" : "before"), true;
                if (!(n2 === (t3 ? "after" : "before")))
                  return e4.removeSelectionAttribute(Qg), true;
                return false;
              });
            }
            _handleArrowKeyPressWhenSelectionNextToAWidget(t3) {
              const e3 = this.editor, n2 = e3.model, o2 = n2.schema, i2 = e3.plugins.get("Widget"), r2 = i2._getObjectElementNextToSelection(t3);
              return !!Kg(e3.editing.mapper.toViewElement(r2), r2, o2) && (n2.change((e4) => {
                i2._setSelectionOverElement(r2), e4.setSelectionAttribute(Qg, t3 ? "before" : "after");
              }), true);
            }
            _handleArrowKeyPressWhenNonCollapsedSelection(t3) {
              const e3 = this.editor, n2 = e3.model, o2 = n2.schema, i2 = e3.editing.mapper, r2 = n2.document.selection, s2 = t3 ? r2.getLastPosition().nodeBefore : r2.getFirstPosition().nodeAfter;
              return !!Kg(i2.toViewElement(s2), s2, o2) && (n2.change((e4) => {
                e4.setSelection(s2, "on"), e4.setSelectionAttribute(Qg, t3 ? "after" : "before");
              }), true);
            }
            _enableInsertingParagraphsOnButtonClick() {
              const t3 = this.editor, e3 = t3.editing.view;
              this._listenToIfEnabled(e3.document, "mousedown", (n2, o2) => {
                const i2 = o2.domTarget.closest(".ck-widget__type-around__button");
                if (!i2)
                  return;
                const r2 = function(t4) {
                  return t4.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
                }(i2), s2 = function(t4, e4) {
                  const n3 = t4.closest(".ck-widget");
                  return e4.mapDomToView(n3);
                }(i2, e3.domConverter), a2 = t3.editing.mapper.toModelElement(s2);
                this._insertParagraph(a2, r2), o2.preventDefault(), n2.stop();
              });
            }
            _enableInsertingParagraphsOnEnterKeypress() {
              const t3 = this.editor, e3 = t3.model.document.selection, n2 = t3.editing.view;
              this._listenToIfEnabled(n2.document, "enter", (n3, o2) => {
                if ("atTarget" != n3.eventPhase)
                  return;
                const i2 = e3.getSelectedElement(), r2 = t3.editing.mapper.toViewElement(i2), s2 = t3.model.schema;
                let a2;
                this._insertParagraphAccordingToFakeCaretPosition() ? a2 = true : Kg(r2, i2, s2) && (this._insertParagraph(i2, o2.isSoft ? "before" : "after"), a2 = true), a2 && (o2.preventDefault(), n3.stop());
              }, { context: jg });
            }
            _enableInsertingParagraphsOnTypingKeystroke() {
              const t3 = this.editor.editing.view, e3 = [dr.enter, dr.delete, dr.backspace];
              this._listenToIfEnabled(t3.document, "keydown", (t4, n2) => {
                e3.includes(n2.keyCode) || Jg(n2) || this._insertParagraphAccordingToFakeCaretPosition();
              }, { priority: "high" });
            }
            _enableDeleteIntegration() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = t3.model, o2 = n2.schema;
              this._listenToIfEnabled(e3.document, "delete", (e4, i2) => {
                if ("atTarget" != e4.eventPhase)
                  return;
                const r2 = $g(n2.document.selection);
                if (!r2)
                  return;
                const s2 = i2.direction, a2 = n2.document.selection.getSelectedElement(), c2 = "forward" == s2;
                if ("before" === r2 === c2)
                  t3.execute("delete", { selection: n2.createSelection(a2, "on") });
                else {
                  const e5 = o2.getNearestSelectionRange(n2.createPositionAt(a2, r2), s2);
                  if (e5)
                    if (e5.isCollapsed) {
                      const i3 = n2.createSelection(e5.start);
                      if (n2.modifySelection(i3, { direction: s2 }), i3.focus.isEqual(e5.start)) {
                        const t4 = function(t5, e6) {
                          let n3 = e6;
                          for (const o3 of e6.getAncestors({ parentFirst: true })) {
                            if (o3.childCount > 1 || t5.isLimit(o3))
                              break;
                            n3 = o3;
                          }
                          return n3;
                        }(o2, e5.start.parent);
                        n2.deleteContent(n2.createSelection(t4, "on"), { doNotAutoparagraph: true });
                      } else
                        n2.change((n3) => {
                          n3.setSelection(e5), t3.execute(c2 ? "deleteForward" : "delete");
                        });
                    } else
                      n2.change((n3) => {
                        n3.setSelection(e5), t3.execute(c2 ? "deleteForward" : "delete");
                      });
                }
                i2.preventDefault(), e4.stop();
              }, { context: jg });
            }
            _enableInsertContentIntegration() {
              const t3 = this.editor, e3 = this.editor.model, n2 = e3.document.selection;
              this._listenToIfEnabled(t3.model, "insertContent", (t4, [o2, i2]) => {
                if (i2 && !i2.is("documentSelection"))
                  return;
                const r2 = $g(n2);
                return r2 ? (t4.stop(), e3.change((t5) => {
                  const i3 = n2.getSelectedElement(), s2 = e3.createPositionAt(i3, r2), a2 = t5.createSelection(s2), c2 = e3.insertContent(o2, a2);
                  return t5.setSelection(a2), c2;
                })) : void 0;
              }, { priority: "high" });
            }
            _enableDeleteContentIntegration() {
              const t3 = this.editor, e3 = this.editor.model.document.selection;
              this._listenToIfEnabled(t3.model, "deleteContent", (t4, [n2]) => {
                if (n2 && !n2.is("documentSelection"))
                  return;
                $g(e3) && t4.stop();
              }, { priority: "high" });
            }
          }
          function rm(t3) {
            const e3 = t3.model;
            return (n2, o2) => {
              const i2 = o2.keyCode == dr.arrowup, r2 = o2.keyCode == dr.arrowdown, s2 = o2.shiftKey, a2 = e3.document.selection;
              if (!i2 && !r2)
                return;
              const c2 = r2;
              if (s2 && function(t4, e4) {
                return !t4.isCollapsed && t4.isBackward == e4;
              }(a2, c2))
                return;
              const l2 = function(t4, e4, n3) {
                const o3 = t4.model;
                if (n3) {
                  const t5 = e4.isCollapsed ? e4.focus : e4.getLastPosition(), n4 = sm(o3, t5, "forward");
                  if (!n4)
                    return null;
                  const i3 = o3.createRange(t5, n4), r3 = am(o3.schema, i3, "backward");
                  return r3 ? o3.createRange(t5, r3) : null;
                }
                {
                  const t5 = e4.isCollapsed ? e4.focus : e4.getFirstPosition(), n4 = sm(o3, t5, "backward");
                  if (!n4)
                    return null;
                  const i3 = o3.createRange(n4, t5), r3 = am(o3.schema, i3, "forward");
                  return r3 ? o3.createRange(r3, t5) : null;
                }
              }(t3, a2, c2);
              if (l2) {
                if (l2.isCollapsed) {
                  if (a2.isCollapsed)
                    return;
                  if (s2)
                    return;
                }
                (l2.isCollapsed || function(t4, e4, n3) {
                  const o3 = t4.model, i3 = t4.view.domConverter;
                  if (n3) {
                    const t5 = o3.createSelection(e4.start);
                    o3.modifySelection(t5), t5.focus.isAtEnd || e4.start.isEqual(t5.focus) || (e4 = o3.createRange(t5.focus, e4.end));
                  }
                  const r3 = t4.mapper.toViewRange(e4), s3 = i3.viewRangeToDom(r3), a3 = fa.getDomRangeRects(s3);
                  let c3;
                  for (const t5 of a3)
                    if (void 0 !== c3) {
                      if (Math.round(t5.top) >= c3)
                        return false;
                      c3 = Math.max(c3, Math.round(t5.bottom));
                    } else
                      c3 = Math.round(t5.bottom);
                  return true;
                }(t3, l2, c2)) && (e3.change((t4) => {
                  const n3 = c2 ? l2.end : l2.start;
                  if (s2) {
                    const o3 = e3.createSelection(a2.anchor);
                    o3.setFocus(n3), t4.setSelection(o3);
                  } else
                    t4.setSelection(n3);
                }), n2.stop(), o2.preventDefault(), o2.stopPropagation());
              }
            };
          }
          function sm(t3, e3, n2) {
            const o2 = t3.schema, i2 = t3.createRangeIn(e3.root), r2 = "forward" == n2 ? "elementStart" : "elementEnd";
            for (const { previousPosition: t4, item: s2, type: a2 } of i2.getWalker({ startPosition: e3, direction: n2 })) {
              if (o2.isLimit(s2) && !o2.isInline(s2))
                return t4;
              if (a2 == r2 && o2.isBlock(s2))
                return null;
            }
            return null;
          }
          function am(t3, e3, n2) {
            const o2 = "backward" == n2 ? e3.end : e3.start;
            if (t3.checkChild(o2, "$text"))
              return o2;
            for (const { nextPosition: o3 } of e3.getWalker({ direction: n2 }))
              if (t3.checkChild(o3, "$text"))
                return o3;
            return null;
          }
          var cm = n(3488), lm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(cm.Z, lm);
          cm.Z.locals;
          class dm extends ue {
            static get pluginName() {
              return "Widget";
            }
            static get requires() {
              return [im, Ng];
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = e3.document;
              this._previouslySelected = /* @__PURE__ */ new Set(), this.editor.editing.downcastDispatcher.on("selection", (e4, n3, o2) => {
                const i2 = o2.writer, r2 = n3.selection;
                if (r2.isCollapsed)
                  return;
                const s2 = r2.getSelectedElement();
                if (!s2)
                  return;
                const a2 = t3.editing.mapper.toViewElement(s2);
                jg(a2) && o2.consumable.consume(r2, "selection") && i2.setSelection(i2.createRangeOn(a2), { fake: true, label: qg(a2) });
              }), this.editor.editing.downcastDispatcher.on("selection", (t4, e4, n3) => {
                this._clearPreviouslySelectedWidgets(n3.writer);
                const o2 = n3.writer, i2 = o2.document.selection;
                let r2 = null;
                for (const t5 of i2.getRanges())
                  for (const e5 of t5) {
                    const t6 = e5.item;
                    jg(t6) && !hm(t6, r2) && (o2.addClass(Rg, t6), this._previouslySelected.add(t6), r2 = t6);
                  }
              }, { priority: "low" }), e3.addObserver(lg), this.listenTo(n2, "mousedown", (...t4) => this._onMousedown(...t4)), this.listenTo(n2, "arrowKey", (...t4) => {
                this._handleSelectionChangeOnArrowKeyPress(...t4);
              }, { context: [jg, "$text"] }), this.listenTo(n2, "arrowKey", (...t4) => {
                this._preventDefaultOnArrowKeyPress(...t4);
              }, { context: "$root" }), this.listenTo(n2, "arrowKey", rm(this.editor.editing), { context: "$text" }), this.listenTo(n2, "delete", (t4, e4) => {
                this._handleDelete("forward" == e4.direction) && (e4.preventDefault(), t4.stop());
              }, { context: "$root" });
            }
            _onMousedown(t3, e3) {
              const n2 = this.editor, o2 = n2.editing.view, i2 = o2.document;
              let r2 = e3.target;
              if (function(t4) {
                for (; t4; ) {
                  if (t4.is("editableElement") && !t4.is("rootElement"))
                    return true;
                  if (jg(t4))
                    return false;
                  t4 = t4.parent;
                }
                return false;
              }(r2)) {
                if ((sr.isSafari || sr.isGecko) && e3.domEvent.detail >= 3) {
                  const t4 = n2.editing.mapper, o3 = r2.is("attributeElement") ? r2.findAncestor((t5) => !t5.is("attributeElement")) : r2, i3 = t4.toModelElement(o3);
                  e3.preventDefault(), this.editor.model.change((t5) => {
                    t5.setSelection(i3, "in");
                  });
                }
                return;
              }
              if (!jg(r2) && (r2 = r2.findAncestor(jg), !r2))
                return;
              sr.isAndroid && e3.preventDefault(), i2.isFocused || o2.focus();
              const s2 = n2.editing.mapper.toModelElement(r2);
              this._setSelectionOverElement(s2);
            }
            _handleSelectionChangeOnArrowKeyPress(t3, e3) {
              const n2 = e3.keyCode, o2 = this.editor.model, i2 = o2.schema, r2 = o2.document.selection, s2 = r2.getSelectedElement(), a2 = pr(n2, this.editor.locale.contentLanguageDirection), c2 = "down" == a2 || "right" == a2, l2 = "up" == a2 || "down" == a2;
              if (s2 && i2.isObject(s2)) {
                const n3 = c2 ? r2.getLastPosition() : r2.getFirstPosition(), s3 = i2.getNearestSelectionRange(n3, c2 ? "forward" : "backward");
                return void (s3 && (o2.change((t4) => {
                  t4.setSelection(s3);
                }), e3.preventDefault(), t3.stop()));
              }
              if (!r2.isCollapsed && !e3.shiftKey) {
                const n3 = r2.getFirstPosition(), s3 = r2.getLastPosition(), a3 = n3.nodeAfter, l3 = s3.nodeBefore;
                return void ((a3 && i2.isObject(a3) || l3 && i2.isObject(l3)) && (o2.change((t4) => {
                  t4.setSelection(c2 ? s3 : n3);
                }), e3.preventDefault(), t3.stop()));
              }
              if (!r2.isCollapsed)
                return;
              const d2 = this._getObjectElementNextToSelection(c2);
              if (d2 && i2.isObject(d2)) {
                if (i2.isInline(d2) && l2)
                  return;
                this._setSelectionOverElement(d2), e3.preventDefault(), t3.stop();
              }
            }
            _preventDefaultOnArrowKeyPress(t3, e3) {
              const n2 = this.editor.model, o2 = n2.schema, i2 = n2.document.selection.getSelectedElement();
              i2 && o2.isObject(i2) && (e3.preventDefault(), t3.stop());
            }
            _handleDelete(t3) {
              if (this.editor.isReadOnly)
                return;
              const e3 = this.editor.model.document.selection;
              if (!e3.isCollapsed)
                return;
              const n2 = this._getObjectElementNextToSelection(t3);
              return n2 ? (this.editor.model.change((t4) => {
                let o2 = e3.anchor.parent;
                for (; o2.isEmpty; ) {
                  const e4 = o2;
                  o2 = e4.parent, t4.remove(e4);
                }
                this._setSelectionOverElement(n2);
              }), true) : void 0;
            }
            _setSelectionOverElement(t3) {
              this.editor.model.change((e3) => {
                e3.setSelection(e3.createRangeOn(t3));
              });
            }
            _getObjectElementNextToSelection(t3) {
              const e3 = this.editor.model, n2 = e3.schema, o2 = e3.document.selection, i2 = e3.createSelection(o2);
              if (e3.modifySelection(i2, { direction: t3 ? "forward" : "backward" }), i2.isEqual(o2))
                return null;
              const r2 = t3 ? i2.focus.nodeBefore : i2.focus.nodeAfter;
              return r2 && n2.isObject(r2) ? r2 : null;
            }
            _clearPreviouslySelectedWidgets(t3) {
              for (const e3 of this._previouslySelected)
                t3.removeClass(Rg, e3);
              this._previouslySelected.clear();
            }
          }
          function hm(t3, e3) {
            return !!e3 && Array.from(t3.getAncestors()).includes(e3);
          }
          const um = function(t3, e3, n2) {
            var o2 = true, i2 = true;
            if ("function" != typeof t3)
              throw new TypeError("Expected a function");
            return y(n2) && (o2 = "leading" in n2 ? !!n2.leading : o2, i2 = "trailing" in n2 ? !!n2.trailing : i2), sa(t3, e3, { leading: o2, maxWait: e3, trailing: i2 });
          };
          var gm = n(903), mm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(gm.Z, mm);
          gm.Z.locals;
          class pm extends ue {
            static get pluginName() {
              return "DragDrop";
            }
            static get requires() {
              return [Cg, dm];
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view;
              this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, this._updateDropMarkerThrottled = um((t4) => this._updateDropMarker(t4), 40), this._removeDropMarkerDelayed = bm(() => this._removeDropMarker(), 40), this._clearDraggableAttributesDelayed = bm(() => this._clearDraggableAttributes(), 40), e3.addObserver(kg), e3.addObserver(lg), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDropMarker(), this._setupDraggableAttributeHandling(), this.listenTo(t3, "change:isReadOnly", (t4, e4, n2) => {
                n2 ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
              }), this.on("change:isEnabled", (t4, e4, n2) => {
                n2 || this._finalizeDragging(false);
              }), sr.isAndroid && this.forceDisabled("noAndroidSupport");
            }
            destroy() {
              return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._updateDropMarkerThrottled.cancel(), this._removeDropMarkerDelayed.cancel(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
            }
            _setupDragging() {
              const t3 = this.editor, e3 = t3.model, n2 = e3.document, o2 = t3.editing.view, i2 = o2.document;
              this.listenTo(i2, "dragstart", (o3, s2) => {
                const a2 = n2.selection;
                if (s2.target && s2.target.is("editableElement"))
                  return void s2.preventDefault();
                const c2 = s2.target ? wm(s2.target) : null;
                if (c2) {
                  const n3 = t3.editing.mapper.toModelElement(c2);
                  this._draggedRange = rc.fromRange(e3.createRangeOn(n3)), t3.plugins.has("WidgetToolbarRepository") && t3.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
                } else if (!i2.selection.isCollapsed) {
                  const t4 = i2.selection.getSelectedElement();
                  t4 && jg(t4) || (this._draggedRange = rc.fromRange(a2.getFirstRange()));
                }
                if (!this._draggedRange)
                  return void s2.preventDefault();
                this._draggingUid = r(), s2.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", s2.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
                const l2 = e3.createSelection(this._draggedRange.toRange()), d2 = t3.data.toView(e3.getSelectedContent(l2));
                i2.fire("clipboardOutput", { dataTransfer: s2.dataTransfer, content: d2, method: o3.name }), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
              }, { priority: "low" }), this.listenTo(i2, "dragend", (t4, e4) => {
                this._finalizeDragging(!e4.dataTransfer.isCanceled && "move" == e4.dataTransfer.dropEffect);
              }, { priority: "low" }), this.listenTo(i2, "dragenter", () => {
                this.isEnabled && o2.focus();
              }), this.listenTo(i2, "dragleave", () => {
                this._removeDropMarkerDelayed();
              }), this.listenTo(i2, "dragging", (e4, n3) => {
                if (!this.isEnabled)
                  return void (n3.dataTransfer.dropEffect = "none");
                this._removeDropMarkerDelayed.cancel();
                const o3 = fm(t3, n3.targetRanges, n3.target);
                this._draggedRange || (n3.dataTransfer.dropEffect = "copy"), sr.isGecko || ("copy" == n3.dataTransfer.effectAllowed ? n3.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(n3.dataTransfer.effectAllowed) && (n3.dataTransfer.dropEffect = "move")), o3 && this._updateDropMarkerThrottled(o3);
              }, { priority: "low" });
            }
            _setupClipboardInputIntegration() {
              const t3 = this.editor, e3 = t3.editing.view.document;
              this.listenTo(e3, "clipboardInput", (e4, n2) => {
                if ("drop" != n2.method)
                  return;
                const o2 = fm(t3, n2.targetRanges, n2.target);
                if (this._removeDropMarker(), !o2)
                  return this._finalizeDragging(false), void e4.stop();
                this._draggedRange && this._draggingUid != n2.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
                if ("move" == km(n2.dataTransfer) && this._draggedRange && this._draggedRange.containsRange(o2, true))
                  return this._finalizeDragging(false), void e4.stop();
                n2.targetRanges = [t3.editing.mapper.toViewRange(o2)];
              }, { priority: "high" });
            }
            _setupContentInsertionIntegration() {
              const t3 = this.editor.plugins.get(Cg);
              t3.on("contentInsertion", (t4, e3) => {
                if (!this.isEnabled || "drop" !== e3.method)
                  return;
                const n2 = e3.targetRanges.map((t5) => this.editor.editing.mapper.toModelRange(t5));
                this.editor.model.change((t5) => t5.setSelection(n2));
              }, { priority: "high" }), t3.on("contentInsertion", (t4, e3) => {
                if (!this.isEnabled || "drop" !== e3.method)
                  return;
                const n2 = "move" == km(e3.dataTransfer), o2 = !e3.resultRange || !e3.resultRange.isCollapsed;
                this._finalizeDragging(o2 && n2);
              }, { priority: "lowest" });
            }
            _setupDraggableAttributeHandling() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = e3.document;
              this.listenTo(n2, "mousedown", (o2, i2) => {
                if (sr.isAndroid || !i2)
                  return;
                this._clearDraggableAttributesDelayed.cancel();
                let r2 = wm(i2.target);
                if (sr.isBlink && !t3.isReadOnly && !r2 && !n2.selection.isCollapsed) {
                  const t4 = n2.selection.getSelectedElement();
                  t4 && jg(t4) || (r2 = n2.selection.editableElement);
                }
                r2 && (e3.change((t4) => {
                  t4.setAttribute("draggable", "true", r2);
                }), this._draggableElement = t3.editing.mapper.toModelElement(r2));
              }), this.listenTo(n2, "mouseup", () => {
                sr.isAndroid || this._clearDraggableAttributesDelayed();
              });
            }
            _clearDraggableAttributes() {
              const t3 = this.editor.editing;
              t3.view.change((e3) => {
                this._draggableElement && "$graveyard" != this._draggableElement.root.rootName && e3.removeAttribute("draggable", t3.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
              });
            }
            _setupDropMarker() {
              const t3 = this.editor;
              t3.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), t3.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (e3, { writer: n2 }) => {
                if (t3.model.schema.checkChild(e3.markerRange.start, "$text"))
                  return n2.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(t4) {
                    const e4 = this.toDomElement(t4);
                    return e4.innerHTML = "&NoBreak;<span></span>&NoBreak;", e4;
                  });
              } });
            }
            _updateDropMarker(t3) {
              const e3 = this.editor, n2 = e3.model.markers;
              e3.model.change((e4) => {
                n2.has("drop-target") ? n2.get("drop-target").getRange().isEqual(t3) || e4.updateMarker("drop-target", { range: t3 }) : e4.addMarker("drop-target", { range: t3, usingOperation: false, affectsData: false });
              });
            }
            _removeDropMarker() {
              const t3 = this.editor.model;
              this._removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), t3.markers.has("drop-target") && t3.change((t4) => {
                t4.removeMarker("drop-target");
              });
            }
            _finalizeDragging(t3) {
              const e3 = this.editor, n2 = e3.model;
              this._removeDropMarker(), this._clearDraggableAttributes(), e3.plugins.has("WidgetToolbarRepository") && e3.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._draggedRange && (t3 && this.isEnabled && n2.deleteContent(n2.createSelection(this._draggedRange), { doNotAutoparagraph: true }), this._draggedRange.detach(), this._draggedRange = null);
            }
          }
          function fm(t3, e3, n2) {
            const o2 = t3.model, i2 = t3.editing.mapper;
            let r2 = null;
            const s2 = e3 ? e3[0].start : null;
            if (n2.is("uiElement") && (n2 = n2.parent), r2 = function(t4, e4) {
              const n3 = t4.model, o3 = t4.editing.mapper;
              if (jg(e4))
                return n3.createRangeOn(o3.toModelElement(e4));
              if (!e4.is("editableElement")) {
                const t5 = e4.findAncestor((t6) => jg(t6) || t6.is("editableElement"));
                if (jg(t5))
                  return n3.createRangeOn(o3.toModelElement(t5));
              }
              return null;
            }(t3, n2), r2)
              return r2;
            const a2 = function(t4, e4) {
              const n3 = t4.editing.mapper, o3 = t4.editing.view, i3 = n3.toModelElement(e4);
              if (i3)
                return i3;
              const r3 = o3.createPositionBefore(e4), s3 = n3.findMappedViewAncestor(r3);
              return n3.toModelElement(s3);
            }(t3, n2), c2 = s2 ? i2.toModelPosition(s2) : null;
            return c2 ? (r2 = function(t4, e4, n3) {
              const o3 = t4.model;
              if (!o3.schema.checkChild(n3, "$block"))
                return null;
              const i3 = o3.createPositionAt(n3, 0), r3 = e4.path.slice(0, i3.path.length), s3 = o3.createPositionFromPath(e4.root, r3).nodeAfter;
              if (s3 && o3.schema.isObject(s3))
                return o3.createRangeOn(s3);
              return null;
            }(t3, c2, a2), r2 || (r2 = o2.schema.getNearestSelectionRange(c2, sr.isGecko ? "forward" : "backward"), r2 || function(t4, e4) {
              const n3 = t4.model;
              for (; e4; ) {
                if (n3.schema.isObject(e4))
                  return n3.createRangeOn(e4);
                e4 = e4.parent;
              }
            }(t3, c2.parent))) : function(t4, e4) {
              const n3 = t4.model, o3 = n3.schema, i3 = n3.createPositionAt(e4, 0);
              return o3.getNearestSelectionRange(i3, "forward");
            }(t3, a2);
          }
          function km(t3) {
            return sr.isGecko ? t3.dropEffect : ["all", "copyMove"].includes(t3.effectAllowed) ? "move" : "copy";
          }
          function bm(t3, e3) {
            let n2;
            function o2(...i2) {
              o2.cancel(), n2 = setTimeout(() => t3(...i2), e3);
            }
            return o2.cancel = () => {
              clearTimeout(n2);
            }, o2;
          }
          function wm(t3) {
            if (t3.is("editableElement"))
              return null;
            if (t3.hasClass("ck-widget__selection-handle"))
              return t3.findAncestor(jg);
            if (jg(t3))
              return t3;
            const e3 = t3.findAncestor((t4) => jg(t4) || t4.is("editableElement"));
            return jg(e3) ? e3 : null;
          }
          class Cm extends ue {
            static get pluginName() {
              return "PastePlainText";
            }
            static get requires() {
              return [Cg];
            }
            init() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.editing.view, o2 = n2.document, i2 = e3.document.selection;
              let r2 = false;
              n2.addObserver(kg), this.listenTo(o2, "keydown", (t4, e4) => {
                r2 = e4.shiftKey;
              }), t3.plugins.get(Cg).on("contentInsertion", (t4, n3) => {
                (r2 || function(t5, e4) {
                  if (t5.childCount > 1)
                    return false;
                  const n4 = t5.getChild(0);
                  if (e4.isObject(n4))
                    return false;
                  return 0 == [...n4.getAttributeKeys()].length;
                }(n3.content, e3.schema)) && e3.change((t5) => {
                  const o3 = Array.from(i2.getAttributes()).filter(([t6]) => e3.schema.getAttributeProperties(t6).isFormatting);
                  i2.isCollapsed || e3.deleteContent(i2, { doNotAutoparagraph: true }), o3.push(...i2.getAttributes());
                  const r3 = t5.createRangeIn(n3.content);
                  for (const e4 of r3.getItems())
                    e4.is("$textProxy") && t5.setAttributes(o3, e4);
                });
              });
            }
          }
          class Am extends ue {
            static get pluginName() {
              return "Clipboard";
            }
            static get requires() {
              return [Cg, pm, Cm];
            }
          }
          class _m extends me {
            execute() {
              const t3 = this.editor.model, e3 = t3.document;
              t3.change((n2) => {
                !function(t4, e4, n3) {
                  const o2 = n3.isCollapsed, i2 = n3.getFirstRange(), r2 = i2.start.parent, s2 = i2.end.parent, a2 = r2 == s2;
                  if (o2) {
                    const o3 = Ag(t4.schema, n3.getAttributes());
                    vm(t4, e4, i2.end), e4.removeSelectionAttribute(n3.getAttributeKeys()), e4.setSelectionAttribute(o3);
                  } else {
                    const o3 = !(i2.start.isAtStart && i2.end.isAtEnd);
                    t4.deleteContent(n3, { leaveUnmerged: o3 }), a2 ? vm(t4, e4, n3.focus) : o3 && e4.setSelection(s2, 0);
                  }
                }(t3, n2, e3.selection), this.fire("afterExecute", { writer: n2 });
              });
            }
            refresh() {
              const t3 = this.editor.model, e3 = t3.document;
              this.isEnabled = function(t4, e4) {
                if (e4.rangeCount > 1)
                  return false;
                const n2 = e4.anchor;
                if (!n2 || !t4.checkChild(n2, "softBreak"))
                  return false;
                const o2 = e4.getFirstRange(), i2 = o2.start.parent, r2 = o2.end.parent;
                if ((ym(i2, t4) || ym(r2, t4)) && i2 !== r2)
                  return false;
                return true;
              }(t3.schema, e3.selection);
            }
          }
          function vm(t3, e3, n2) {
            const o2 = e3.createElement("softBreak");
            t3.insertContent(o2, n2), e3.setSelection(o2, "after");
          }
          function ym(t3, e3) {
            return !t3.is("rootElement") && (e3.isLimit(t3) || ym(t3.parent, e3));
          }
          class xm extends ue {
            static get pluginName() {
              return "ShiftEnter";
            }
            init() {
              const t3 = this.editor, e3 = t3.model.schema, n2 = t3.conversion, o2 = t3.editing.view, i2 = o2.document;
              e3.register("softBreak", { allowWhere: "$text", isInline: true }), n2.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n2.for("downcast").elementToElement({ model: "softBreak", view: (t4, { writer: e4 }) => e4.createEmptyElement("br") }), o2.addObserver(yg), t3.commands.add("shiftEnter", new _m(t3)), this.listenTo(i2, "enter", (e4, n3) => {
                n3.preventDefault(), n3.isSoft && (t3.execute("shiftEnter"), o2.scrollToTheSelection());
              }, { priority: "low" });
            }
          }
          class Em extends me {
            constructor(t3) {
              super(t3), this.affectsData = false;
            }
            execute() {
              const t3 = this.editor.model, e3 = t3.document.selection;
              let n2 = t3.schema.getLimitElement(e3);
              if (e3.containsEntireContent(n2) || !Dm(t3.schema, n2))
                do {
                  if (n2 = n2.parent, !n2)
                    return;
                } while (!Dm(t3.schema, n2));
              t3.change((t4) => {
                t4.setSelection(n2, "in");
              });
            }
          }
          function Dm(t3, e3) {
            return t3.isLimit(e3) && (t3.checkChild(e3, "$text") || t3.checkChild(e3, "paragraph"));
          }
          const Im = gr("Ctrl+A");
          class Mm extends ue {
            static get pluginName() {
              return "SelectAllEditing";
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view.document;
              t3.commands.add("selectAll", new Em(t3)), this.listenTo(e3, "keydown", (e4, n2) => {
                ur(n2) === Im && (t3.execute("selectAll"), n2.preventDefault());
              });
            }
          }
          class Sm extends ue {
            static get pluginName() {
              return "SelectAllUI";
            }
            init() {
              const t3 = this.editor;
              t3.ui.componentFactory.add("selectAll", (e3) => {
                const n2 = t3.commands.get("selectAll"), o2 = new gh(e3), i2 = e3.t;
                return o2.set({ label: i2("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: true }), o2.bind("isOn", "isEnabled").to(n2, "value", "isEnabled"), this.listenTo(o2, "execute", () => {
                  t3.execute("selectAll"), t3.editing.view.focus();
                }), o2;
              });
            }
          }
          class Tm extends ue {
            static get requires() {
              return [Mm, Sm];
            }
            static get pluginName() {
              return "SelectAll";
            }
          }
          class Nm extends me {
            constructor(t3, e3) {
              super(t3), this._buffer = new Eg(t3.model, e3);
            }
            get buffer() {
              return this._buffer;
            }
            destroy() {
              super.destroy(), this._buffer.destroy();
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.document, o2 = t3.text || "", i2 = o2.length, r2 = t3.range ? e3.createSelection(t3.range) : n2.selection, s2 = t3.resultRange;
              e3.enqueueChange(this._buffer.batch, (t4) => {
                this._buffer.lock(), e3.deleteContent(r2), o2 && e3.insertContent(t4.createText(o2, n2.selection.getAttributes()), r2), s2 ? t4.setSelection(s2) : r2.is("documentSelection") || t4.setSelection(r2), this._buffer.unlock(), this._buffer.input(i2);
              });
            }
          }
          class Bm {
            constructor(t3) {
              this.editor = t3, this.editing = this.editor.editing;
            }
            handle(t3, e3) {
              if (function(t4) {
                if (0 == t4.length)
                  return false;
                for (const e4 of t4)
                  if ("children" === e4.type && !Ig(e4))
                    return true;
                return false;
              }(t3))
                this._handleContainerChildrenMutations(t3, e3);
              else
                for (const n2 of t3)
                  this._handleTextMutation(n2, e3), this._handleTextNodeInsertion(n2);
            }
            _handleContainerChildrenMutations(t3, e3) {
              const n2 = function(t4) {
                const e4 = t4.map((t5) => t5.node).reduce((t5, e5) => t5.getCommonAncestor(e5, { includeSelf: true }));
                if (!e4)
                  return;
                return e4.getAncestors({ includeSelf: true, parentFirst: true }).find((t5) => t5.is("containerElement") || t5.is("rootElement"));
              }(t3);
              if (!n2)
                return;
              const o2 = this.editor.editing.view.domConverter.mapViewToDom(n2), i2 = new gs(this.editor.editing.view.document), r2 = this.editor.data.toModel(i2.domToView(o2)).getChild(0), s2 = this.editor.editing.mapper.toModelElement(n2);
              if (!s2)
                return;
              const a2 = Array.from(r2.getChildren()), c2 = Array.from(s2.getChildren()), l2 = a2[a2.length - 1], d2 = c2[c2.length - 1], h2 = l2 && l2.is("element", "softBreak"), u2 = d2 && !d2.is("element", "softBreak");
              h2 && u2 && a2.pop();
              const g2 = this.editor.model.schema;
              if (!zm(a2, g2) || !zm(c2, g2))
                return;
              const m2 = a2.map((t4) => t4.is("$text") ? t4.data : "@").join("").replace(/\u00A0/g, " "), p2 = c2.map((t4) => t4.is("$text") ? t4.data : "@").join("").replace(/\u00A0/g, " ");
              if (p2 === m2)
                return;
              const f2 = Wr(p2, m2), { firstChangeAt: k2, insertions: b2, deletions: w2 } = Pm(f2);
              let C2 = null;
              e3 && (C2 = this.editing.mapper.toModelRange(e3.getFirstRange()));
              const A2 = m2.substr(k2, b2), _2 = this.editor.model.createRange(this.editor.model.createPositionAt(s2, k2), this.editor.model.createPositionAt(s2, k2 + w2));
              this.editor.execute("input", { text: A2, range: _2, resultRange: C2 });
            }
            _handleTextMutation(t3, e3) {
              if ("text" != t3.type)
                return;
              const n2 = t3.newText.replace(/\u00A0/g, " "), o2 = t3.oldText.replace(/\u00A0/g, " ");
              if (o2 === n2)
                return;
              const i2 = Wr(o2, n2), { firstChangeAt: r2, insertions: s2, deletions: a2 } = Pm(i2);
              let c2 = null;
              e3 && (c2 = this.editing.mapper.toModelRange(e3.getFirstRange()));
              const l2 = this.editing.view.createPositionAt(t3.node, r2), d2 = this.editing.mapper.toModelPosition(l2), h2 = this.editor.model.createRange(d2, d2.getShiftedBy(a2)), u2 = n2.substr(r2, s2);
              this.editor.execute("input", { text: u2, range: h2, resultRange: c2 });
            }
            _handleTextNodeInsertion(t3) {
              if ("children" != t3.type)
                return;
              const e3 = Ig(t3), n2 = this.editing.view.createPositionAt(t3.node, e3.index), o2 = this.editing.mapper.toModelPosition(n2), i2 = e3.values[0].data;
              this.editor.execute("input", { text: i2.replace(/\u00A0/g, " "), range: this.editor.model.createRange(o2) });
            }
          }
          function zm(t3, e3) {
            return t3.every((t4) => e3.isInline(t4));
          }
          function Pm(t3) {
            let e3 = null, n2 = null;
            for (let o3 = 0; o3 < t3.length; o3++) {
              "equal" != t3[o3] && (e3 = null === e3 ? o3 : e3, n2 = o3);
            }
            let o2 = 0, i2 = 0;
            for (let r2 = e3; r2 <= n2; r2++)
              "insert" != t3[r2] && o2++, "delete" != t3[r2] && i2++;
            return { insertions: i2, deletions: o2, firstChangeAt: e3 };
          }
          class Lm extends ue {
            static get pluginName() {
              return "Input";
            }
            init() {
              const t3 = this.editor, e3 = new Nm(t3, t3.config.get("typing.undoStep") || 20);
              t3.commands.add("input", e3), function(t4) {
                let e4 = null;
                const n2 = t4.model, o2 = t4.editing.view, i2 = t4.commands.get("input");
                function r2(t5) {
                  if (sr.isWindows && Sg(t5, o2.document))
                    return;
                  const r3 = n2.document, a2 = o2.document.isComposing, c2 = e4 && e4.isEqual(r3.selection);
                  e4 = null, i2.isEnabled && (Jg(t5) || r3.selection.isCollapsed || a2 && 229 === t5.keyCode || !a2 && 229 === t5.keyCode && c2 || s2());
                }
                function s2() {
                  const t5 = i2.buffer;
                  t5.lock();
                  const e5 = t5.batch;
                  n2.enqueueChange(e5, () => {
                    n2.deleteContent(n2.document.selection);
                  }), t5.unlock();
                }
                sr.isAndroid ? o2.document.on("beforeinput", (t5, e5) => r2(e5), { priority: "lowest" }) : o2.document.on("keydown", (t5, e5) => r2(e5), { priority: "lowest" }), o2.document.on("compositionstart", function() {
                  const t5 = n2.document, e5 = 1 !== t5.selection.rangeCount || t5.selection.getFirstRange().isFlat;
                  t5.selection.isCollapsed || e5 || s2();
                }, { priority: "lowest" }), o2.document.on("compositionend", () => {
                  e4 = n2.createSelection(n2.document.selection);
                }, { priority: "lowest" });
              }(t3), function(t4) {
                t4.editing.view.document.on("mutations", (e4, n2, o2) => {
                  new Bm(t4).handle(n2, o2);
                });
              }(t3);
            }
          }
          class Om extends ue {
            static get requires() {
              return [Lm, Ng];
            }
            static get pluginName() {
              return "Typing";
            }
          }
          function Rm(t3, e3) {
            let n2 = t3.start;
            return { text: Array.from(t3.getItems()).reduce((t4, o2) => o2.is("$text") || o2.is("$textProxy") ? t4 + o2.data : (n2 = e3.createPositionAfter(o2), ""), ""), range: e3.createRange(n2, t3.end) };
          }
          class jm {
            constructor(t3, e3) {
              this.model = t3, this.testCallback = e3, this.hasMatch = false, this.set("isEnabled", true), this.on("change:isEnabled", () => {
                this.isEnabled ? this._startListening() : (this.stopListening(t3.document.selection), this.stopListening(t3.document));
              }), this._startListening();
            }
            _startListening() {
              const t3 = this.model.document;
              this.listenTo(t3.selection, "change:range", (e3, { directChange: n2 }) => {
                n2 && (t3.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this.hasMatch = false));
              }), this.listenTo(t3, "change:data", (t4, e3) => {
                !e3.isUndo && e3.isLocal && this._evaluateTextBeforeSelection("data", { batch: e3 });
              });
            }
            _evaluateTextBeforeSelection(t3, e3 = {}) {
              const n2 = this.model, o2 = n2.document.selection, i2 = n2.createRange(n2.createPositionAt(o2.focus.parent, 0), o2.focus), { text: r2, range: s2 } = Rm(i2, n2), a2 = this.testCallback(r2);
              if (!a2 && this.hasMatch && this.fire("unmatched"), this.hasMatch = !!a2, a2) {
                const n3 = Object.assign(e3, { text: r2, range: s2 });
                "object" == typeof a2 && Object.assign(n3, a2), this.fire(`matched:${t3}`, n3);
              }
            }
          }
          he(jm, re);
          class Fm extends ue {
            static get pluginName() {
              return "TwoStepCaretMovement";
            }
            constructor(t3) {
              super(t3), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
            }
            init() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.editing.view, o2 = t3.locale, i2 = e3.document.selection;
              this.listenTo(n2.document, "arrowKey", (t4, e4) => {
                if (!i2.isCollapsed)
                  return;
                if (e4.shiftKey || e4.altKey || e4.ctrlKey)
                  return;
                const n3 = e4.keyCode == dr.arrowright, r2 = e4.keyCode == dr.arrowleft;
                if (!n3 && !r2)
                  return;
                const s2 = o2.contentLanguageDirection;
                let a2 = false;
                a2 = "ltr" === s2 && n3 || "rtl" === s2 && r2 ? this._handleForwardMovement(e4) : this._handleBackwardMovement(e4), true === a2 && t4.stop();
              }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = false, this.listenTo(i2, "change:range", (t4, e4) => {
                this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = false : this._isGravityOverridden && (!e4.directChange && qm(i2.getFirstPosition(), this.attributes) || this._restoreGravity());
              });
            }
            registerAttribute(t3) {
              this.attributes.add(t3);
            }
            _handleForwardMovement(t3) {
              const e3 = this.attributes, n2 = this.editor.model.document.selection, o2 = n2.getFirstPosition();
              return !this._isGravityOverridden && ((!o2.isAtStart || !Vm(n2, e3)) && (qm(o2, e3) ? (Hm(t3), this._overrideGravity(), true) : void 0));
            }
            _handleBackwardMovement(t3) {
              const e3 = this.attributes, n2 = this.editor.model, o2 = n2.document.selection, i2 = o2.getFirstPosition();
              return this._isGravityOverridden ? (Hm(t3), this._restoreGravity(), Um(n2, e3, i2), true) : i2.isAtStart ? !!Vm(o2, e3) && (Hm(t3), Um(n2, e3, i2), true) : function(t4, e4) {
                return qm(t4.getShiftedBy(-1), e4);
              }(i2, e3) ? i2.isAtEnd && !Vm(o2, e3) && qm(i2, e3) ? (Hm(t3), Um(n2, e3, i2), true) : (this._isNextGravityRestorationSkipped = true, this._overrideGravity(), false) : void 0;
            }
            get _isGravityOverridden() {
              return !!this._overrideUid;
            }
            _overrideGravity() {
              this._overrideUid = this.editor.model.change((t3) => t3.overrideSelectionGravity());
            }
            _restoreGravity() {
              this.editor.model.change((t3) => {
                t3.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
              });
            }
          }
          function Vm(t3, e3) {
            for (const n2 of e3)
              if (t3.hasAttribute(n2))
                return true;
            return false;
          }
          function Um(t3, e3, n2) {
            const o2 = n2.nodeBefore;
            t3.change((t4) => {
              o2 ? t4.setSelectionAttribute(o2.getAttributes()) : t4.removeSelectionAttribute(e3);
            });
          }
          function Hm(t3) {
            t3.preventDefault();
          }
          function qm(t3, e3) {
            const { nodeBefore: n2, nodeAfter: o2 } = t3;
            for (const t4 of e3) {
              const e4 = n2 ? n2.getAttribute(t4) : void 0;
              if ((o2 ? o2.getAttribute(t4) : void 0) !== e4)
                return true;
            }
            return false;
          }
          var Wm = /[\\^$.*+?()[\]{}|]/g, Gm = RegExp(Wm.source);
          const Ym = function(t3) {
            return (t3 = si(t3)) && Gm.test(t3) ? t3.replace(Wm, "\\$&") : t3;
          }, Qm = { copyright: { from: "(c)", to: "\xA9" }, registeredTrademark: { from: "(r)", to: "\xAE" }, trademark: { from: "(tm)", to: "\u2122" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "\xBD", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "\u2153", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "\u2154", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "\xBC", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "\xBE", null] }, lessThanOrEqual: { from: "<=", to: "\u2264" }, greaterThanOrEqual: { from: ">=", to: "\u2265" }, notEqual: { from: "!=", to: "\u2260" }, arrowLeft: { from: "<-", to: "\u2190" }, arrowRight: { from: "->", to: "\u2192" }, horizontalEllipsis: { from: "...", to: "\u2026" }, enDash: { from: /(^| )(--)( )$/, to: [null, "\u2013", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "\u2014", null] }, quotesPrimary: { from: tp('"'), to: [null, "\u201C", null, "\u201D"] }, quotesSecondary: { from: tp("'"), to: [null, "\u2018", null, "\u2019"] }, quotesPrimaryEnGb: { from: tp("'"), to: [null, "\u2018", null, "\u2019"] }, quotesSecondaryEnGb: { from: tp('"'), to: [null, "\u201C", null, "\u201D"] }, quotesPrimaryPl: { from: tp('"'), to: [null, "\u201E", null, "\u201D"] }, quotesSecondaryPl: { from: tp("'"), to: [null, "\u201A", null, "\u2019"] } }, Km = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, $m = ["symbols", "mathematical", "typography", "quotes"];
          function Zm(t3) {
            return "string" == typeof t3 ? new RegExp(`(${Ym(t3)})$`) : t3;
          }
          function Jm(t3) {
            return "string" == typeof t3 ? () => [t3] : t3 instanceof Array ? () => t3 : t3;
          }
          function Xm(t3) {
            return (t3.textNode ? t3.textNode : t3.nodeAfter).getAttributes();
          }
          function tp(t3) {
            return new RegExp(`(^|\\s)(${t3})([^${t3}]*)(${t3})$`);
          }
          function ep(t3, e3, n2, o2) {
            return o2.createRange(np(t3, e3, n2, true, o2), np(t3, e3, n2, false, o2));
          }
          function np(t3, e3, n2, o2, i2) {
            let r2 = t3.textNode || (o2 ? t3.nodeBefore : t3.nodeAfter), s2 = null;
            for (; r2 && r2.getAttribute(e3) == n2; )
              s2 = r2, r2 = o2 ? r2.previousSibling : r2.nextSibling;
            return s2 ? i2.createPositionAt(s2, o2 ? "before" : "after") : t3;
          }
          class op extends me {
            constructor(t3) {
              super(t3), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this.listenTo(t3.data, "set", (t4, e3) => {
                e3[1] = { ...e3[1] };
                const n2 = e3[1];
                n2.batchType || (n2.batchType = { isUndoable: false });
              }, { priority: "high" }), this.listenTo(t3.data, "set", (t4, e3) => {
                e3[1].batchType.isUndoable || this.clearStack();
              });
            }
            refresh() {
              this.isEnabled = this._stack.length > 0;
            }
            addBatch(t3) {
              const e3 = this.editor.model.document.selection, n2 = { ranges: e3.hasOwnRange ? Array.from(e3.getRanges()) : [], isBackward: e3.isBackward };
              this._stack.push({ batch: t3, selection: n2 }), this.refresh();
            }
            clearStack() {
              this._stack = [], this.refresh();
            }
            _restoreSelection(t3, e3, n2) {
              const o2 = this.editor.model, i2 = o2.document, r2 = [], s2 = t3.map((t4) => t4.getTransformedByOperations(n2)), a2 = s2.flat();
              for (const t4 of s2) {
                const e4 = t4.filter((t5) => t5.root != i2.graveyard).filter((t5) => !rp(t5, a2));
                e4.length && (ip(e4), r2.push(e4[0]));
              }
              r2.length && o2.change((t4) => {
                t4.setSelection(r2, { backward: e3 });
              });
            }
            _undo(t3, e3) {
              const n2 = this.editor.model, o2 = n2.document;
              this._createdBatches.add(e3);
              const i2 = t3.operations.slice().filter((t4) => t4.isDocumentOperation);
              i2.reverse();
              for (const t4 of i2) {
                const i3 = t4.baseVersion + 1, r2 = Array.from(o2.history.getOperations(i3)), s2 = eg([t4.getReversed()], r2, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }).operationsA;
                for (const i4 of s2)
                  e3.addOperation(i4), n2.applyOperation(i4), o2.history.setOperationAsUndone(t4, i4);
              }
            }
          }
          function ip(t3) {
            t3.sort((t4, e3) => t4.start.isBefore(e3.start) ? -1 : 1);
            for (let e3 = 1; e3 < t3.length; e3++) {
              const n2 = t3[e3 - 1].getJoined(t3[e3], true);
              n2 && (e3--, t3.splice(e3, 2, n2));
            }
          }
          function rp(t3, e3) {
            return e3.some((e4) => e4 !== t3 && e4.containsRange(t3, true));
          }
          class sp extends op {
            execute(t3 = null) {
              const e3 = t3 ? this._stack.findIndex((e4) => e4.batch == t3) : this._stack.length - 1, n2 = this._stack.splice(e3, 1)[0], o2 = this.editor.model.createBatch({ isUndo: true });
              this.editor.model.enqueueChange(o2, () => {
                this._undo(n2.batch, o2);
                const t4 = this.editor.model.document.history.getOperations(n2.batch.baseVersion);
                this._restoreSelection(n2.selection.ranges, n2.selection.isBackward, t4), this.fire("revert", n2.batch, o2);
              }), this.refresh();
            }
          }
          class ap extends op {
            execute() {
              const t3 = this._stack.pop(), e3 = this.editor.model.createBatch({ isUndo: true });
              this.editor.model.enqueueChange(e3, () => {
                const n2 = t3.batch.operations[t3.batch.operations.length - 1].baseVersion + 1, o2 = this.editor.model.document.history.getOperations(n2);
                this._restoreSelection(t3.selection.ranges, t3.selection.isBackward, o2), this._undo(t3.batch, e3);
              }), this.refresh();
            }
          }
          class cp extends ue {
            static get pluginName() {
              return "UndoEditing";
            }
            constructor(t3) {
              super(t3), this._batchRegistry = /* @__PURE__ */ new WeakSet();
            }
            init() {
              const t3 = this.editor;
              this._undoCommand = new sp(t3), this._redoCommand = new ap(t3), t3.commands.add("undo", this._undoCommand), t3.commands.add("redo", this._redoCommand), this.listenTo(t3.model, "applyOperation", (t4, e3) => {
                const n2 = e3[0];
                if (!n2.isDocumentOperation)
                  return;
                const o2 = n2.batch, i2 = this._redoCommand._createdBatches.has(o2), r2 = this._undoCommand._createdBatches.has(o2);
                this._batchRegistry.has(o2) || (this._batchRegistry.add(o2), o2.isUndoable && (i2 ? this._undoCommand.addBatch(o2) : r2 || (this._undoCommand.addBatch(o2), this._redoCommand.clearStack())));
              }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t4, e3, n2) => {
                this._redoCommand.addBatch(n2);
              }), t3.keystrokes.set("CTRL+Z", "undo"), t3.keystrokes.set("CTRL+Y", "redo"), t3.keystrokes.set("CTRL+SHIFT+Z", "redo");
            }
          }
          const lp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', dp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
          class hp extends ue {
            static get pluginName() {
              return "UndoUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.locale, n2 = t3.t, o2 = "ltr" == e3.uiLanguageDirection ? lp : dp, i2 = "ltr" == e3.uiLanguageDirection ? dp : lp;
              this._addButton("undo", n2("Undo"), "CTRL+Z", o2), this._addButton("redo", n2("Redo"), "CTRL+Y", i2);
            }
            _addButton(t3, e3, n2, o2) {
              const i2 = this.editor;
              i2.ui.componentFactory.add(t3, (r2) => {
                const s2 = i2.commands.get(t3), a2 = new gh(r2);
                return a2.set({ label: e3, icon: o2, keystroke: n2, tooltip: true }), a2.bind("isEnabled").to(s2, "isEnabled"), this.listenTo(a2, "execute", () => {
                  i2.execute(t3), i2.editing.view.focus();
                }), a2;
              });
            }
          }
          class up extends ue {
            static get requires() {
              return [cp, hp];
            }
            static get pluginName() {
              return "Undo";
            }
          }
          class gp {
            constructor() {
              const t3 = new window.FileReader();
              this._reader = t3, this._data = void 0, this.set("loaded", 0), t3.onprogress = (t4) => {
                this.loaded = t4.loaded;
              };
            }
            get error() {
              return this._reader.error;
            }
            get data() {
              return this._data;
            }
            read(t3) {
              const e3 = this._reader;
              return this.total = t3.size, new Promise((n2, o2) => {
                e3.onload = () => {
                  const t4 = e3.result;
                  this._data = t4, n2(t4);
                }, e3.onerror = () => {
                  o2("error");
                }, e3.onabort = () => {
                  o2("aborted");
                }, this._reader.readAsDataURL(t3);
              });
            }
            abort() {
              this._reader.abort();
            }
          }
          he(gp, re);
          class mp extends ue {
            static get pluginName() {
              return "FileRepository";
            }
            static get requires() {
              return [Dd];
            }
            init() {
              this.loaders = new Io(), this.loaders.on("add", () => this._updatePendingAction()), this.loaders.on("remove", () => this._updatePendingAction()), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null, this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t3, e3) => e3 ? t3 / e3 * 100 : 0);
            }
            getLoader(t3) {
              return this._loadersMap.get(t3) || null;
            }
            createLoader(t3) {
              if (!this.createUploadAdapter)
                return c("filerepository-no-upload-adapter"), null;
              const e3 = new pp(Promise.resolve(t3), this.createUploadAdapter);
              return this.loaders.add(e3), this._loadersMap.set(t3, e3), t3 instanceof Promise && e3.file.then((t4) => {
                this._loadersMap.set(t4, e3);
              }).catch(() => {
              }), e3.on("change:uploaded", () => {
                let t4 = 0;
                for (const e4 of this.loaders)
                  t4 += e4.uploaded;
                this.uploaded = t4;
              }), e3.on("change:uploadTotal", () => {
                let t4 = 0;
                for (const e4 of this.loaders)
                  e4.uploadTotal && (t4 += e4.uploadTotal);
                this.uploadTotal = t4;
              }), e3;
            }
            destroyLoader(t3) {
              const e3 = t3 instanceof pp ? t3 : this.getLoader(t3);
              e3._destroy(), this.loaders.remove(e3), this._loadersMap.forEach((t4, n2) => {
                t4 === e3 && this._loadersMap.delete(n2);
              });
            }
            _updatePendingAction() {
              const t3 = this.editor.plugins.get(Dd);
              if (this.loaders.length) {
                if (!this._pendingAction) {
                  const e3 = this.editor.t, n2 = (t4) => `${e3("Upload in progress")} ${parseInt(t4)}%.`;
                  this._pendingAction = t3.add(n2(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n2);
                }
              } else
                t3.remove(this._pendingAction), this._pendingAction = null;
            }
          }
          he(mp, re);
          class pp {
            constructor(t3, e3) {
              this.id = r(), this._filePromiseWrapper = this._createFilePromiseWrapper(t3), this._adapter = e3(this), this._reader = new gp(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t4, e4) => e4 ? t4 / e4 * 100 : 0), this.set("uploadResponse", null);
            }
            get file() {
              return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t3) => this._filePromiseWrapper ? t3 : null) : Promise.resolve(null);
            }
            get data() {
              return this._reader.data;
            }
            read() {
              if ("idle" != this.status)
                throw new a("filerepository-read-wrong-status", this);
              return this.status = "reading", this.file.then((t3) => this._reader.read(t3)).then((t3) => {
                if ("reading" !== this.status)
                  throw this.status;
                return this.status = "idle", t3;
              }).catch((t3) => {
                if ("aborted" === t3)
                  throw this.status = "aborted", "aborted";
                throw this.status = "error", this._reader.error ? this._reader.error : t3;
              });
            }
            upload() {
              if ("idle" != this.status)
                throw new a("filerepository-upload-wrong-status", this);
              return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((t3) => (this.uploadResponse = t3, this.status = "idle", t3)).catch((t3) => {
                if ("aborted" === this.status)
                  throw "aborted";
                throw this.status = "error", t3;
              });
            }
            abort() {
              const t3 = this.status;
              this.status = "aborted", this._filePromiseWrapper.isFulfilled ? "reading" == t3 ? this._reader.abort() : "uploading" == t3 && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
              }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
            }
            _destroy() {
              this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
            }
            _createFilePromiseWrapper(t3) {
              const e3 = {};
              return e3.promise = new Promise((n2, o2) => {
                e3.rejecter = o2, e3.isFulfilled = false, t3.then((t4) => {
                  e3.isFulfilled = true, n2(t4);
                }).catch((t4) => {
                  e3.isFulfilled = true, o2(t4);
                });
              }), e3;
            }
          }
          he(pp, re);
          class fp extends Ld {
            constructor(t3) {
              super(t3), this.buttonView = new gh(t3), this._fileInputView = new kp(t3), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
                this._fileInputView.open();
              });
            }
            focus() {
              this.buttonView.focus();
            }
          }
          class kp extends Ld {
            constructor(t3) {
              super(t3), this.set("acceptedType"), this.set("allowMultipleFiles", false);
              const e3 = this.bindTemplate;
              this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: e3.to("acceptedType"), multiple: e3.to("allowMultipleFiles") }, on: { change: e3.to(() => {
                this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
              }) } });
            }
            open() {
              this.element.click();
            }
          }
          const bp = "ckCsrfToken", wp = "abcdefghijklmnopqrstuvwxyz0123456789";
          function Cp() {
            let t3 = function(t4) {
              t4 = t4.toLowerCase();
              const e4 = document.cookie.split(";");
              for (const n3 of e4) {
                const e5 = n3.split("=");
                if (decodeURIComponent(e5[0].trim().toLowerCase()) === t4)
                  return decodeURIComponent(e5[1]);
              }
              return null;
            }(bp);
            var e3, n2;
            return t3 && 40 == t3.length || (t3 = function(t4) {
              let e4 = "";
              const n3 = new Uint8Array(t4);
              window.crypto.getRandomValues(n3);
              for (let t5 = 0; t5 < n3.length; t5++) {
                const o2 = wp.charAt(n3[t5] % wp.length);
                e4 += Math.random() > 0.5 ? o2.toUpperCase() : o2;
              }
              return e4;
            }(40), e3 = bp, n2 = t3, document.cookie = encodeURIComponent(e3) + "=" + encodeURIComponent(n2) + ";path=/"), t3;
          }
          class Ap {
            constructor(t3, e3, n2) {
              this.loader = t3, this.url = e3, this.t = n2;
            }
            upload() {
              return this.loader.file.then((t3) => new Promise((e3, n2) => {
                this._initRequest(), this._initListeners(e3, n2, t3), this._sendRequest(t3);
              }));
            }
            abort() {
              this.xhr && this.xhr.abort();
            }
            _initRequest() {
              const t3 = this.xhr = new XMLHttpRequest();
              t3.open("POST", this.url, true), t3.responseType = "json";
            }
            _initListeners(t3, e3, n2) {
              const o2 = this.xhr, i2 = this.loader, r2 = (0, this.t)("Cannot upload file:") + ` ${n2.name}.`;
              o2.addEventListener("error", () => e3(r2)), o2.addEventListener("abort", () => e3()), o2.addEventListener("load", () => {
                const n3 = o2.response;
                if (!n3 || !n3.uploaded)
                  return e3(n3 && n3.error && n3.error.message ? n3.error.message : r2);
                t3({ default: n3.url });
              }), o2.upload && o2.upload.addEventListener("progress", (t4) => {
                t4.lengthComputable && (i2.uploadTotal = t4.total, i2.uploaded = t4.loaded);
              });
            }
            _sendRequest(t3) {
              const e3 = new FormData();
              e3.append("upload", t3), e3.append("ckCsrfToken", Cp()), this.xhr.send(e3);
            }
          }
          function _p(t3, e3, n2, o2) {
            let i2, r2 = null;
            "function" == typeof o2 ? i2 = o2 : (r2 = t3.commands.get(o2), i2 = () => {
              t3.execute(o2);
            }), t3.model.document.on("change:data", (s2, a2) => {
              if (r2 && !r2.isEnabled || !e3.isEnabled)
                return;
              const c2 = Aa(t3.model.document.selection.getRanges());
              if (!c2.isCollapsed)
                return;
              if (a2.isUndo || !a2.isLocal)
                return;
              const l2 = Array.from(t3.model.document.differ.getChanges()), d2 = l2[0];
              if (1 != l2.length || "insert" !== d2.type || "$text" != d2.name || 1 != d2.length)
                return;
              const h2 = d2.position.parent;
              if (h2.is("element", "codeBlock"))
                return;
              if (h2.is("element", "listItem") && "function" != typeof o2 && !["numberedList", "bulletedList", "todoList"].includes(o2))
                return;
              if (r2 && true === r2.value)
                return;
              const u2 = h2.getChild(0), g2 = t3.model.createRangeOn(u2);
              if (!g2.containsRange(c2) && !c2.end.isEqual(g2.end))
                return;
              const m2 = n2.exec(u2.data.substr(0, c2.end.offset));
              m2 && t3.model.enqueueChange((e4) => {
                const n3 = e4.createPositionAt(h2, 0), o3 = e4.createPositionAt(h2, m2[0].length), r3 = new rc(n3, o3);
                if (false !== i2({ match: m2 })) {
                  e4.remove(r3);
                  const n4 = t3.model.document.selection.getFirstRange(), o4 = e4.createRangeIn(h2);
                  !h2.isEmpty || o4.isEqual(n4) || o4.containsRange(n4, true) || e4.remove(h2);
                }
                r3.detach(), t3.model.enqueueChange(() => {
                  t3.plugins.get("Delete").requestUndoOnBackspace();
                });
              });
            });
          }
          function vp(t3, e3, n2, o2) {
            let i2, r2;
            n2 instanceof RegExp ? i2 = n2 : r2 = n2, r2 = r2 || ((t4) => {
              let e4;
              const n3 = [], o3 = [];
              for (; null !== (e4 = i2.exec(t4)) && !(e4 && e4.length < 4); ) {
                let { index: t5, 1: i3, 2: r3, 3: s2 } = e4;
                const a2 = i3 + r3 + s2;
                t5 += e4[0].length - a2.length;
                const c2 = [t5, t5 + i3.length], l2 = [t5 + i3.length + r3.length, t5 + i3.length + r3.length + s2.length];
                n3.push(c2), n3.push(l2), o3.push([t5 + i3.length, t5 + i3.length + r3.length]);
              }
              return { remove: n3, format: o3 };
            }), t3.model.document.on("change:data", (n3, i3) => {
              if (i3.isUndo || !i3.isLocal || !e3.isEnabled)
                return;
              const s2 = t3.model, a2 = s2.document.selection;
              if (!a2.isCollapsed)
                return;
              const c2 = Array.from(s2.document.differ.getChanges()), l2 = c2[0];
              if (1 != c2.length || "insert" !== l2.type || "$text" != l2.name || 1 != l2.length)
                return;
              const d2 = a2.focus, h2 = d2.parent, { text: u2, range: g2 } = function(t4, e4) {
                let n4 = t4.start;
                return { text: Array.from(t4.getItems()).reduce((t5, o3) => !o3.is("$text") && !o3.is("$textProxy") || o3.getAttribute("code") ? (n4 = e4.createPositionAfter(o3), "") : t5 + o3.data, ""), range: e4.createRange(n4, t4.end) };
              }(s2.createRange(s2.createPositionAt(h2, 0), d2), s2), m2 = r2(u2), p2 = yp(g2.start, m2.format, s2), f2 = yp(g2.start, m2.remove, s2);
              p2.length && f2.length && s2.enqueueChange((e4) => {
                if (false !== o2(e4, p2)) {
                  for (const t4 of f2.reverse())
                    e4.remove(t4);
                  s2.enqueueChange(() => {
                    t3.plugins.get("Delete").requestUndoOnBackspace();
                  });
                }
              });
            });
          }
          function yp(t3, e3, n2) {
            return e3.filter((t4) => void 0 !== t4[0] && void 0 !== t4[1]).map((e4) => n2.createRange(t3.getShiftedBy(e4[0]), t3.getShiftedBy(e4[1])));
          }
          function xp(t3, e3) {
            return (n2, o2) => {
              if (!t3.commands.get(e3).isEnabled)
                return false;
              const i2 = t3.model.schema.getValidRanges(o2, e3);
              for (const t4 of i2)
                n2.setAttribute(e3, true, t4);
              n2.removeSelectionAttribute(e3);
            };
          }
          class Ep extends me {
            constructor(t3, e3) {
              super(t3), this.attributeKey = e3;
            }
            refresh() {
              const t3 = this.editor.model, e3 = t3.document;
              this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t3.schema.checkAttributeInSelection(e3.selection, this.attributeKey);
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.document.selection, o2 = void 0 === t3.forceValue ? !this.value : t3.forceValue;
              e3.change((t4) => {
                if (n2.isCollapsed)
                  o2 ? t4.setSelectionAttribute(this.attributeKey, true) : t4.removeSelectionAttribute(this.attributeKey);
                else {
                  const i2 = e3.schema.getValidRanges(n2.getRanges(), this.attributeKey);
                  for (const e4 of i2)
                    o2 ? t4.setAttribute(this.attributeKey, o2, e4) : t4.removeAttribute(this.attributeKey, e4);
                }
              });
            }
            _getValueFromFirstAllowedNode() {
              const t3 = this.editor.model, e3 = t3.schema, n2 = t3.document.selection;
              if (n2.isCollapsed)
                return n2.hasAttribute(this.attributeKey);
              for (const t4 of n2.getRanges())
                for (const n3 of t4.getItems())
                  if (e3.checkAttribute(n3, this.attributeKey))
                    return n3.hasAttribute(this.attributeKey);
              return false;
            }
          }
          const Dp = "bold";
          class Ip extends ue {
            static get pluginName() {
              return "BoldEditing";
            }
            init() {
              const t3 = this.editor;
              t3.model.schema.extend("$text", { allowAttributes: Dp }), t3.model.schema.setAttributeProperties(Dp, { isFormatting: true, copyOnEnter: true }), t3.conversion.attributeToElement({ model: Dp, view: "strong", upcastAlso: ["b", (t4) => {
                const e3 = t4.getStyle("font-weight");
                return e3 ? "bold" == e3 || Number(e3) >= 600 ? { name: true, styles: ["font-weight"] } : void 0 : null;
              }] }), t3.commands.add(Dp, new Ep(t3, Dp)), t3.keystrokes.set("CTRL+B", Dp);
            }
          }
          const Mp = "bold";
          class Sp extends ue {
            static get pluginName() {
              return "BoldUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.t;
              t3.ui.componentFactory.add(Mp, (n2) => {
                const o2 = t3.commands.get(Mp), i2 = new gh(n2);
                return i2.set({ label: e3("Bold"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', keystroke: "CTRL+B", tooltip: true, isToggleable: true }), i2.bind("isOn", "isEnabled").to(o2, "value", "isEnabled"), this.listenTo(i2, "execute", () => {
                  t3.execute(Mp), t3.editing.view.focus();
                }), i2;
              });
            }
          }
          const Tp = "italic";
          class Np extends ue {
            static get pluginName() {
              return "ItalicEditing";
            }
            init() {
              const t3 = this.editor;
              t3.model.schema.extend("$text", { allowAttributes: Tp }), t3.model.schema.setAttributeProperties(Tp, { isFormatting: true, copyOnEnter: true }), t3.conversion.attributeToElement({ model: Tp, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), t3.commands.add(Tp, new Ep(t3, Tp)), t3.keystrokes.set("CTRL+I", Tp);
            }
          }
          const Bp = "italic";
          class zp extends ue {
            static get pluginName() {
              return "ItalicUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.t;
              t3.ui.componentFactory.add(Bp, (n2) => {
                const o2 = t3.commands.get(Bp), i2 = new gh(n2);
                return i2.set({ label: e3("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: true, isToggleable: true }), i2.bind("isOn", "isEnabled").to(o2, "value", "isEnabled"), this.listenTo(i2, "execute", () => {
                  t3.execute(Bp), t3.editing.view.focus();
                }), i2;
              });
            }
          }
          class Pp extends me {
            refresh() {
              this.value = this._getValue(), this.isEnabled = this._checkEnabled();
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.schema, o2 = e3.document.selection, i2 = Array.from(o2.getSelectedBlocks()), r2 = void 0 === t3.forceValue ? !this.value : t3.forceValue;
              e3.change((t4) => {
                if (r2) {
                  const e4 = i2.filter((t5) => Lp(t5) || Rp(n2, t5));
                  this._applyQuote(t4, e4);
                } else
                  this._removeQuote(t4, i2.filter(Lp));
              });
            }
            _getValue() {
              const t3 = Aa(this.editor.model.document.selection.getSelectedBlocks());
              return !(!t3 || !Lp(t3));
            }
            _checkEnabled() {
              if (this.value)
                return true;
              const t3 = this.editor.model.document.selection, e3 = this.editor.model.schema, n2 = Aa(t3.getSelectedBlocks());
              return !!n2 && Rp(e3, n2);
            }
            _removeQuote(t3, e3) {
              Op(t3, e3).reverse().forEach((e4) => {
                if (e4.start.isAtStart && e4.end.isAtEnd)
                  return void t3.unwrap(e4.start.parent);
                if (e4.start.isAtStart) {
                  const n3 = t3.createPositionBefore(e4.start.parent);
                  return void t3.move(e4, n3);
                }
                e4.end.isAtEnd || t3.split(e4.end);
                const n2 = t3.createPositionAfter(e4.end.parent);
                t3.move(e4, n2);
              });
            }
            _applyQuote(t3, e3) {
              const n2 = [];
              Op(t3, e3).reverse().forEach((e4) => {
                let o2 = Lp(e4.start);
                o2 || (o2 = t3.createElement("blockQuote"), t3.wrap(e4, o2)), n2.push(o2);
              }), n2.reverse().reduce((e4, n3) => e4.nextSibling == n3 ? (t3.merge(t3.createPositionAfter(e4)), e4) : n3);
            }
          }
          function Lp(t3) {
            return "blockQuote" == t3.parent.name ? t3.parent : null;
          }
          function Op(t3, e3) {
            let n2, o2 = 0;
            const i2 = [];
            for (; o2 < e3.length; ) {
              const r2 = e3[o2], s2 = e3[o2 + 1];
              n2 || (n2 = t3.createPositionBefore(r2)), s2 && r2.nextSibling == s2 || (i2.push(t3.createRange(n2, t3.createPositionAfter(r2))), n2 = null), o2++;
            }
            return i2;
          }
          function Rp(t3, e3) {
            const n2 = t3.checkChild(e3.parent, "blockQuote"), o2 = t3.checkChild(["$root", "blockQuote"], e3);
            return n2 && o2;
          }
          class jp extends ue {
            static get pluginName() {
              return "BlockQuoteEditing";
            }
            static get requires() {
              return [xg, Ng];
            }
            init() {
              const t3 = this.editor, e3 = t3.model.schema;
              t3.commands.add("blockQuote", new Pp(t3)), e3.register("blockQuote", { allowWhere: "$block", allowContentOf: "$root" }), t3.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), t3.model.document.registerPostFixer((n3) => {
                const o3 = t3.model.document.differ.getChanges();
                for (const t4 of o3)
                  if ("insert" == t4.type) {
                    const o4 = t4.position.nodeAfter;
                    if (!o4)
                      continue;
                    if (o4.is("element", "blockQuote") && o4.isEmpty)
                      return n3.remove(o4), true;
                    if (o4.is("element", "blockQuote") && !e3.checkChild(t4.position, o4))
                      return n3.unwrap(o4), true;
                    if (o4.is("element")) {
                      const t5 = n3.createRangeIn(o4);
                      for (const o5 of t5.getItems())
                        if (o5.is("element", "blockQuote") && !e3.checkChild(n3.createPositionBefore(o5), o5))
                          return n3.unwrap(o5), true;
                    }
                  } else if ("remove" == t4.type) {
                    const e4 = t4.position.parent;
                    if (e4.is("element", "blockQuote") && e4.isEmpty)
                      return n3.remove(e4), true;
                  }
                return false;
              });
              const n2 = this.editor.editing.view.document, o2 = t3.model.document.selection, i2 = t3.commands.get("blockQuote");
              this.listenTo(n2, "enter", (e4, n3) => {
                if (!o2.isCollapsed || !i2.value)
                  return;
                o2.getLastPosition().parent.isEmpty && (t3.execute("blockQuote"), t3.editing.view.scrollToTheSelection(), n3.preventDefault(), e4.stop());
              }, { context: "blockquote" }), this.listenTo(n2, "delete", (e4, n3) => {
                if ("backward" != n3.direction || !o2.isCollapsed || !i2.value)
                  return;
                const r2 = o2.getLastPosition().parent;
                r2.isEmpty && !r2.previousSibling && (t3.execute("blockQuote"), t3.editing.view.scrollToTheSelection(), n3.preventDefault(), e4.stop());
              }, { context: "blockquote" });
            }
          }
          var Fp = n(3062), Vp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Fp.Z, Vp);
          Fp.Z.locals;
          class Up extends ue {
            static get pluginName() {
              return "BlockQuoteUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.t;
              t3.ui.componentFactory.add("blockQuote", (n2) => {
                const o2 = t3.commands.get("blockQuote"), i2 = new gh(n2);
                return i2.set({ label: e3("Block quote"), icon: Md.quote, tooltip: true, isToggleable: true }), i2.bind("isOn", "isEnabled").to(o2, "value", "isEnabled"), this.listenTo(i2, "execute", () => {
                  t3.execute("blockQuote"), t3.editing.view.focus();
                }), i2;
              });
            }
          }
          class Hp extends ue {
            static get pluginName() {
              return "CKFinderUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.ui.componentFactory, n2 = t3.t;
              e3.add("ckfinder", (e4) => {
                const o2 = t3.commands.get("ckfinder"), i2 = new gh(e4);
                return i2.set({ label: n2("Insert image or file"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', tooltip: true }), i2.bind("isEnabled").to(o2), i2.on("execute", () => {
                  t3.execute("ckfinder"), t3.editing.view.focus();
                }), i2;
              });
            }
          }
          class qp extends me {
            constructor(t3) {
              super(t3), this.stopListening(this.editor.model.document, "change"), this.listenTo(this.editor.model.document, "change", () => this.refresh(), { priority: "low" });
            }
            refresh() {
              const t3 = this.editor.commands.get("insertImage"), e3 = this.editor.commands.get("link");
              this.isEnabled = t3.isEnabled || e3.isEnabled;
            }
            execute() {
              const t3 = this.editor, e3 = this.editor.config.get("ckfinder.openerMethod") || "modal";
              if ("popup" != e3 && "modal" != e3)
                throw new a("ckfinder-unknown-openermethod", t3);
              const n2 = this.editor.config.get("ckfinder.options") || {};
              n2.chooseFiles = true;
              const o2 = n2.onInit;
              n2.language || (n2.language = t3.locale.uiLanguage), n2.onInit = (e4) => {
                o2 && o2(e4), e4.on("files:choose", (n3) => {
                  const o3 = n3.data.files.toArray(), i2 = o3.filter((t4) => !t4.isImage()), r2 = o3.filter((t4) => t4.isImage());
                  for (const e5 of i2)
                    t3.execute("link", e5.getUrl());
                  const s2 = [];
                  for (const t4 of r2) {
                    const n4 = t4.getUrl();
                    s2.push(n4 || e4.request("file:getProxyUrl", { file: t4 }));
                  }
                  s2.length && Wp(t3, s2);
                }), e4.on("file:choose:resizedImage", (e5) => {
                  const n3 = e5.data.resizedUrl;
                  if (n3)
                    Wp(t3, [n3]);
                  else {
                    const e6 = t3.plugins.get("Notification"), n4 = t3.locale.t;
                    e6.showWarning(n4("Could not obtain resized image URL."), { title: n4("Selecting resized image failed"), namespace: "ckfinder" });
                  }
                });
              }, window.CKFinder[e3](n2);
            }
          }
          function Wp(t3, e3) {
            if (t3.commands.get("insertImage").isEnabled)
              t3.execute("insertImage", { source: e3 });
            else {
              const e4 = t3.plugins.get("Notification"), n2 = t3.locale.t;
              e4.showWarning(n2("Could not insert image at the current position."), { title: n2("Inserting image failed"), namespace: "ckfinder" });
            }
          }
          class Gp extends ue {
            static get pluginName() {
              return "CKFinderEditing";
            }
            static get requires() {
              return [Cu, "LinkEditing"];
            }
            init() {
              const t3 = this.editor;
              if (!t3.plugins.has("ImageBlockEditing") && !t3.plugins.has("ImageInlineEditing"))
                throw new a("ckfinder-missing-image-plugin", t3);
              t3.commands.add("ckfinder", new qp(t3));
            }
          }
          class Yp extends ue {
            static get pluginName() {
              return "CloudServicesUploadAdapter";
            }
            static get requires() {
              return ["CloudServices", mp];
            }
            init() {
              const t3 = this.editor, e3 = t3.plugins.get("CloudServices"), n2 = e3.token, o2 = e3.uploadUrl;
              n2 && (this._uploadGateway = t3.plugins.get("CloudServicesCore").createUploadGateway(n2, o2), t3.plugins.get(mp).createUploadAdapter = (t4) => new Qp(this._uploadGateway, t4));
            }
          }
          class Qp {
            constructor(t3, e3) {
              this.uploadGateway = t3, this.loader = e3;
            }
            upload() {
              return this.loader.file.then((t3) => (this.fileUploader = this.uploadGateway.upload(t3), this.fileUploader.on("progress", (t4, e3) => {
                this.loader.uploadTotal = e3.total, this.loader.uploaded = e3.uploaded;
              }), this.fileUploader.send()));
            }
            abort() {
              this.fileUploader.abort();
            }
          }
          class Kp extends me {
            refresh() {
              const t3 = this.editor.model, e3 = Aa(t3.document.selection.getSelectedBlocks());
              this.value = !!e3 && e3.is("element", "paragraph"), this.isEnabled = !!e3 && $p(e3, t3.schema);
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.document;
              e3.change((o2) => {
                const i2 = (t3.selection || n2.selection).getSelectedBlocks();
                for (const t4 of i2)
                  !t4.is("element", "paragraph") && $p(t4, e3.schema) && o2.rename(t4, "paragraph");
              });
            }
          }
          function $p(t3, e3) {
            return e3.checkChild(t3.parent, "paragraph") && !e3.isObject(t3);
          }
          class Zp extends me {
            execute(t3) {
              const e3 = this.editor.model;
              let n2 = t3.position;
              e3.change((t4) => {
                const o2 = t4.createElement("paragraph");
                if (!e3.schema.checkChild(n2.parent, o2)) {
                  const i2 = e3.schema.findAllowedParent(n2, o2);
                  if (!i2)
                    return;
                  n2 = t4.split(n2, i2).position;
                }
                e3.insertContent(o2, n2), t4.setSelection(o2, "in");
              });
            }
          }
          class Jp extends ue {
            static get pluginName() {
              return "Paragraph";
            }
            init() {
              const t3 = this.editor, e3 = t3.model;
              t3.commands.add("paragraph", new Kp(t3)), t3.commands.add("insertParagraph", new Zp(t3)), e3.schema.register("paragraph", { inheritAllFrom: "$block" }), t3.conversion.elementToElement({ model: "paragraph", view: "p" }), t3.conversion.for("upcast").elementToElement({ model: (t4, { writer: e4 }) => Jp.paragraphLikeElements.has(t4.name) ? t4.isEmpty ? null : e4.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
            }
          }
          Jp.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
          class Xp extends me {
            constructor(t3, e3) {
              super(t3), this.modelElements = e3;
            }
            refresh() {
              const t3 = Aa(this.editor.model.document.selection.getSelectedBlocks());
              this.value = !!t3 && this.modelElements.includes(t3.name) && t3.name, this.isEnabled = !!t3 && this.modelElements.some((e3) => tf(t3, e3, this.editor.model.schema));
            }
            execute(t3) {
              const e3 = this.editor.model, n2 = e3.document, o2 = t3.value;
              e3.change((t4) => {
                const i2 = Array.from(n2.selection.getSelectedBlocks()).filter((t5) => tf(t5, o2, e3.schema));
                for (const e4 of i2)
                  e4.is("element", o2) || t4.rename(e4, o2);
              });
            }
          }
          function tf(t3, e3, n2) {
            return n2.checkChild(t3.parent, e3) && !n2.isObject(t3);
          }
          const ef = "paragraph";
          class nf extends ue {
            static get pluginName() {
              return "HeadingEditing";
            }
            constructor(t3) {
              super(t3), t3.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
            }
            static get requires() {
              return [Jp];
            }
            init() {
              const t3 = this.editor, e3 = t3.config.get("heading.options"), n2 = [];
              for (const o2 of e3)
                o2.model !== ef && (t3.model.schema.register(o2.model, { inheritAllFrom: "$block" }), t3.conversion.elementToElement(o2), n2.push(o2.model));
              this._addDefaultH1Conversion(t3), t3.commands.add("heading", new Xp(t3, n2));
            }
            afterInit() {
              const t3 = this.editor, e3 = t3.commands.get("enter"), n2 = t3.config.get("heading.options");
              e3 && this.listenTo(e3, "afterExecute", (e4, o2) => {
                const i2 = t3.model.document.selection.getFirstPosition().parent;
                n2.some((t4) => i2.is("element", t4.model)) && !i2.is("element", ef) && 0 === i2.childCount && o2.writer.rename(i2, ef);
              });
            }
            _addDefaultH1Conversion(t3) {
              t3.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: s.get("low") + 1 });
            }
          }
          var of = n(8733), rf = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(of.Z, rf);
          of.Z.locals;
          class sf extends ue {
            static get pluginName() {
              return "HeadingUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.t, n2 = function(t4) {
                const e4 = t4.t, n3 = { Paragraph: e4("Paragraph"), "Heading 1": e4("Heading 1"), "Heading 2": e4("Heading 2"), "Heading 3": e4("Heading 3"), "Heading 4": e4("Heading 4"), "Heading 5": e4("Heading 5"), "Heading 6": e4("Heading 6") };
                return t4.config.get("heading.options").map((t5) => {
                  const e5 = n3[t5.title];
                  return e5 && e5 != t5.title && (t5.title = e5), t5;
                });
              }(t3), o2 = e3("Choose heading"), i2 = e3("Heading");
              t3.ui.componentFactory.add("heading", (e4) => {
                const r2 = {}, s2 = new Io(), a2 = t3.commands.get("heading"), c2 = t3.commands.get("paragraph"), l2 = [a2];
                for (const t4 of n2) {
                  const e5 = { type: "button", model: new Au({ label: t4.title, class: t4.class, withText: true }) };
                  "paragraph" === t4.model ? (e5.model.bind("isOn").to(c2, "value"), e5.model.set("commandName", "paragraph"), l2.push(c2)) : (e5.model.bind("isOn").to(a2, "value", (e6) => e6 === t4.model), e5.model.set({ commandName: "heading", commandValue: t4.model })), s2.add(e5), r2[t4.model] = t4.title;
                }
                const d2 = Jh(e4);
                return tu(d2, s2), d2.buttonView.set({ isOn: false, withText: true, tooltip: i2 }), d2.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), d2.bind("isEnabled").toMany(l2, "isEnabled", (...t4) => t4.some((t5) => t5)), d2.buttonView.bind("label").to(a2, "value", c2, "value", (t4, e5) => {
                  const n3 = t4 || e5 && "paragraph";
                  return r2[n3] ? r2[n3] : o2;
                }), this.listenTo(d2, "execute", (e5) => {
                  t3.execute(e5.source.commandName, e5.source.commandValue ? { value: e5.source.commandValue } : void 0), t3.editing.view.focus();
                }), d2;
              });
            }
          }
          class af extends ue {
            static get requires() {
              return [zu];
            }
            static get pluginName() {
              return "WidgetToolbarRepository";
            }
            init() {
              const t3 = this.editor;
              if (t3.plugins.has("BalloonToolbar")) {
                const e3 = t3.plugins.get("BalloonToolbar");
                this.listenTo(e3, "show", (e4) => {
                  (function(t4) {
                    const e5 = t4.getSelectedElement();
                    return !(!e5 || !jg(e5));
                  })(t3.editing.view.document.selection) && e4.stop();
                }, { priority: "high" });
              }
              this._toolbarDefinitions = /* @__PURE__ */ new Map(), this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
                this._updateToolbarsVisibility();
              }), this.listenTo(t3.ui, "update", () => {
                this._updateToolbarsVisibility();
              }), this.listenTo(t3.ui.focusTracker, "change:isFocused", () => {
                this._updateToolbarsVisibility();
              }, { priority: "low" });
            }
            destroy() {
              super.destroy();
              for (const t3 of this._toolbarDefinitions.values())
                t3.view.destroy();
            }
            register(t3, { ariaLabel: e3, items: n2, getRelatedElement: o2, balloonClassName: i2 = "ck-toolbar-container" }) {
              if (!n2.length)
                return void c("widget-toolbar-no-items", { toolbarId: t3 });
              const r2 = this.editor, s2 = r2.t, l2 = new jh(r2.locale);
              if (l2.ariaLabel = e3 || s2("Widget toolbar"), this._toolbarDefinitions.has(t3))
                throw new a("widget-toolbar-duplicated", this, { toolbarId: t3 });
              l2.fillFromConfig(n2, r2.ui.componentFactory), this._toolbarDefinitions.set(t3, { view: l2, getRelatedElement: o2, balloonClassName: i2 });
            }
            _updateToolbarsVisibility() {
              let t3 = 0, e3 = null, n2 = null;
              for (const o2 of this._toolbarDefinitions.values()) {
                const i2 = o2.getRelatedElement(this.editor.editing.view.document.selection);
                if (this.isEnabled && i2)
                  if (this.editor.ui.focusTracker.isFocused) {
                    const r2 = i2.getAncestors().length;
                    r2 > t3 && (t3 = r2, e3 = i2, n2 = o2);
                  } else
                    this._isToolbarVisible(o2) && this._hideToolbar(o2);
                else
                  this._isToolbarInBalloon(o2) && this._hideToolbar(o2);
              }
              n2 && this._showToolbar(n2, e3);
            }
            _hideToolbar(t3) {
              this._balloon.remove(t3.view), this.stopListening(this._balloon, "change:visibleView");
            }
            _showToolbar(t3, e3) {
              this._isToolbarVisible(t3) ? cf(this.editor, e3) : this._isToolbarInBalloon(t3) || (this._balloon.add({ view: t3.view, position: lf(this.editor, e3), balloonClassName: t3.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
                for (const t4 of this._toolbarDefinitions.values())
                  if (this._isToolbarVisible(t4)) {
                    const e4 = t4.getRelatedElement(this.editor.editing.view.document.selection);
                    cf(this.editor, e4);
                  }
              }));
            }
            _isToolbarVisible(t3) {
              return this._balloon.visibleView === t3.view;
            }
            _isToolbarInBalloon(t3) {
              return this._balloon.hasView(t3.view);
            }
          }
          function cf(t3, e3) {
            const n2 = t3.plugins.get("ContextualBalloon"), o2 = lf(t3, e3);
            n2.updatePosition(o2);
          }
          function lf(t3, e3) {
            const n2 = t3.editing.view, o2 = Du.defaultPositions;
            return { target: n2.domConverter.mapViewToDom(e3), positions: [o2.northArrowSouth, o2.northArrowSouthWest, o2.northArrowSouthEast, o2.southArrowNorth, o2.southArrowNorthWest, o2.southArrowNorthEast, o2.viewportStickyNorth] };
          }
          class df {
            constructor(t3) {
              this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = t3, this._referenceCoordinates = null;
            }
            begin(t3, e3, n2) {
              const o2 = new fa(e3);
              this.activeHandlePosition = function(t4) {
                const e4 = ["top-left", "top-right", "bottom-right", "bottom-left"];
                for (const n3 of e4)
                  if (t4.classList.contains(hf(n3)))
                    return n3;
              }(t3), this._referenceCoordinates = function(t4, e4) {
                const n3 = new fa(t4), o3 = e4.split("-"), i3 = { x: "right" == o3[1] ? n3.right : n3.left, y: "bottom" == o3[0] ? n3.bottom : n3.top };
                return i3.x += t4.ownerDocument.defaultView.scrollX, i3.y += t4.ownerDocument.defaultView.scrollY, i3;
              }(e3, function(t4) {
                const e4 = t4.split("-"), n3 = { top: "bottom", bottom: "top", left: "right", right: "left" };
                return `${n3[e4[0]]}-${n3[e4[1]]}`;
              }(this.activeHandlePosition)), this.originalWidth = o2.width, this.originalHeight = o2.height, this.aspectRatio = o2.width / o2.height;
              const i2 = n2.style.width;
              i2 && i2.match(/^\d+(\.\d*)?%$/) ? this.originalWidthPercents = parseFloat(i2) : this.originalWidthPercents = function(t4, e4) {
                const n3 = t4.parentElement, o3 = parseFloat(n3.ownerDocument.defaultView.getComputedStyle(n3).width);
                return e4.width / o3 * 100;
              }(n2, o2);
            }
            update(t3) {
              this.proposedWidth = t3.width, this.proposedHeight = t3.height, this.proposedWidthPercents = t3.widthPercents, this.proposedHandleHostWidth = t3.handleHostWidth, this.proposedHandleHostHeight = t3.handleHostHeight;
            }
          }
          function hf(t3) {
            return `ck-widget__resizer__handle-${t3}`;
          }
          he(df, re);
          class uf extends Ld {
            constructor() {
              super();
              const t3 = this.bindTemplate;
              this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-size-view", t3.to("_viewPosition", (t4) => t4 ? `ck-orientation-${t4}` : "")], style: { display: t3.if("_isVisible", "none", (t4) => !t4) } }, children: [{ text: t3.to("_label") }] });
            }
            _bindToState(t3, e3) {
              this.bind("_isVisible").to(e3, "proposedWidth", e3, "proposedHeight", (t4, e4) => null !== t4 && null !== e4), this.bind("_label").to(e3, "proposedHandleHostWidth", e3, "proposedHandleHostHeight", e3, "proposedWidthPercents", (e4, n2, o2) => "px" === t3.unit ? `${e4}\xD7${n2}` : `${o2}%`), this.bind("_viewPosition").to(e3, "activeHandlePosition", e3, "proposedHandleHostWidth", e3, "proposedHandleHostHeight", (t4, e4, n2) => e4 < 50 || n2 < 50 ? "above-center" : t4);
            }
            _dismiss() {
              this.unbind(), this._isVisible = false;
            }
          }
          class gf {
            constructor(t3) {
              this._options = t3, this._viewResizerWrapper = null, this.set("isEnabled", true), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t4) => {
                this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), t4.stop());
              }, { priority: "high" }), this.on("change:isEnabled", () => {
                this.isEnabled && this.redraw();
              });
            }
            attach() {
              const t3 = this, e3 = this._options.viewElement;
              this._options.editor.editing.view.change((n2) => {
                const o2 = n2.createUIElement("div", { class: "ck ck-reset_all ck-widget__resizer" }, function(e4) {
                  const n3 = this.toDomElement(e4);
                  return t3._appendHandles(n3), t3._appendSizeUI(n3), t3.on("change:isEnabled", (t4, e5, o3) => {
                    n3.style.display = o3 ? "" : "none";
                  }), n3.style.display = t3.isEnabled ? "" : "none", n3;
                });
                n2.insert(n2.createPositionAt(e3, "end"), o2), n2.addClass("ck-widget_with-resizer", e3), this._viewResizerWrapper = o2;
              });
            }
            begin(t3) {
              this.state = new df(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(t3, this._getHandleHost(), this._getResizeHost());
            }
            updateSize(t3) {
              const e3 = this._proposeNewSize(t3);
              this._options.editor.editing.view.change((t4) => {
                const n3 = this._options.unit || "%", o3 = ("%" === n3 ? e3.widthPercents : e3.width) + n3;
                t4.setStyle("width", o3, this._options.viewElement);
              });
              const n2 = this._getHandleHost(), o2 = new fa(n2);
              e3.handleHostWidth = Math.round(o2.width), e3.handleHostHeight = Math.round(o2.height);
              const i2 = new fa(n2);
              e3.width = Math.round(i2.width), e3.height = Math.round(i2.height), this.redraw(o2), this.state.update(e3);
            }
            commit() {
              const t3 = this._options.unit || "%", e3 = ("%" === t3 ? this.state.proposedWidthPercents : this.state.proposedWidth) + t3;
              this._options.editor.editing.view.change(() => {
                this._cleanup(), this._options.onCommit(e3);
              });
            }
            cancel() {
              this._cleanup();
            }
            destroy() {
              this.cancel();
            }
            redraw(t3) {
              const e3 = this._domResizerWrapper;
              if (!((n2 = e3) && n2.ownerDocument && n2.ownerDocument.contains(n2)))
                return;
              var n2;
              const o2 = e3.parentElement, i2 = this._getHandleHost(), r2 = this._viewResizerWrapper, s2 = [r2.getStyle("width"), r2.getStyle("height"), r2.getStyle("left"), r2.getStyle("top")];
              let a2;
              if (o2.isSameNode(i2)) {
                const e4 = t3 || new fa(i2);
                a2 = [e4.width + "px", e4.height + "px", void 0, void 0];
              } else
                a2 = [i2.offsetWidth + "px", i2.offsetHeight + "px", i2.offsetLeft + "px", i2.offsetTop + "px"];
              "same" !== Oo(s2, a2) && this._options.editor.editing.view.change((t4) => {
                t4.setStyle({ width: a2[0], height: a2[1], left: a2[2], top: a2[3] }, r2);
              });
            }
            containsHandle(t3) {
              return this._domResizerWrapper.contains(t3);
            }
            static isResizeHandle(t3) {
              return t3.classList.contains("ck-widget__resizer__handle");
            }
            _cleanup() {
              this._sizeView._dismiss();
              this._options.editor.editing.view.change((t3) => {
                t3.setStyle("width", this._initialViewWidth, this._options.viewElement);
              });
            }
            _proposeNewSize(t3) {
              const e3 = this.state, n2 = { x: (o2 = t3).pageX, y: o2.pageY };
              var o2;
              const i2 = !this._options.isCentered || this._options.isCentered(this), r2 = { x: e3._referenceCoordinates.x - (n2.x + e3.originalWidth), y: n2.y - e3.originalHeight - e3._referenceCoordinates.y };
              i2 && e3.activeHandlePosition.endsWith("-right") && (r2.x = n2.x - (e3._referenceCoordinates.x + e3.originalWidth)), i2 && (r2.x *= 2);
              const s2 = { width: Math.abs(e3.originalWidth + r2.x), height: Math.abs(e3.originalHeight + r2.y) };
              s2.dominant = s2.width / e3.aspectRatio > s2.height ? "width" : "height", s2.max = s2[s2.dominant];
              const a2 = { width: s2.width, height: s2.height };
              return "width" == s2.dominant ? a2.height = a2.width / e3.aspectRatio : a2.width = a2.height * e3.aspectRatio, { width: Math.round(a2.width), height: Math.round(a2.height), widthPercents: Math.min(Math.round(e3.originalWidthPercents / e3.originalWidth * a2.width * 100) / 100, 100) };
            }
            _getResizeHost() {
              const t3 = this._domResizerWrapper.parentElement;
              return this._options.getResizeHost(t3);
            }
            _getHandleHost() {
              const t3 = this._domResizerWrapper.parentElement;
              return this._options.getHandleHost(t3);
            }
            get _domResizerWrapper() {
              return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
            }
            _appendHandles(t3) {
              const e3 = ["top-left", "top-right", "bottom-right", "bottom-left"];
              for (const o2 of e3)
                t3.appendChild(new Od({ tag: "div", attributes: { class: "ck-widget__resizer__handle " + (n2 = o2, `ck-widget__resizer__handle-${n2}`) } }).render());
              var n2;
            }
            _appendSizeUI(t3) {
              this._sizeView = new uf(), this._sizeView.render(), t3.appendChild(this._sizeView.element);
            }
          }
          he(gf, re);
          var mf = n(8506), pf = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(mf.Z, pf);
          mf.Z.locals;
          he(class extends ue {
            static get pluginName() {
              return "WidgetResize";
            }
            init() {
              const t3 = this.editor.editing, e3 = is.window.document;
              this.set("visibleResizer", null), this.set("_activeResizer", null), this._resizers = /* @__PURE__ */ new Map(), t3.view.addObserver(lg), this._observer = Object.create(ws), this.listenTo(t3.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(e3, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(e3, "mouseup", this._mouseUpListener.bind(this));
              const n2 = () => {
                this.visibleResizer && this.visibleResizer.redraw();
              };
              this._redrawFocusedResizerThrottled = um(n2, 200), this.on("change:visibleResizer", n2), this.editor.ui.on("update", this._redrawFocusedResizerThrottled), this.editor.model.document.on("change", () => {
                for (const [t4, e4] of this._resizers)
                  t4.isAttached() || (this._resizers.delete(t4), e4.destroy());
              }, { priority: "lowest" }), this._observer.listenTo(is.window, "resize", this._redrawFocusedResizerThrottled);
              const o2 = this.editor.editing.view.document.selection;
              o2.on("change", () => {
                const t4 = o2.getSelectedElement();
                this.visibleResizer = this.getResizerByViewElement(t4) || null;
              });
            }
            destroy() {
              this._observer.stopListening();
              for (const t3 of this._resizers.values())
                t3.destroy();
              this._redrawFocusedResizerThrottled.cancel();
            }
            attachTo(t3) {
              const e3 = new gf(t3), n2 = this.editor.plugins;
              if (e3.attach(), n2.has("WidgetToolbarRepository")) {
                const t4 = n2.get("WidgetToolbarRepository");
                e3.on("begin", () => {
                  t4.forceDisabled("resize");
                }, { priority: "lowest" }), e3.on("cancel", () => {
                  t4.clearForceDisabled("resize");
                }, { priority: "highest" }), e3.on("commit", () => {
                  t4.clearForceDisabled("resize");
                }, { priority: "highest" });
              }
              this._resizers.set(t3.viewElement, e3);
              const o2 = this.editor.editing.view.document.selection.getSelectedElement();
              return this.getResizerByViewElement(o2) == e3 && (this.visibleResizer = e3), e3;
            }
            getResizerByViewElement(t3) {
              return this._resizers.get(t3);
            }
            _getResizerByHandle(t3) {
              for (const e3 of this._resizers.values())
                if (e3.containsHandle(t3))
                  return e3;
            }
            _mouseDownListener(t3, e3) {
              const n2 = e3.domTarget;
              gf.isResizeHandle(n2) && (this._activeResizer = this._getResizerByHandle(n2), this._activeResizer && (this._activeResizer.begin(n2), t3.stop(), e3.preventDefault()));
            }
            _mouseMoveListener(t3, e3) {
              this._activeResizer && this._activeResizer.updateSize(e3);
            }
            _mouseUpListener() {
              this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
            }
          }, re);
          class ff extends me {
            refresh() {
              const t3 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
              this.isEnabled = !!t3, this.isEnabled && t3.hasAttribute("alt") ? this.value = t3.getAttribute("alt") : this.value = false;
            }
            execute(t3) {
              const e3 = this.editor, n2 = e3.plugins.get("ImageUtils"), o2 = e3.model, i2 = n2.getClosestSelectedImageElement(o2.document.selection);
              o2.change((e4) => {
                e4.setAttribute("alt", t3.newValue, i2);
              });
            }
          }
          function kf(t3) {
            return t3.createContainerElement("figure", { class: "image" }, [t3.createEmptyElement("img"), t3.createSlot()]);
          }
          function bf(t3, e3) {
            if (t3.plugins.has("ImageInlineEditing") !== t3.plugins.has("ImageBlockEditing"))
              return { name: "img" };
            const n2 = t3.plugins.get("ImageUtils");
            return (t4) => {
              if (!n2.isInlineImageView(t4))
                return null;
              return (t4.findAncestor(n2.isBlockImageView) ? "imageBlock" : "imageInline") !== e3 ? null : { name: true };
            };
          }
          function wf(t3, e3) {
            const n2 = Aa(e3.getSelectedBlocks());
            return !n2 || t3.isObject(n2) || n2.isEmpty && "listItem" != n2.name ? "imageBlock" : "imageInline";
          }
          class Cf extends ue {
            static get pluginName() {
              return "ImageUtils";
            }
            isImage(t3) {
              return this.isInlineImage(t3) || this.isBlockImage(t3);
            }
            isInlineImageView(t3) {
              return !!t3 && t3.is("element", "img");
            }
            isBlockImageView(t3) {
              return !!t3 && t3.is("element", "figure") && t3.hasClass("image");
            }
            insertImage(t3 = {}, e3 = null, n2 = null) {
              const o2 = this.editor, i2 = o2.model, r2 = i2.document.selection;
              n2 = Af(o2, e3 || r2, n2), t3 = { ...Object.fromEntries(r2.getAttributes()), ...t3 };
              for (const e4 in t3)
                i2.schema.checkAttribute(n2, e4) || delete t3[e4];
              return i2.change((o3) => {
                const s2 = o3.createElement(n2, t3);
                return e3 || "imageInline" == n2 || (e3 = Gg(r2, i2)), i2.insertContent(s2, e3), s2.parent ? (o3.setSelection(s2, "on"), s2) : null;
              });
            }
            getClosestSelectedImageWidget(t3) {
              const e3 = t3.getSelectedElement();
              if (e3 && this.isImageWidget(e3))
                return e3;
              let n2 = t3.getFirstPosition().parent;
              for (; n2; ) {
                if (n2.is("element") && this.isImageWidget(n2))
                  return n2;
                n2 = n2.parent;
              }
              return null;
            }
            getClosestSelectedImageElement(t3) {
              const e3 = t3.getSelectedElement();
              return this.isImage(e3) ? e3 : t3.getFirstPosition().findAncestor("imageBlock");
            }
            isImageAllowed() {
              const t3 = this.editor.model.document.selection;
              return function(t4, e3) {
                if ("imageBlock" == Af(t4, e3)) {
                  const n2 = function(t5, e4) {
                    const n3 = Gg(t5, e4).start.parent;
                    if (n3.isEmpty && !n3.is("element", "$root"))
                      return n3.parent;
                    return n3;
                  }(e3, t4.model);
                  if (t4.model.schema.checkChild(n2, "imageBlock"))
                    return true;
                } else if (t4.model.schema.checkChild(e3.focus, "imageInline"))
                  return true;
                return false;
              }(this.editor, t3) && function(t4) {
                return [...t4.focus.getAncestors()].every((t5) => !t5.is("element", "imageBlock"));
              }(t3);
            }
            toImageWidget(t3, e3, n2) {
              e3.setCustomProperty("image", true, t3);
              return Fg(t3, e3, { label: () => {
                const e4 = this.findViewImgElement(t3).getAttribute("alt");
                return e4 ? `${e4} ${n2}` : n2;
              } });
            }
            isImageWidget(t3) {
              return !!t3.getCustomProperty("image") && jg(t3);
            }
            isBlockImage(t3) {
              return !!t3 && t3.is("element", "imageBlock");
            }
            isInlineImage(t3) {
              return !!t3 && t3.is("element", "imageInline");
            }
            findViewImgElement(t3) {
              if (this.isInlineImageView(t3))
                return t3;
              const e3 = this.editor.editing.view;
              for (const { item: n2 } of e3.createRangeIn(t3))
                if (this.isInlineImageView(n2))
                  return n2;
            }
          }
          function Af(t3, e3, n2) {
            const o2 = t3.model.schema, i2 = t3.config.get("image.insert.type");
            return t3.plugins.has("ImageBlockEditing") ? t3.plugins.has("ImageInlineEditing") ? n2 || ("inline" === i2 ? "imageInline" : "block" === i2 ? "imageBlock" : e3.is("selection") ? wf(o2, e3) : o2.checkChild(e3, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
          }
          class _f extends ue {
            static get requires() {
              return [Cf];
            }
            static get pluginName() {
              return "ImageTextAlternativeEditing";
            }
            init() {
              this.editor.commands.add("imageTextAlternative", new ff(this.editor));
            }
          }
          var vf = n(1905), yf = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(vf.Z, yf);
          vf.Z.locals;
          var xf = n(6764), Ef = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(xf.Z, Ef);
          xf.Z.locals;
          class Df extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.locale.t;
              this.focusTracker = new _a(), this.keystrokes = new va(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(e3("Save"), Md.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(e3("Cancel"), Md.cancel, "ck-button-cancel", "cancel"), this._focusables = new Bd(), this._focusCycler = new Nh({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] }), Td(this);
            }
            render() {
              super.render(), this.keystrokes.listenTo(this.element), Nd({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t3) => {
                this._focusables.add(t3), this.focusTracker.add(t3.element);
              });
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
            }
            _createButton(t3, e3, n2, o2) {
              const i2 = new gh(this.locale);
              return i2.set({ label: t3, icon: e3, tooltip: true }), i2.extendTemplate({ attributes: { class: n2 } }), o2 && i2.delegate("execute").to(this, o2), i2;
            }
            _createLabeledInputView() {
              const t3 = this.locale.t, e3 = new bu(this.locale, wu);
              return e3.label = t3("Text alternative"), e3;
            }
          }
          function If(t3) {
            const e3 = t3.editing.view, n2 = Du.defaultPositions, o2 = t3.plugins.get("ImageUtils");
            return { target: e3.domConverter.viewToDom(o2.getClosestSelectedImageWidget(e3.document.selection)), positions: [n2.northArrowSouth, n2.northArrowSouthWest, n2.northArrowSouthEast, n2.southArrowNorth, n2.southArrowNorthWest, n2.southArrowNorthEast, n2.viewportStickyNorth] };
          }
          class Mf extends ue {
            static get requires() {
              return [zu];
            }
            static get pluginName() {
              return "ImageTextAlternativeUI";
            }
            init() {
              this._createButton(), this._createForm();
            }
            destroy() {
              super.destroy(), this._form.destroy();
            }
            _createButton() {
              const t3 = this.editor, e3 = t3.t;
              t3.ui.componentFactory.add("imageTextAlternative", (n2) => {
                const o2 = t3.commands.get("imageTextAlternative"), i2 = new gh(n2);
                return i2.set({ label: e3("Change image text alternative"), icon: Md.lowVision, tooltip: true }), i2.bind("isEnabled").to(o2, "isEnabled"), this.listenTo(i2, "execute", () => {
                  this._showForm();
                }), i2;
              });
            }
            _createForm() {
              const t3 = this.editor, e3 = t3.editing.view.document, n2 = t3.plugins.get("ImageUtils");
              this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new Df(t3.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
                t3.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(true);
              }), this.listenTo(this._form, "cancel", () => {
                this._hideForm(true);
              }), this._form.keystrokes.set("Esc", (t4, e4) => {
                this._hideForm(true), e4();
              }), this.listenTo(t3.ui, "update", () => {
                n2.getClosestSelectedImageWidget(e3.selection) ? this._isVisible && function(t4) {
                  const e4 = t4.plugins.get("ContextualBalloon");
                  if (t4.plugins.get("ImageUtils").getClosestSelectedImageWidget(t4.editing.view.document.selection)) {
                    const n3 = If(t4);
                    e4.updatePosition(n3);
                  }
                }(t3) : this._hideForm(true);
              }), Sd({ emitter: this._form, activator: () => this._isVisible, contextElements: [this._balloon.view.element], callback: () => this._hideForm() });
            }
            _showForm() {
              if (this._isVisible)
                return;
              const t3 = this.editor, e3 = t3.commands.get("imageTextAlternative"), n2 = this._form.labeledInput;
              this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: If(t3) }), n2.fieldView.value = n2.fieldView.element.value = e3.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
            }
            _hideForm(t3) {
              this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t3 && this.editor.editing.view.focus());
            }
            get _isVisible() {
              return this._balloon.visibleView === this._form;
            }
            get _isInBalloon() {
              return this._balloon.hasView(this._form);
            }
          }
          class Sf extends ue {
            static get requires() {
              return [_f, Mf];
            }
            static get pluginName() {
              return "ImageTextAlternative";
            }
          }
          function Tf(t3, e3) {
            return (t4) => {
              t4.on(`attribute:srcset:${e3}`, n2);
            };
            function n2(e4, n3, o2) {
              if (!o2.consumable.consume(n3.item, e4.name))
                return;
              const i2 = o2.writer, r2 = o2.mapper.toViewElement(n3.item), s2 = t3.findViewImgElement(r2);
              if (null === n3.attributeNewValue) {
                const t4 = n3.attributeOldValue;
                t4.data && (i2.removeAttribute("srcset", s2), i2.removeAttribute("sizes", s2), t4.width && i2.removeAttribute("width", s2));
              } else {
                const t4 = n3.attributeNewValue;
                t4.data && (i2.setAttribute("srcset", t4.data, s2), i2.setAttribute("sizes", "100vw", s2), t4.width && i2.setAttribute("width", t4.width, s2));
              }
            }
          }
          function Nf(t3, e3, n2) {
            return (t4) => {
              t4.on(`attribute:${n2}:${e3}`, o2);
            };
            function o2(e4, n3, o3) {
              if (!o3.consumable.consume(n3.item, e4.name))
                return;
              const i2 = o3.writer, r2 = o3.mapper.toViewElement(n3.item), s2 = t3.findViewImgElement(r2);
              i2.setAttribute(n3.attributeKey, n3.attributeNewValue || "", s2);
            }
          }
          class Bf extends _s {
            observe(t3) {
              this.listenTo(t3, "load", (t4, e3) => {
                const n2 = e3.target;
                this.checkShouldIgnoreEventFromTarget(n2) || "IMG" == n2.tagName && this._fireEvents(e3);
              }, { useCapture: true });
            }
            _fireEvents(t3) {
              this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", t3));
            }
          }
          class zf extends me {
            constructor(t3) {
              super(t3);
              const e3 = t3.config.get("image.insert.type");
              t3.plugins.has("ImageBlockEditing") || "block" === e3 && c("image-block-plugin-required"), t3.plugins.has("ImageInlineEditing") || "inline" === e3 && c("image-inline-plugin-required");
            }
            refresh() {
              this.isEnabled = this.editor.plugins.get("ImageUtils").isImageAllowed();
            }
            execute(t3) {
              const e3 = So(t3.source), n2 = this.editor.model.document.selection, o2 = this.editor.plugins.get("ImageUtils"), i2 = Object.fromEntries(n2.getAttributes());
              e3.forEach((t4, e4) => {
                const r2 = n2.getSelectedElement();
                if ("string" == typeof t4 && (t4 = { src: t4 }), e4 && r2 && o2.isImage(r2)) {
                  const e5 = this.editor.model.createPositionAfter(r2);
                  o2.insertImage({ ...t4, ...i2 }, e5);
                } else
                  o2.insertImage({ ...t4, ...i2 });
              });
            }
          }
          class Pf extends ue {
            static get requires() {
              return [Cf];
            }
            static get pluginName() {
              return "ImageEditing";
            }
            init() {
              const t3 = this.editor, e3 = t3.conversion;
              t3.editing.view.addObserver(Bf), e3.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: (t4) => {
                const e4 = { data: t4.getAttribute("srcset") };
                return t4.hasAttribute("width") && (e4.width = t4.getAttribute("width")), e4;
              } } });
              const n2 = new zf(t3);
              t3.commands.add("insertImage", n2), t3.commands.add("imageInsert", n2);
            }
          }
          class Lf extends me {
            constructor(t3, e3) {
              super(t3), this._modelElementName = e3;
            }
            refresh() {
              const t3 = this.editor.plugins.get("ImageUtils"), e3 = t3.getClosestSelectedImageElement(this.editor.model.document.selection);
              "imageBlock" === this._modelElementName ? this.isEnabled = t3.isInlineImage(e3) : this.isEnabled = t3.isBlockImage(e3);
            }
            execute() {
              const t3 = this.editor, e3 = this.editor.model, n2 = t3.plugins.get("ImageUtils"), o2 = n2.getClosestSelectedImageElement(e3.document.selection), i2 = Object.fromEntries(o2.getAttributes());
              return i2.src || i2.uploadId ? e3.change((t4) => {
                const r2 = Array.from(e3.markers).filter((t5) => t5.getRange().containsItem(o2)), s2 = n2.insertImage(i2, e3.createSelection(o2, "on"), this._modelElementName);
                if (!s2)
                  return null;
                const a2 = t4.createRangeOn(s2);
                for (const e4 of r2) {
                  const n3 = e4.getRange(), o3 = "$graveyard" != n3.root.rootName ? n3.getJoined(a2, true) : a2;
                  t4.updateMarker(e4, { range: o3 });
                }
                return { oldElement: o2, newElement: s2 };
              }) : null;
            }
          }
          class Of extends ue {
            static get requires() {
              return [Pf, Cf, Cg];
            }
            static get pluginName() {
              return "ImageBlockEditing";
            }
            init() {
              const t3 = this.editor;
              t3.model.schema.register("imageBlock", { isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), t3.plugins.has("ImageInlineEditing") && (t3.commands.add("imageTypeBlock", new Lf(this.editor, "imageBlock")), this._setupClipboardIntegration());
            }
            _setupConversion() {
              const t3 = this.editor, e3 = t3.t, n2 = t3.conversion, o2 = t3.plugins.get("ImageUtils");
              n2.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (t4, { writer: e4 }) => kf(e4) }), n2.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (t4, { writer: n3 }) => o2.toImageWidget(kf(n3), n3, e3("image widget")) }), n2.for("downcast").add(Nf(o2, "imageBlock", "src")).add(Nf(o2, "imageBlock", "alt")).add(Tf(o2, "imageBlock")), n2.for("upcast").elementToElement({ view: bf(t3, "imageBlock"), model: (t4, { writer: e4 }) => e4.createElement("imageBlock", t4.hasAttribute("src") ? { src: t4.getAttribute("src") } : null) }).add(function(t4) {
                return (t5) => {
                  t5.on("element:figure", e4);
                };
                function e4(e5, n3, o3) {
                  if (!o3.consumable.test(n3.viewItem, { name: true, classes: "image" }))
                    return;
                  const i2 = t4.findViewImgElement(n3.viewItem);
                  if (!i2 || !o3.consumable.test(i2, { name: true }))
                    return;
                  o3.consumable.consume(n3.viewItem, { name: true, classes: "image" });
                  const r2 = Aa(o3.convertItem(i2, n3.modelCursor).modelRange.getItems());
                  r2 ? (o3.convertChildren(n3.viewItem, r2), o3.updateConversionResult(r2, n3)) : o3.consumable.revert(n3.viewItem, { name: true, classes: "image" });
                }
              }(o2));
            }
            _setupClipboardIntegration() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.editing.view, o2 = t3.plugins.get("ImageUtils");
              this.listenTo(t3.plugins.get("ClipboardPipeline"), "inputTransformation", (i2, r2) => {
                const s2 = Array.from(r2.content.getChildren());
                let a2;
                if (!s2.every(o2.isInlineImageView))
                  return;
                a2 = r2.targetRanges ? t3.editing.mapper.toModelRange(r2.targetRanges[0]) : e3.document.selection.getFirstRange();
                const c2 = e3.createSelection(a2);
                if ("imageBlock" === wf(e3.schema, c2)) {
                  const t4 = new dg(n2.document), e4 = s2.map((e5) => t4.createElement("figure", { class: "image" }, e5));
                  r2.content = t4.createDocumentFragment(e4);
                }
              });
            }
          }
          var Rf = n(3508), jf = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Rf.Z, jf);
          Rf.Z.locals;
          class Ff extends ue {
            static get requires() {
              return [Of, dm, Sf];
            }
            static get pluginName() {
              return "ImageBlock";
            }
          }
          class Vf extends ue {
            static get requires() {
              return [Pf, Cf, Cg];
            }
            static get pluginName() {
              return "ImageInlineEditing";
            }
            init() {
              const t3 = this.editor, e3 = t3.model.schema;
              e3.register("imageInline", { isObject: true, isInline: true, allowWhere: "$text", allowAttributesOf: "$text", allowAttributes: ["alt", "src", "srcset"] }), e3.addChildCheck((t4, e4) => {
                if (t4.endsWith("caption") && "imageInline" === e4.name)
                  return false;
              }), this._setupConversion(), t3.plugins.has("ImageBlockEditing") && (t3.commands.add("imageTypeInline", new Lf(this.editor, "imageInline")), this._setupClipboardIntegration());
            }
            _setupConversion() {
              const t3 = this.editor, e3 = t3.t, n2 = t3.conversion, o2 = t3.plugins.get("ImageUtils");
              n2.for("dataDowncast").elementToElement({ model: "imageInline", view: (t4, { writer: e4 }) => e4.createEmptyElement("img") }), n2.for("editingDowncast").elementToStructure({ model: "imageInline", view: (t4, { writer: n3 }) => o2.toImageWidget(function(t5) {
                return t5.createContainerElement("span", { class: "image-inline" }, t5.createEmptyElement("img"), { isAllowedInsideAttributeElement: true });
              }(n3), n3, e3("image widget")) }), n2.for("downcast").add(Nf(o2, "imageInline", "src")).add(Nf(o2, "imageInline", "alt")).add(Tf(o2, "imageInline")), n2.for("upcast").elementToElement({ view: bf(t3, "imageInline"), model: (t4, { writer: e4 }) => e4.createElement("imageInline", t4.hasAttribute("src") ? { src: t4.getAttribute("src") } : null) });
            }
            _setupClipboardIntegration() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.editing.view, o2 = t3.plugins.get("ImageUtils");
              this.listenTo(t3.plugins.get("ClipboardPipeline"), "inputTransformation", (i2, r2) => {
                const s2 = Array.from(r2.content.getChildren());
                let a2;
                if (!s2.every(o2.isBlockImageView))
                  return;
                a2 = r2.targetRanges ? t3.editing.mapper.toModelRange(r2.targetRanges[0]) : e3.document.selection.getFirstRange();
                const c2 = e3.createSelection(a2);
                if ("imageInline" === wf(e3.schema, c2)) {
                  const t4 = new dg(n2.document), e4 = s2.map((e5) => 1 === e5.childCount ? (Array.from(e5.getAttributes()).forEach((n3) => t4.setAttribute(...n3, o2.findViewImgElement(e5))), e5.getChild(0)) : e5);
                  r2.content = t4.createDocumentFragment(e4);
                }
              });
            }
          }
          class Uf extends ue {
            static get requires() {
              return [Vf, dm, Sf];
            }
            static get pluginName() {
              return "ImageInline";
            }
          }
          class Hf extends me {
            refresh() {
              const t3 = this.editor, e3 = t3.plugins.get("ImageCaptionUtils");
              if (!t3.plugins.has(Of))
                return this.isEnabled = false, void (this.value = false);
              const n2 = t3.model.document.selection, o2 = n2.getSelectedElement();
              if (!o2) {
                const t4 = e3.getCaptionFromModelSelection(n2);
                return this.isEnabled = !!t4, void (this.value = !!t4);
              }
              this.isEnabled = this.editor.plugins.get("ImageUtils").isImage(o2), this.isEnabled ? this.value = !!e3.getCaptionFromImageModelElement(o2) : this.value = false;
            }
            execute(t3 = {}) {
              const { focusCaptionOnShow: e3 } = t3;
              this.editor.model.change((t4) => {
                this.value ? this._hideImageCaption(t4) : this._showImageCaption(t4, e3);
              });
            }
            _showImageCaption(t3, e3) {
              const n2 = this.editor.model.document.selection, o2 = this.editor.plugins.get("ImageCaptionEditing");
              let i2 = n2.getSelectedElement();
              const r2 = o2._getSavedCaption(i2);
              this.editor.plugins.get("ImageUtils").isInlineImage(i2) && (this.editor.execute("imageTypeBlock"), i2 = n2.getSelectedElement());
              const s2 = r2 || t3.createElement("caption");
              t3.append(s2, i2), e3 && t3.setSelection(s2, "in");
            }
            _hideImageCaption(t3) {
              const e3 = this.editor, n2 = e3.model.document.selection, o2 = e3.plugins.get("ImageCaptionEditing"), i2 = e3.plugins.get("ImageCaptionUtils");
              let r2, s2 = n2.getSelectedElement();
              s2 ? r2 = i2.getCaptionFromImageModelElement(s2) : (r2 = i2.getCaptionFromModelSelection(n2), s2 = r2.parent), o2._saveCaption(s2, r2), t3.setSelection(s2, "on"), t3.remove(r2);
            }
          }
          class qf extends ue {
            static get pluginName() {
              return "ImageCaptionUtils";
            }
            static get requires() {
              return [Cf];
            }
            getCaptionFromImageModelElement(t3) {
              for (const e3 of t3.getChildren())
                if (e3 && e3.is("element", "caption"))
                  return e3;
              return null;
            }
            getCaptionFromModelSelection(t3) {
              const e3 = this.editor.plugins.get("ImageUtils"), n2 = t3.getFirstPosition().findAncestor("caption");
              return n2 && e3.isBlockImage(n2.parent) ? n2 : null;
            }
            matchImageCaptionViewElement(t3) {
              const e3 = this.editor.plugins.get("ImageUtils");
              return "figcaption" == t3.name && e3.isBlockImageView(t3.parent) ? { name: true } : null;
            }
          }
          class Wf extends ue {
            static get requires() {
              return [Cf, qf];
            }
            static get pluginName() {
              return "ImageCaptionEditing";
            }
            constructor(t3) {
              super(t3), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
            }
            init() {
              const t3 = this.editor, e3 = t3.model.schema;
              e3.isRegistered("caption") ? e3.extend("caption", { allowIn: "imageBlock" }) : e3.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: true }), t3.commands.add("toggleImageCaption", new Hf(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration();
            }
            _setupConversion() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = t3.plugins.get("ImageUtils"), o2 = t3.plugins.get("ImageCaptionUtils"), i2 = t3.t;
              t3.conversion.for("upcast").elementToElement({ view: (t4) => o2.matchImageCaptionViewElement(t4), model: "caption" }), t3.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t4, { writer: e4 }) => n2.isBlockImage(t4.parent) ? e4.createContainerElement("figcaption") : null }), t3.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t4, { writer: o3 }) => {
                if (!n2.isBlockImage(t4.parent))
                  return null;
                const r2 = o3.createEditableElement("figcaption");
                return o3.setCustomProperty("imageCaption", true, r2), Gu({ view: e3, element: r2, text: i2("Enter image caption"), keepOnFocus: true }), Wg(r2, o3);
              } });
            }
            _setupImageTypeCommandsIntegration() {
              const t3 = this.editor, e3 = t3.plugins.get("ImageUtils"), n2 = t3.plugins.get("ImageCaptionUtils"), o2 = t3.commands.get("imageTypeInline"), i2 = t3.commands.get("imageTypeBlock"), r2 = (t4) => {
                if (!t4.return)
                  return;
                const { oldElement: o3, newElement: i3 } = t4.return;
                if (!o3)
                  return;
                if (e3.isBlockImage(o3)) {
                  const t5 = n2.getCaptionFromImageModelElement(o3);
                  if (t5)
                    return void this._saveCaption(i3, t5);
                }
                const r3 = this._getSavedCaption(o3);
                r3 && this._saveCaption(i3, r3);
              };
              o2 && this.listenTo(o2, "execute", r2, { priority: "low" }), i2 && this.listenTo(i2, "execute", r2, { priority: "low" });
            }
            _getSavedCaption(t3) {
              const e3 = this._savedCaptionsMap.get(t3);
              return e3 ? Fa.fromJSON(e3) : null;
            }
            _saveCaption(t3, e3) {
              this._savedCaptionsMap.set(t3, e3.toJSON());
            }
          }
          class Gf extends ue {
            static get requires() {
              return [qf];
            }
            static get pluginName() {
              return "ImageCaptionUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view, n2 = t3.plugins.get("ImageCaptionUtils"), o2 = t3.t;
              t3.ui.componentFactory.add("toggleImageCaption", (i2) => {
                const r2 = t3.commands.get("toggleImageCaption"), s2 = new gh(i2);
                return s2.set({ icon: Md.caption, tooltip: true, isToggleable: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), s2.bind("label").to(r2, "value", (t4) => o2(t4 ? "Toggle caption off" : "Toggle caption on")), this.listenTo(s2, "execute", () => {
                  t3.execute("toggleImageCaption", { focusCaptionOnShow: true });
                  const o3 = n2.getCaptionFromModelSelection(t3.model.document.selection);
                  if (o3) {
                    const n3 = t3.editing.mapper.toViewElement(o3);
                    e3.scrollToTheSelection(), e3.change((t4) => {
                      t4.addClass("image__caption_highlighted", n3);
                    });
                  }
                }), s2;
              });
            }
          }
          var Yf = n(2640), Qf = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Yf.Z, Qf);
          Yf.Z.locals;
          class Kf extends me {
            constructor(t3, e3) {
              super(t3), this._defaultStyles = { imageBlock: false, imageInline: false }, this._styles = new Map(e3.map((t4) => {
                if (t4.isDefault)
                  for (const e4 of t4.modelElements)
                    this._defaultStyles[e4] = t4.name;
                return [t4.name, t4];
              }));
            }
            refresh() {
              const t3 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
              this.isEnabled = !!t3, this.isEnabled ? t3.hasAttribute("imageStyle") ? this.value = t3.getAttribute("imageStyle") : this.value = this._defaultStyles[t3.name] : this.value = false;
            }
            execute(t3 = {}) {
              const e3 = this.editor, n2 = e3.model, o2 = e3.plugins.get("ImageUtils");
              n2.change((e4) => {
                const i2 = t3.value;
                let r2 = o2.getClosestSelectedImageElement(n2.document.selection);
                i2 && this.shouldConvertImageType(i2, r2) && (this.editor.execute(o2.isBlockImage(r2) ? "imageTypeInline" : "imageTypeBlock"), r2 = o2.getClosestSelectedImageElement(n2.document.selection)), !i2 || this._styles.get(i2).isDefault ? e4.removeAttribute("imageStyle", r2) : e4.setAttribute("imageStyle", i2, r2);
              });
            }
            shouldConvertImageType(t3, e3) {
              return !this._styles.get(t3).modelElements.includes(e3.name);
            }
          }
          const { objectFullWidth: $f, objectInline: Zf, objectLeft: Jf, objectRight: Xf, objectCenter: tk, objectBlockLeft: ek, objectBlockRight: nk } = Md, ok = { get inline() {
            return { name: "inline", title: "In line", icon: Zf, modelElements: ["imageInline"], isDefault: true };
          }, get alignLeft() {
            return { name: "alignLeft", title: "Left aligned image", icon: Jf, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
          }, get alignBlockLeft() {
            return { name: "alignBlockLeft", title: "Left aligned image", icon: ek, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
          }, get alignCenter() {
            return { name: "alignCenter", title: "Centered image", icon: tk, modelElements: ["imageBlock"], className: "image-style-align-center" };
          }, get alignRight() {
            return { name: "alignRight", title: "Right aligned image", icon: Xf, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
          }, get alignBlockRight() {
            return { name: "alignBlockRight", title: "Right aligned image", icon: nk, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
          }, get block() {
            return { name: "block", title: "Centered image", icon: tk, modelElements: ["imageBlock"], isDefault: true };
          }, get side() {
            return { name: "side", title: "Side image", icon: Xf, modelElements: ["imageBlock"], className: "image-style-side" };
          } }, ik = { full: $f, left: ek, right: nk, center: tk, inlineLeft: Jf, inlineRight: Xf, inline: Zf }, rk = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
          function sk(t3) {
            c("image-style-configuration-definition-invalid", t3);
          }
          const ak = { normalizeStyles: function(t3) {
            return (t3.configuredStyles.options || []).map((t4) => function(t5) {
              t5 = "string" == typeof t5 ? ok[t5] ? { ...ok[t5] } : { name: t5 } : function(t6, e3) {
                const n2 = { ...e3 };
                for (const o2 in t6)
                  Object.prototype.hasOwnProperty.call(e3, o2) || (n2[o2] = t6[o2]);
                return n2;
              }(ok[t5.name], t5);
              "string" == typeof t5.icon && (t5.icon = ik[t5.icon] || t5.icon);
              return t5;
            }(t4)).filter((e3) => function(t4, { isBlockPluginLoaded: e4, isInlinePluginLoaded: n2 }) {
              const { modelElements: o2, name: i2 } = t4;
              if (!(o2 && o2.length && i2))
                return sk({ style: t4 }), false;
              {
                const i3 = [e4 ? "imageBlock" : null, n2 ? "imageInline" : null];
                if (!o2.some((t5) => i3.includes(t5)))
                  return c("image-style-missing-dependency", { style: t4, missingPlugins: o2.map((t5) => "imageBlock" === t5 ? "ImageBlockEditing" : "ImageInlineEditing") }), false;
              }
              return true;
            }(e3, t3));
          }, getDefaultStylesConfiguration: function(t3, e3) {
            return t3 && e3 ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : t3 ? { options: ["block", "side"] } : e3 ? { options: ["inline", "alignLeft", "alignRight"] } : {};
          }, getDefaultDropdownDefinitions: function(t3) {
            return t3.has("ImageBlockEditing") && t3.has("ImageInlineEditing") ? [...rk] : [];
          }, warnInvalidStyle: sk, DEFAULT_OPTIONS: ok, DEFAULT_ICONS: ik, DEFAULT_DROPDOWN_DEFINITIONS: rk };
          function ck(t3, e3) {
            for (const n2 of e3)
              if (n2.name === t3)
                return n2;
          }
          class lk extends ue {
            static get pluginName() {
              return "ImageStyleEditing";
            }
            static get requires() {
              return [Cf];
            }
            init() {
              const { normalizeStyles: t3, getDefaultStylesConfiguration: e3 } = ak, n2 = this.editor, o2 = n2.plugins.has("ImageBlockEditing"), i2 = n2.plugins.has("ImageInlineEditing");
              n2.config.define("image.styles", e3(o2, i2)), this.normalizedStyles = t3({ configuredStyles: n2.config.get("image.styles"), isBlockPluginLoaded: o2, isInlinePluginLoaded: i2 }), this._setupConversion(o2, i2), this._setupPostFixer(), n2.commands.add("imageStyle", new Kf(n2, this.normalizedStyles));
            }
            _setupConversion(t3, e3) {
              const n2 = this.editor, o2 = n2.model.schema, i2 = (r2 = this.normalizedStyles, (t4, e4, n3) => {
                if (!n3.consumable.consume(e4.item, t4.name))
                  return;
                const o3 = ck(e4.attributeNewValue, r2), i3 = ck(e4.attributeOldValue, r2), s3 = n3.mapper.toViewElement(e4.item), a2 = n3.writer;
                i3 && a2.removeClass(i3.className, s3), o3 && a2.addClass(o3.className, s3);
              });
              var r2;
              const s2 = function(t4) {
                const e4 = { imageInline: t4.filter((t5) => !t5.isDefault && t5.modelElements.includes("imageInline")), imageBlock: t4.filter((t5) => !t5.isDefault && t5.modelElements.includes("imageBlock")) };
                return (t5, n3, o3) => {
                  if (!n3.modelRange)
                    return;
                  const i3 = n3.viewItem, r3 = Aa(n3.modelRange.getItems());
                  if (r3 && o3.schema.checkAttribute(r3, "imageStyle"))
                    for (const t6 of e4[r3.name])
                      o3.consumable.consume(i3, { classes: t6.className }) && o3.writer.setAttribute("imageStyle", t6.name, r3);
                };
              }(this.normalizedStyles);
              n2.editing.downcastDispatcher.on("attribute:imageStyle", i2), n2.data.downcastDispatcher.on("attribute:imageStyle", i2), t3 && (o2.extend("imageBlock", { allowAttributes: "imageStyle" }), n2.data.upcastDispatcher.on("element:figure", s2, { priority: "low" })), e3 && (o2.extend("imageInline", { allowAttributes: "imageStyle" }), n2.data.upcastDispatcher.on("element:img", s2, { priority: "low" }));
            }
            _setupPostFixer() {
              const t3 = this.editor, e3 = t3.model.document, n2 = t3.plugins.get(Cf), o2 = new Map(this.normalizedStyles.map((t4) => [t4.name, t4]));
              e3.registerPostFixer((t4) => {
                let i2 = false;
                for (const r2 of e3.differ.getChanges())
                  if ("insert" == r2.type || "attribute" == r2.type && "imageStyle" == r2.attributeKey) {
                    let e4 = "insert" == r2.type ? r2.position.nodeAfter : r2.range.start.nodeAfter;
                    if (e4 && e4.is("element", "paragraph") && e4.childCount > 0 && (e4 = e4.getChild(0)), !n2.isImage(e4))
                      continue;
                    const s2 = e4.getAttribute("imageStyle");
                    if (!s2)
                      continue;
                    const a2 = o2.get(s2);
                    a2 && a2.modelElements.includes(e4.name) || (t4.removeAttribute("imageStyle", e4), i2 = true);
                  }
                return i2;
              });
            }
          }
          var dk = n(5083), hk = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(dk.Z, hk);
          dk.Z.locals;
          class uk extends ue {
            static get requires() {
              return [lk];
            }
            static get pluginName() {
              return "ImageStyleUI";
            }
            get localizedDefaultStylesTitles() {
              const t3 = this.editor.t;
              return { "Wrap text": t3("Wrap text"), "Break text": t3("Break text"), "In line": t3("In line"), "Full size image": t3("Full size image"), "Side image": t3("Side image"), "Left aligned image": t3("Left aligned image"), "Centered image": t3("Centered image"), "Right aligned image": t3("Right aligned image") };
            }
            init() {
              const t3 = this.editor.plugins, e3 = this.editor.config.get("image.toolbar") || [], n2 = gk(t3.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
              for (const t4 of n2)
                this._createButton(t4);
              const o2 = gk([...e3.filter(y), ...ak.getDefaultDropdownDefinitions(t3)], this.localizedDefaultStylesTitles);
              for (const t4 of o2)
                this._createDropdown(t4, n2);
            }
            _createDropdown(t3, e3) {
              const n2 = this.editor.ui.componentFactory;
              n2.add(t3.name, (o2) => {
                let i2;
                const { defaultItem: r2, items: s2, title: a2 } = t3, c2 = s2.filter((t4) => e3.find(({ name: e4 }) => mk(e4) === t4)).map((t4) => {
                  const e4 = n2.create(t4);
                  return t4 === r2 && (i2 = e4), e4;
                });
                s2.length !== c2.length && ak.warnInvalidStyle({ dropdown: t3 });
                const l2 = Jh(o2, vh), d2 = l2.buttonView;
                return Xh(l2, c2), d2.set({ label: pk(a2, i2.label), class: null, tooltip: true }), d2.bind("icon").toMany(c2, "isOn", (...t4) => {
                  const e4 = t4.findIndex(rt);
                  return e4 < 0 ? i2.icon : c2[e4].icon;
                }), d2.bind("label").toMany(c2, "isOn", (...t4) => {
                  const e4 = t4.findIndex(rt);
                  return pk(a2, e4 < 0 ? i2.label : c2[e4].label);
                }), d2.bind("isOn").toMany(c2, "isOn", (...t4) => t4.some(rt)), d2.bind("class").toMany(c2, "isOn", (...t4) => t4.some(rt) ? "ck-splitbutton_flatten" : null), d2.on("execute", () => {
                  c2.some(({ isOn: t4 }) => t4) ? l2.isOpen = !l2.isOpen : i2.fire("execute");
                }), l2.bind("isEnabled").toMany(c2, "isEnabled", (...t4) => t4.some(rt)), l2;
              });
            }
            _createButton(t3) {
              const e3 = t3.name;
              this.editor.ui.componentFactory.add(mk(e3), (n2) => {
                const o2 = this.editor.commands.get("imageStyle"), i2 = new gh(n2);
                return i2.set({ label: t3.title, icon: t3.icon, tooltip: true, isToggleable: true }), i2.bind("isEnabled").to(o2, "isEnabled"), i2.bind("isOn").to(o2, "value", (t4) => t4 === e3), i2.on("execute", this._executeCommand.bind(this, e3)), i2;
              });
            }
            _executeCommand(t3) {
              this.editor.execute("imageStyle", { value: t3 }), this.editor.editing.view.focus();
            }
          }
          function gk(t3, e3) {
            for (const n2 of t3)
              e3[n2.title] && (n2.title = e3[n2.title]);
            return t3;
          }
          function mk(t3) {
            return `imageStyle:${t3}`;
          }
          function pk(t3, e3) {
            return (t3 ? t3 + ": " : "") + e3;
          }
          function fk(t3) {
            const e3 = t3.map((t4) => t4.replace("+", "\\+"));
            return new RegExp(`^image\\/(${e3.join("|")})$`);
          }
          function kk(t3) {
            return new Promise((e3, n2) => {
              const o2 = t3.getAttribute("src");
              fetch(o2).then((t4) => t4.blob()).then((t4) => {
                const n3 = bk(t4, o2), i2 = n3.replace("image/", ""), r2 = new File([t4], `image.${i2}`, { type: n3 });
                e3(r2);
              }).catch((t4) => t4 && "TypeError" === t4.name ? function(t5) {
                return function(t6) {
                  return new Promise((e4, n3) => {
                    const o3 = is.document.createElement("img");
                    o3.addEventListener("load", () => {
                      const t7 = is.document.createElement("canvas");
                      t7.width = o3.width, t7.height = o3.height;
                      t7.getContext("2d").drawImage(o3, 0, 0), t7.toBlob((t8) => t8 ? e4(t8) : n3());
                    }), o3.addEventListener("error", () => n3()), o3.src = t6;
                  });
                }(t5).then((e4) => {
                  const n3 = bk(e4, t5), o3 = n3.replace("image/", "");
                  return new File([e4], `image.${o3}`, { type: n3 });
                });
              }(o2).then(e3).catch(n2) : n2(t4));
            });
          }
          function bk(t3, e3) {
            return t3.type ? t3.type : e3.match(/data:(image\/\w+);base64/) ? e3.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
          }
          class wk extends ue {
            static get pluginName() {
              return "ImageUploadUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.t, n2 = (n3) => {
                const o2 = new fp(n3), i2 = t3.commands.get("uploadImage"), r2 = t3.config.get("image.upload.types"), s2 = fk(r2);
                return o2.set({ acceptedType: r2.map((t4) => `image/${t4}`).join(","), allowMultipleFiles: true }), o2.buttonView.set({ label: e3("Insert image"), icon: Md.image, tooltip: true }), o2.buttonView.bind("isEnabled").to(i2), o2.on("done", (e4, n4) => {
                  const o3 = Array.from(n4).filter((t4) => s2.test(t4.type));
                  o3.length && t3.execute("uploadImage", { file: o3 });
                }), o2;
              };
              t3.ui.componentFactory.add("uploadImage", n2), t3.ui.componentFactory.add("imageUpload", n2);
            }
          }
          var Ck = n(3689), Ak = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Ck.Z, Ak);
          Ck.Z.locals;
          var _k = n(4036), vk = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(_k.Z, vk);
          _k.Z.locals;
          var yk = n(3773), xk = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(yk.Z, xk);
          yk.Z.locals;
          class Ek extends ue {
            static get pluginName() {
              return "ImageUploadProgress";
            }
            constructor(t3) {
              super(t3), this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            }
            init() {
              const t3 = this.editor;
              t3.plugins.has("ImageBlockEditing") && t3.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", (...t4) => this.uploadStatusChange(...t4)), t3.plugins.has("ImageInlineEditing") && t3.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", (...t4) => this.uploadStatusChange(...t4));
            }
            uploadStatusChange(t3, e3, n2) {
              const o2 = this.editor, i2 = e3.item, r2 = i2.getAttribute("uploadId");
              if (!n2.consumable.consume(e3.item, t3.name))
                return;
              const s2 = o2.plugins.get("ImageUtils"), a2 = o2.plugins.get(mp), c2 = r2 ? e3.attributeNewValue : null, l2 = this.placeholder, d2 = o2.editing.mapper.toViewElement(i2), h2 = n2.writer;
              if ("reading" == c2)
                return Dk(d2, h2), void Ik(s2, l2, d2, h2);
              if ("uploading" == c2) {
                const t4 = a2.loaders.get(r2);
                return Dk(d2, h2), void (t4 ? (Mk(d2, h2), function(t5, e4, n3, o3) {
                  const i3 = function(t6) {
                    const e5 = t6.createUIElement("div", { class: "ck-progress-bar" });
                    return t6.setCustomProperty("progressBar", true, e5), e5;
                  }(e4);
                  e4.insert(e4.createPositionAt(t5, "end"), i3), n3.on("change:uploadedPercent", (t6, e5, n4) => {
                    o3.change((t7) => {
                      t7.setStyle("width", n4 + "%", i3);
                    });
                  });
                }(d2, h2, t4, o2.editing.view), function(t5, e4, n3, o3) {
                  if (o3.data) {
                    const i3 = t5.findViewImgElement(e4);
                    n3.setAttribute("src", o3.data, i3);
                  }
                }(s2, d2, h2, t4)) : Ik(s2, l2, d2, h2));
              }
              "complete" == c2 && a2.loaders.get(r2) && function(t4, e4, n3) {
                const o3 = e4.createUIElement("div", { class: "ck-image-upload-complete-icon" });
                e4.insert(e4.createPositionAt(t4, "end"), o3), setTimeout(() => {
                  n3.change((t5) => t5.remove(t5.createRangeOn(o3)));
                }, 3e3);
              }(d2, h2, o2.editing.view), function(t4, e4) {
                Tk(t4, e4, "progressBar");
              }(d2, h2), Mk(d2, h2), function(t4, e4) {
                e4.removeClass("ck-appear", t4);
              }(d2, h2);
            }
          }
          function Dk(t3, e3) {
            t3.hasClass("ck-appear") || e3.addClass("ck-appear", t3);
          }
          function Ik(t3, e3, n2, o2) {
            n2.hasClass("ck-image-upload-placeholder") || o2.addClass("ck-image-upload-placeholder", n2);
            const i2 = t3.findViewImgElement(n2);
            i2.getAttribute("src") !== e3 && o2.setAttribute("src", e3, i2), Sk(n2, "placeholder") || o2.insert(o2.createPositionAfter(i2), function(t4) {
              const e4 = t4.createUIElement("div", { class: "ck-upload-placeholder-loader" });
              return t4.setCustomProperty("placeholder", true, e4), e4;
            }(o2));
          }
          function Mk(t3, e3) {
            t3.hasClass("ck-image-upload-placeholder") && e3.removeClass("ck-image-upload-placeholder", t3), Tk(t3, e3, "placeholder");
          }
          function Sk(t3, e3) {
            for (const n2 of t3.getChildren())
              if (n2.getCustomProperty(e3))
                return n2;
          }
          function Tk(t3, e3, n2) {
            const o2 = Sk(t3, n2);
            o2 && e3.remove(e3.createRangeOn(o2));
          }
          class Nk extends me {
            refresh() {
              const t3 = this.editor, e3 = t3.plugins.get("ImageUtils"), n2 = t3.model.document.selection.getSelectedElement();
              this.isEnabled = e3.isImageAllowed() || e3.isImage(n2);
            }
            execute(t3) {
              const e3 = So(t3.file), n2 = this.editor.model.document.selection, o2 = this.editor.plugins.get("ImageUtils"), i2 = Object.fromEntries(n2.getAttributes());
              e3.forEach((t4, e4) => {
                const r2 = n2.getSelectedElement();
                if (e4 && r2 && o2.isImage(r2)) {
                  const e5 = this.editor.model.createPositionAfter(r2);
                  this._uploadImage(t4, i2, e5);
                } else
                  this._uploadImage(t4, i2);
              });
            }
            _uploadImage(t3, e3, n2) {
              const o2 = this.editor, i2 = o2.plugins.get(mp).createLoader(t3), r2 = o2.plugins.get("ImageUtils");
              i2 && r2.insertImage({ ...e3, uploadId: i2.id }, n2);
            }
          }
          class Bk extends ue {
            static get requires() {
              return [mp, Cu, Cg, Cf];
            }
            static get pluginName() {
              return "ImageUploadEditing";
            }
            constructor(t3) {
              super(t3), t3.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
            }
            init() {
              const t3 = this.editor, e3 = t3.model.document, n2 = t3.conversion, o2 = t3.plugins.get(mp), i2 = t3.plugins.get("ImageUtils"), r2 = fk(t3.config.get("image.upload.types")), s2 = new Nk(t3);
              t3.commands.add("uploadImage", s2), t3.commands.add("imageUpload", s2), n2.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(t3.editing.view.document, "clipboardInput", (e4, n3) => {
                if (o3 = n3.dataTransfer, Array.from(o3.types).includes("text/html") && "" !== o3.getData("text/html"))
                  return;
                var o3;
                const i3 = Array.from(n3.dataTransfer.files).filter((t4) => !!t4 && r2.test(t4.type));
                i3.length && (e4.stop(), t3.model.change((e5) => {
                  n3.targetRanges && e5.setSelection(n3.targetRanges.map((e6) => t3.editing.mapper.toModelRange(e6))), t3.model.enqueueChange(() => {
                    t3.execute("uploadImage", { file: i3 });
                  });
                }));
              }), this.listenTo(t3.plugins.get("ClipboardPipeline"), "inputTransformation", (e4, n3) => {
                const r3 = Array.from(t3.editing.view.createRangeIn(n3.content)).filter((t4) => function(t5, e5) {
                  return !(!t5.isInlineImageView(e5) || !e5.getAttribute("src")) && (e5.getAttribute("src").match(/^data:image\/\w+;base64,/g) || e5.getAttribute("src").match(/^blob:/g));
                }(i2, t4.item) && !t4.item.getAttribute("uploadProcessed")).map((t4) => ({ promise: kk(t4.item), imageElement: t4.item }));
                if (!r3.length)
                  return;
                const s3 = new dg(t3.editing.view.document);
                for (const t4 of r3) {
                  s3.setAttribute("uploadProcessed", true, t4.imageElement);
                  const e5 = o2.createLoader(t4.promise);
                  e5 && (s3.setAttribute("src", "", t4.imageElement), s3.setAttribute("uploadId", e5.id, t4.imageElement));
                }
              }), t3.editing.view.document.on("dragover", (t4, e4) => {
                e4.preventDefault();
              }), e3.on("change", () => {
                const n3 = e3.differ.getChanges({ includeChangesInGraveyard: true }).reverse(), i3 = /* @__PURE__ */ new Set();
                for (const e4 of n3)
                  if ("insert" == e4.type && "$text" != e4.name) {
                    const n4 = e4.position.nodeAfter, r3 = "$graveyard" == e4.position.root.rootName;
                    for (const e5 of zk(t3, n4)) {
                      const t4 = e5.getAttribute("uploadId");
                      if (!t4)
                        continue;
                      const n5 = o2.loaders.get(t4);
                      n5 && (r3 ? i3.has(t4) || n5.abort() : (i3.add(t4), this._uploadImageElements.set(t4, e5), "idle" == n5.status && this._readAndUpload(n5)));
                    }
                  }
              }), this.on("uploadComplete", (t4, { imageElement: e4, data: n3 }) => {
                const o3 = n3.urls ? n3.urls : n3;
                this.editor.model.change((t5) => {
                  t5.setAttribute("src", o3.default, e4), this._parseAndSetSrcsetAttributeOnImage(o3, e4, t5);
                });
              }, { priority: "low" });
            }
            afterInit() {
              const t3 = this.editor.model.schema;
              this.editor.plugins.has("ImageBlockEditing") && t3.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && t3.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
            }
            _readAndUpload(t3) {
              const e3 = this.editor, n2 = e3.model, o2 = e3.locale.t, i2 = e3.plugins.get(mp), r2 = e3.plugins.get(Cu), s2 = e3.plugins.get("ImageUtils"), a2 = this._uploadImageElements;
              return n2.enqueueChange({ isUndoable: false }, (e4) => {
                e4.setAttribute("uploadStatus", "reading", a2.get(t3.id));
              }), t3.read().then(() => {
                const o3 = t3.upload(), i3 = a2.get(t3.id);
                if (sr.isSafari) {
                  const t4 = e3.editing.mapper.toViewElement(i3), n3 = s2.findViewImgElement(t4);
                  e3.editing.view.once("render", () => {
                    if (!n3.parent)
                      return;
                    const t5 = e3.editing.view.domConverter.mapViewToDom(n3.parent);
                    if (!t5)
                      return;
                    const o4 = t5.style.display;
                    t5.style.display = "none", t5._ckHack = t5.offsetHeight, t5.style.display = o4;
                  });
                }
                return n2.enqueueChange({ isUndoable: false }, (t4) => {
                  t4.setAttribute("uploadStatus", "uploading", i3);
                }), o3;
              }).then((e4) => {
                n2.enqueueChange({ isUndoable: false }, (n3) => {
                  const o3 = a2.get(t3.id);
                  n3.setAttribute("uploadStatus", "complete", o3), this.fire("uploadComplete", { data: e4, imageElement: o3 });
                }), c2();
              }).catch((e4) => {
                if ("error" !== t3.status && "aborted" !== t3.status)
                  throw e4;
                "error" == t3.status && e4 && r2.showWarning(e4, { title: o2("Upload failed"), namespace: "upload" }), n2.enqueueChange({ isUndoable: false }, (e5) => {
                  e5.remove(a2.get(t3.id));
                }), c2();
              });
              function c2() {
                n2.enqueueChange({ isUndoable: false }, (e4) => {
                  const n3 = a2.get(t3.id);
                  e4.removeAttribute("uploadId", n3), e4.removeAttribute("uploadStatus", n3), a2.delete(t3.id);
                }), i2.destroyLoader(t3);
              }
            }
            _parseAndSetSrcsetAttributeOnImage(t3, e3, n2) {
              let o2 = 0;
              const i2 = Object.keys(t3).filter((t4) => {
                const e4 = parseInt(t4, 10);
                if (!isNaN(e4))
                  return o2 = Math.max(o2, e4), true;
              }).map((e4) => `${t3[e4]} ${e4}w`).join(", ");
              "" != i2 && n2.setAttribute("srcset", { data: i2, width: o2 }, e3);
            }
          }
          function zk(t3, e3) {
            const n2 = t3.plugins.get("ImageUtils");
            return Array.from(t3.model.createRangeOn(e3)).filter((t4) => n2.isImage(t4.item)).map((t4) => t4.item);
          }
          class Pk extends ue {
            static get pluginName() {
              return "IndentEditing";
            }
            init() {
              const t3 = this.editor;
              t3.commands.add("indent", new fe(t3)), t3.commands.add("outdent", new fe(t3));
            }
          }
          const Lk = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', Ok = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
          class Rk extends ue {
            static get pluginName() {
              return "IndentUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.locale, n2 = t3.t, o2 = "ltr" == e3.uiLanguageDirection ? Lk : Ok, i2 = "ltr" == e3.uiLanguageDirection ? Ok : Lk;
              this._defineButton("indent", n2("Increase indent"), o2), this._defineButton("outdent", n2("Decrease indent"), i2);
            }
            _defineButton(t3, e3, n2) {
              const o2 = this.editor;
              o2.ui.componentFactory.add(t3, (i2) => {
                const r2 = o2.commands.get(t3), s2 = new gh(i2);
                return s2.set({ label: e3, icon: n2, tooltip: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), this.listenTo(s2, "execute", () => {
                  o2.execute(t3), o2.editing.view.focus();
                }), s2;
              });
            }
          }
          class jk {
            constructor() {
              this._definitions = /* @__PURE__ */ new Set();
            }
            get length() {
              return this._definitions.size;
            }
            add(t3) {
              Array.isArray(t3) ? t3.forEach((t4) => this._definitions.add(t4)) : this._definitions.add(t3);
            }
            getDispatcher() {
              return (t3) => {
                t3.on("attribute:linkHref", (t4, e3, n2) => {
                  if (!n2.consumable.test(e3.item, "attribute:linkHref"))
                    return;
                  const o2 = n2.writer, i2 = o2.document.selection;
                  for (const t5 of this._definitions) {
                    const r2 = o2.createAttributeElement("a", t5.attributes, { priority: 5 });
                    t5.classes && o2.addClass(t5.classes, r2);
                    for (const e4 in t5.styles)
                      o2.setStyle(e4, t5.styles[e4], r2);
                    o2.setCustomProperty("link", true, r2), t5.callback(e3.attributeNewValue) ? e3.item.is("selection") ? o2.wrap(i2.getFirstRange(), r2) : o2.wrap(n2.mapper.toViewRange(e3.range), r2) : o2.unwrap(n2.mapper.toViewRange(e3.range), r2);
                  }
                }, { priority: "high" });
              };
            }
            getDispatcherForLinkedImage() {
              return (t3) => {
                t3.on("attribute:linkHref:imageBlock", (t4, e3, { writer: n2, mapper: o2 }) => {
                  const i2 = o2.toViewElement(e3.item), r2 = Array.from(i2.getChildren()).find((t5) => "a" === t5.name);
                  for (const t5 of this._definitions) {
                    const o3 = Uo(t5.attributes);
                    if (t5.callback(e3.attributeNewValue)) {
                      for (const [t6, e4] of o3)
                        "class" === t6 ? n2.addClass(e4, r2) : n2.setAttribute(t6, e4, r2);
                      t5.classes && n2.addClass(t5.classes, r2);
                      for (const e4 in t5.styles)
                        n2.setStyle(e4, t5.styles[e4], r2);
                    } else {
                      for (const [t6, e4] of o3)
                        "class" === t6 ? n2.removeClass(e4, r2) : n2.removeAttribute(t6, r2);
                      t5.classes && n2.removeClass(t5.classes, r2);
                      for (const e4 in t5.styles)
                        n2.removeStyle(e4, r2);
                    }
                  }
                });
              };
            }
          }
          const Fk = function(t3, e3, n2) {
            var o2 = t3.length;
            return n2 = void 0 === n2 ? o2 : n2, !e3 && n2 >= o2 ? t3 : hi(t3, e3, n2);
          };
          var Vk = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
          const Uk = function(t3) {
            return Vk.test(t3);
          };
          const Hk = function(t3) {
            return t3.split("");
          };
          var qk = "[\\ud800-\\udfff]", Wk = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", Gk = "\\ud83c[\\udffb-\\udfff]", Yk = "[^\\ud800-\\udfff]", Qk = "(?:\\ud83c[\\udde6-\\uddff]){2}", Kk = "[\\ud800-\\udbff][\\udc00-\\udfff]", $k = "(?:" + Wk + "|" + Gk + ")?", Zk = "[\\ufe0e\\ufe0f]?", Jk = Zk + $k + ("(?:\\u200d(?:" + [Yk, Qk, Kk].join("|") + ")" + Zk + $k + ")*"), Xk = "(?:" + [Yk + Wk + "?", Wk, Qk, Kk, qk].join("|") + ")", tb = RegExp(Gk + "(?=" + Gk + ")|" + Xk + Jk, "g");
          const eb = function(t3) {
            return t3.match(tb) || [];
          };
          const nb = function(t3) {
            return Uk(t3) ? eb(t3) : Hk(t3);
          };
          const ob = function(t3) {
            return function(e3) {
              e3 = si(e3);
              var n2 = Uk(e3) ? nb(e3) : void 0, o2 = n2 ? n2[0] : e3.charAt(0), i2 = n2 ? Fk(n2, 1).join("") : e3.slice(1);
              return o2[t3]() + i2;
            };
          }("toUpperCase"), ib = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, rb = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, sb = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, ab = /^((\w+:(\/{2,})?)|(\W))/i, cb = "Ctrl+K";
          function lb(t3, { writer: e3 }) {
            const n2 = e3.createAttributeElement("a", { href: t3 }, { priority: 5 });
            return e3.setCustomProperty("link", true, n2), n2;
          }
          function db(t3) {
            return function(t4) {
              return t4.replace(ib, "").match(rb);
            }(t3 = String(t3)) ? t3 : "#";
          }
          function hb(t3, e3) {
            return !!t3 && e3.checkAttribute(t3.name, "linkHref");
          }
          function ub(t3, e3) {
            const n2 = (o2 = t3, sb.test(o2) ? "mailto:" : e3);
            var o2;
            const i2 = !!n2 && !ab.test(t3);
            return t3 && i2 ? n2 + t3 : t3;
          }
          function gb(t3) {
            window.open(t3, "_blank", "noopener");
          }
          class mb extends me {
            constructor(t3) {
              super(t3), this.manualDecorators = new Io(), this.automaticDecorators = new jk();
            }
            restoreManualDecoratorStates() {
              for (const t3 of this.manualDecorators)
                t3.value = this._getDecoratorStateFromModel(t3.id);
            }
            refresh() {
              const t3 = this.editor.model, e3 = t3.document.selection, n2 = e3.getSelectedElement() || Aa(e3.getSelectedBlocks());
              hb(n2, t3.schema) ? (this.value = n2.getAttribute("linkHref"), this.isEnabled = t3.schema.checkAttribute(n2, "linkHref")) : (this.value = e3.getAttribute("linkHref"), this.isEnabled = t3.schema.checkAttributeInSelection(e3, "linkHref"));
              for (const t4 of this.manualDecorators)
                t4.value = this._getDecoratorStateFromModel(t4.id);
            }
            execute(t3, e3 = {}) {
              const n2 = this.editor.model, o2 = n2.document.selection, i2 = [], r2 = [];
              for (const t4 in e3)
                e3[t4] ? i2.push(t4) : r2.push(t4);
              n2.change((e4) => {
                if (o2.isCollapsed) {
                  const s2 = o2.getFirstPosition();
                  if (o2.hasAttribute("linkHref")) {
                    const a2 = ep(s2, "linkHref", o2.getAttribute("linkHref"), n2);
                    e4.setAttribute("linkHref", t3, a2), i2.forEach((t4) => {
                      e4.setAttribute(t4, true, a2);
                    }), r2.forEach((t4) => {
                      e4.removeAttribute(t4, a2);
                    }), e4.setSelection(e4.createPositionAfter(a2.end.nodeBefore));
                  } else if ("" !== t3) {
                    const r3 = Uo(o2.getAttributes());
                    r3.set("linkHref", t3), i2.forEach((t4) => {
                      r3.set(t4, true);
                    });
                    const { end: a2 } = n2.insertContent(e4.createText(t3, r3), s2);
                    e4.setSelection(a2);
                  }
                  ["linkHref", ...i2, ...r2].forEach((t4) => {
                    e4.removeSelectionAttribute(t4);
                  });
                } else {
                  const s2 = n2.schema.getValidRanges(o2.getRanges(), "linkHref"), a2 = [];
                  for (const t4 of o2.getSelectedBlocks())
                    n2.schema.checkAttribute(t4, "linkHref") && a2.push(e4.createRangeOn(t4));
                  const c2 = a2.slice();
                  for (const t4 of s2)
                    this._isRangeToUpdate(t4, a2) && c2.push(t4);
                  for (const n3 of c2)
                    e4.setAttribute("linkHref", t3, n3), i2.forEach((t4) => {
                      e4.setAttribute(t4, true, n3);
                    }), r2.forEach((t4) => {
                      e4.removeAttribute(t4, n3);
                    });
                }
              });
            }
            _getDecoratorStateFromModel(t3) {
              const e3 = this.editor.model, n2 = e3.document.selection, o2 = n2.getSelectedElement();
              return hb(o2, e3.schema) ? o2.getAttribute(t3) : n2.getAttribute(t3);
            }
            _isRangeToUpdate(t3, e3) {
              for (const n2 of e3)
                if (n2.containsRange(t3))
                  return false;
              return true;
            }
          }
          class pb extends me {
            refresh() {
              const t3 = this.editor.model, e3 = t3.document.selection, n2 = e3.getSelectedElement();
              hb(n2, t3.schema) ? this.isEnabled = t3.schema.checkAttribute(n2, "linkHref") : this.isEnabled = t3.schema.checkAttributeInSelection(e3, "linkHref");
            }
            execute() {
              const t3 = this.editor, e3 = this.editor.model, n2 = e3.document.selection, o2 = t3.commands.get("link");
              e3.change((t4) => {
                const i2 = n2.isCollapsed ? [ep(n2.getFirstPosition(), "linkHref", n2.getAttribute("linkHref"), e3)] : e3.schema.getValidRanges(n2.getRanges(), "linkHref");
                for (const e4 of i2)
                  if (t4.removeAttribute("linkHref", e4), o2)
                    for (const n3 of o2.manualDecorators)
                      t4.removeAttribute(n3.id, e4);
              });
            }
          }
          class fb {
            constructor({ id: t3, label: e3, attributes: n2, classes: o2, styles: i2, defaultValue: r2 }) {
              this.id = t3, this.set("value"), this.defaultValue = r2, this.label = e3, this.attributes = n2, this.classes = o2, this.styles = i2;
            }
            _createPattern() {
              return { attributes: this.attributes, classes: this.classes, styles: this.styles };
            }
          }
          he(fb, re);
          var kb = n(9773), bb = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(kb.Z, bb);
          kb.Z.locals;
          const wb = "automatic", Cb = /^(https?:)?\/\//;
          class Ab extends ue {
            static get pluginName() {
              return "LinkEditing";
            }
            static get requires() {
              return [Fm, Lm, Cg];
            }
            constructor(t3) {
              super(t3), t3.config.define("link", { addTargetToExternalLinks: false });
            }
            init() {
              const t3 = this.editor;
              t3.model.schema.extend("$text", { allowAttributes: "linkHref" }), t3.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: lb }), t3.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (t4, e4) => lb(db(t4), e4) }), t3.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: (t4) => t4.getAttribute("href") } }), t3.commands.add("link", new mb(t3)), t3.commands.add("unlink", new pb(t3));
              const e3 = function(t4, e4) {
                const n2 = { "Open in a new tab": t4("Open in a new tab"), Downloadable: t4("Downloadable") };
                return e4.forEach((t5) => (t5.label && n2[t5.label] && (t5.label = n2[t5.label]), t5)), e4;
              }(t3.t, function(t4) {
                const e4 = [];
                if (t4)
                  for (const [n2, o2] of Object.entries(t4)) {
                    const t5 = Object.assign({}, o2, { id: `link${ob(n2)}` });
                    e4.push(t5);
                  }
                return e4;
              }(t3.config.get("link.decorators")));
              this._enableAutomaticDecorators(e3.filter((t4) => t4.mode === wb)), this._enableManualDecorators(e3.filter((t4) => "manual" === t4.mode));
              t3.plugins.get(Fm).registerAttribute("linkHref"), function(t4, e4, n2, o2) {
                const i2 = t4.editing.view, r2 = /* @__PURE__ */ new Set();
                i2.document.registerPostFixer((i3) => {
                  const s2 = t4.model.document.selection;
                  let a2 = false;
                  if (s2.hasAttribute(e4)) {
                    const c2 = ep(s2.getFirstPosition(), e4, s2.getAttribute(e4), t4.model), l2 = t4.editing.mapper.toViewRange(c2);
                    for (const t5 of l2.getItems())
                      t5.is("element", n2) && !t5.hasClass(o2) && (i3.addClass(o2, t5), r2.add(t5), a2 = true);
                  }
                  return a2;
                }), t4.conversion.for("editingDowncast").add((t5) => {
                  function e5() {
                    i2.change((t6) => {
                      for (const e6 of r2.values())
                        t6.removeClass(o2, e6), r2.delete(e6);
                    });
                  }
                  t5.on("insert", e5, { priority: "highest" }), t5.on("remove", e5, { priority: "highest" }), t5.on("attribute", e5, { priority: "highest" }), t5.on("selection", e5, { priority: "highest" });
                });
              }(t3, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink();
            }
            _enableAutomaticDecorators(t3) {
              const e3 = this.editor, n2 = e3.commands.get("link").automaticDecorators;
              e3.config.get("link.addTargetToExternalLinks") && n2.add({ id: "linkIsExternal", mode: wb, callback: (t4) => Cb.test(t4), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n2.add(t3), n2.length && e3.conversion.for("downcast").add(n2.getDispatcher());
            }
            _enableManualDecorators(t3) {
              if (!t3.length)
                return;
              const e3 = this.editor, n2 = e3.commands.get("link").manualDecorators;
              t3.forEach((t4) => {
                e3.model.schema.extend("$text", { allowAttributes: t4.id }), t4 = new fb(t4), n2.add(t4), e3.conversion.for("downcast").attributeToElement({ model: t4.id, view: (e4, { writer: n3 }) => {
                  if (e4) {
                    const e5 = n3.createAttributeElement("a", t4.attributes, { priority: 5 });
                    t4.classes && n3.addClass(t4.classes, e5);
                    for (const o2 in t4.styles)
                      n3.setStyle(o2, t4.styles[o2], e5);
                    return n3.setCustomProperty("link", true, e5), e5;
                  }
                } }), e3.conversion.for("upcast").elementToAttribute({ view: { name: "a", ...t4._createPattern() }, model: { key: t4.id } });
              });
            }
            _enableLinkOpen() {
              const t3 = this.editor, e3 = t3.editing.view.document, n2 = t3.model.document;
              this.listenTo(e3, "click", (t4, e4) => {
                if (!(sr.isMac ? e4.domEvent.metaKey : e4.domEvent.ctrlKey))
                  return;
                let n3 = e4.domTarget;
                if ("a" != n3.tagName.toLowerCase() && (n3 = n3.closest("a")), !n3)
                  return;
                const o2 = n3.getAttribute("href");
                o2 && (t4.stop(), e4.preventDefault(), gb(o2));
              }, { context: "$capture" }), this.listenTo(e3, "enter", (t4, e4) => {
                const o2 = n2.selection, i2 = o2.getSelectedElement(), r2 = i2 ? i2.getAttribute("linkHref") : o2.getAttribute("linkHref");
                r2 && e4.domEvent.altKey && (t4.stop(), gb(r2));
              }, { context: "a" });
            }
            _enableInsertContentSelectionAttributesFixer() {
              const t3 = this.editor.model, e3 = t3.document.selection;
              this.listenTo(t3, "insertContent", () => {
                const n2 = e3.anchor.nodeBefore, o2 = e3.anchor.nodeAfter;
                e3.hasAttribute("linkHref") && n2 && n2.hasAttribute("linkHref") && (o2 && o2.hasAttribute("linkHref") || t3.change((e4) => {
                  _b(e4, yb(t3.schema));
                }));
              }, { priority: "low" });
            }
            _enableClickingAfterLink() {
              const t3 = this.editor, e3 = t3.model;
              t3.editing.view.addObserver(lg);
              let n2 = false;
              this.listenTo(t3.editing.view.document, "mousedown", () => {
                n2 = true;
              }), this.listenTo(t3.editing.view.document, "selectionChange", () => {
                if (!n2)
                  return;
                n2 = false;
                const t4 = e3.document.selection;
                if (!t4.isCollapsed)
                  return;
                if (!t4.hasAttribute("linkHref"))
                  return;
                const o2 = t4.getFirstPosition(), i2 = ep(o2, "linkHref", t4.getAttribute("linkHref"), e3);
                (o2.isTouching(i2.start) || o2.isTouching(i2.end)) && e3.change((t5) => {
                  _b(t5, yb(e3.schema));
                });
              });
            }
            _enableTypingOverLink() {
              const t3 = this.editor, e3 = t3.editing.view;
              let n2, o2;
              this.listenTo(e3.document, "delete", () => {
                o2 = true;
              }, { priority: "high" }), this.listenTo(t3.model, "deleteContent", () => {
                const e4 = t3.model.document.selection;
                e4.isCollapsed || (o2 ? o2 = false : vb(t3) && function(t4) {
                  const e5 = t4.document.selection, n3 = e5.getFirstPosition(), o3 = e5.getLastPosition(), i2 = n3.nodeAfter;
                  if (!i2)
                    return false;
                  if (!i2.is("$text"))
                    return false;
                  if (!i2.hasAttribute("linkHref"))
                    return false;
                  const r2 = o3.textNode || o3.nodeBefore;
                  if (i2 === r2)
                    return true;
                  return ep(n3, "linkHref", i2.getAttribute("linkHref"), t4).containsRange(t4.createRange(n3, o3), true);
                }(t3.model) && (n2 = e4.getAttributes()));
              }, { priority: "high" }), this.listenTo(t3.model, "insertContent", (e4, [i2]) => {
                o2 = false, vb(t3) && n2 && (t3.model.change((t4) => {
                  for (const [e5, o3] of n2)
                    t4.setAttribute(e5, o3, i2);
                }), n2 = null);
              }, { priority: "high" });
            }
            _handleDeleteContentAfterLink() {
              const t3 = this.editor, e3 = t3.model, n2 = e3.document.selection, o2 = t3.editing.view;
              let i2 = false, r2 = false;
              this.listenTo(o2.document, "delete", (t4, e4) => {
                r2 = e4.domEvent.keyCode === dr.backspace;
              }, { priority: "high" }), this.listenTo(e3, "deleteContent", () => {
                i2 = false;
                const t4 = n2.getFirstPosition(), o3 = n2.getAttribute("linkHref");
                if (!o3)
                  return;
                const r3 = ep(t4, "linkHref", o3, e3);
                i2 = r3.containsPosition(t4) || r3.end.isEqual(t4);
              }, { priority: "high" }), this.listenTo(e3, "deleteContent", () => {
                r2 && (r2 = false, i2 || t3.model.enqueueChange((t4) => {
                  _b(t4, yb(e3.schema));
                }));
              }, { priority: "low" });
            }
          }
          function _b(t3, e3) {
            t3.removeSelectionAttribute("linkHref");
            for (const n2 of e3)
              t3.removeSelectionAttribute(n2);
          }
          function vb(t3) {
            return t3.model.change((t4) => t4.batch).isTyping;
          }
          function yb(t3) {
            return t3.getDefinition("$text").allowAttributes.filter((t4) => t4.startsWith("link"));
          }
          var xb = n(7754), Eb = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(xb.Z, Eb);
          xb.Z.locals;
          class Db extends Ld {
            constructor(t3, e3) {
              super(t3);
              const n2 = t3.t;
              this.focusTracker = new _a(), this.keystrokes = new va(), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n2("Save"), Md.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n2("Cancel"), Md.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e3), this.children = this._createFormChildren(e3.manualDecorators), this._focusables = new Bd(), this._focusCycler = new Nh({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
              const o2 = ["ck", "ck-link-form", "ck-responsive-form"];
              e3.manualDecorators.length && o2.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: o2, tabindex: "-1" }, children: this.children }), Td(this);
            }
            getDecoratorSwitchesState() {
              return Array.from(this._manualDecoratorSwitches).reduce((t3, e3) => (t3[e3.name] = e3.isOn, t3), {});
            }
            render() {
              super.render(), Nd({ view: this });
              [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((t3) => {
                this._focusables.add(t3), this.focusTracker.add(t3.element);
              }), this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            _createUrlInput() {
              const t3 = this.locale.t, e3 = new bu(this.locale, wu);
              return e3.label = t3("Link URL"), e3;
            }
            _createButton(t3, e3, n2, o2) {
              const i2 = new gh(this.locale);
              return i2.set({ label: t3, icon: e3, tooltip: true }), i2.extendTemplate({ attributes: { class: n2 } }), o2 && i2.delegate("execute").to(this, o2), i2;
            }
            _createManualDecoratorSwitches(t3) {
              const e3 = this.createCollection();
              for (const n2 of t3.manualDecorators) {
                const o2 = new fh(this.locale);
                o2.set({ name: n2.id, label: n2.label, withText: true }), o2.bind("isOn").toMany([n2, t3], "value", (t4, e4) => void 0 === e4 && void 0 === t4 ? n2.defaultValue : t4), o2.on("execute", () => {
                  n2.set("value", !o2.isOn);
                }), e3.add(o2);
              }
              return e3;
            }
            _createFormChildren(t3) {
              const e3 = this.createCollection();
              if (e3.add(this.urlInputView), t3.length) {
                const t4 = new Ld();
                t4.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((t5) => ({ tag: "li", children: [t5], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), e3.add(t4);
              }
              return e3.add(this.saveButtonView), e3.add(this.cancelButtonView), e3;
            }
          }
          var Ib = n(2347), Mb = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Ib.Z, Mb);
          Ib.Z.locals;
          class Sb extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = t3.t;
              this.focusTracker = new _a(), this.keystrokes = new va(), this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(e3("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(e3("Edit link"), Md.pencil, "edit"), this.set("href"), this._focusables = new Bd(), this._focusCycler = new Nh({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
            }
            render() {
              super.render();
              [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((t3) => {
                this._focusables.add(t3), this.focusTracker.add(t3.element);
              }), this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            _createButton(t3, e3, n2) {
              const o2 = new gh(this.locale);
              return o2.set({ label: t3, icon: e3, tooltip: true }), o2.delegate("execute").to(this, n2), o2;
            }
            _createPreviewButton() {
              const t3 = new gh(this.locale), e3 = this.bindTemplate, n2 = this.t;
              return t3.set({ withText: true, tooltip: n2("Open link in new tab") }), t3.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: e3.to("href", (t4) => t4 && db(t4)), target: "_blank", rel: "noopener noreferrer" } }), t3.bind("label").to(this, "href", (t4) => t4 || n2("This link has no URL")), t3.bind("isEnabled").to(this, "href", (t4) => !!t4), t3.template.tag = "a", t3.template.eventListeners = {}, t3;
            }
          }
          const Tb = "link-ui";
          class Nb extends ue {
            static get requires() {
              return [zu];
            }
            static get pluginName() {
              return "LinkUI";
            }
            init() {
              const t3 = this.editor;
              t3.editing.view.addObserver(cg), this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._balloon = t3.plugins.get(zu), this._createToolbarLinkButton(), this._enableUserBalloonInteractions(), t3.conversion.for("editingDowncast").markerToHighlight({ model: Tb, view: { classes: ["ck-fake-link-selection"] } }), t3.conversion.for("editingDowncast").markerToElement({ model: Tb, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
            }
            destroy() {
              super.destroy(), this.formView.destroy();
            }
            _createActionsView() {
              const t3 = this.editor, e3 = new Sb(t3.locale), n2 = t3.commands.get("link"), o2 = t3.commands.get("unlink");
              return e3.bind("href").to(n2, "value"), e3.editButtonView.bind("isEnabled").to(n2), e3.unlinkButtonView.bind("isEnabled").to(o2), this.listenTo(e3, "edit", () => {
                this._addFormView();
              }), this.listenTo(e3, "unlink", () => {
                t3.execute("unlink"), this._hideUI();
              }), e3.keystrokes.set("Esc", (t4, e4) => {
                this._hideUI(), e4();
              }), e3.keystrokes.set(cb, (t4, e4) => {
                this._addFormView(), e4();
              }), e3;
            }
            _createFormView() {
              const t3 = this.editor, e3 = t3.commands.get("link"), n2 = t3.config.get("link.defaultProtocol"), o2 = new Db(t3.locale, e3);
              return o2.urlInputView.fieldView.bind("value").to(e3, "value"), o2.urlInputView.bind("isReadOnly").to(e3, "isEnabled", (t4) => !t4), o2.saveButtonView.bind("isEnabled").to(e3), this.listenTo(o2, "submit", () => {
                const { value: e4 } = o2.urlInputView.fieldView.element, i2 = ub(e4, n2);
                t3.execute("link", i2, o2.getDecoratorSwitchesState()), this._closeFormView();
              }), this.listenTo(o2, "cancel", () => {
                this._closeFormView();
              }), o2.keystrokes.set("Esc", (t4, e4) => {
                this._closeFormView(), e4();
              }), o2;
            }
            _createToolbarLinkButton() {
              const t3 = this.editor, e3 = t3.commands.get("link"), n2 = t3.t;
              t3.keystrokes.set(cb, (t4, n3) => {
                n3(), e3.isEnabled && this._showUI(true);
              }), t3.ui.componentFactory.add("link", (t4) => {
                const o2 = new gh(t4);
                return o2.isEnabled = true, o2.label = n2("Link"), o2.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', o2.keystroke = cb, o2.tooltip = true, o2.isToggleable = true, o2.bind("isEnabled").to(e3, "isEnabled"), o2.bind("isOn").to(e3, "value", (t5) => !!t5), this.listenTo(o2, "execute", () => this._showUI(true)), o2;
              });
            }
            _enableUserBalloonInteractions() {
              const t3 = this.editor.editing.view.document;
              this.listenTo(t3, "click", () => {
                this._getSelectedLinkElement() && this._showUI();
              }), this.editor.keystrokes.set("Tab", (t4, e3) => {
                this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), e3());
              }, { priority: "high" }), this.editor.keystrokes.set("Esc", (t4, e3) => {
                this._isUIVisible && (this._hideUI(), e3());
              }), Sd({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: [this._balloon.view.element], callback: () => this._hideUI() });
            }
            _addActionsView() {
              this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
            }
            _addFormView() {
              if (this._isFormInPanel)
                return;
              const t3 = this.editor.commands.get("link");
              this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = t3.value || "";
            }
            _closeFormView() {
              const t3 = this.editor.commands.get("link");
              t3.restoreManualDecoratorStates(), void 0 !== t3.value ? this._removeFormView() : this._hideUI();
            }
            _removeFormView() {
              this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
            }
            _showUI(t3 = false) {
              this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), t3 && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), t3 && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
            }
            _hideUI() {
              if (!this._isUIInPanel)
                return;
              const t3 = this.editor;
              this.stopListening(t3.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t3.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
            }
            _startUpdatingUI() {
              const t3 = this.editor, e3 = t3.editing.view.document;
              let n2 = this._getSelectedLinkElement(), o2 = r2();
              const i2 = () => {
                const t4 = this._getSelectedLinkElement(), e4 = r2();
                n2 && !t4 || !n2 && e4 !== o2 ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n2 = t4, o2 = e4;
              };
              function r2() {
                return e3.selection.focus.getAncestors().reverse().find((t4) => t4.is("element"));
              }
              this.listenTo(t3.ui, "update", i2), this.listenTo(this._balloon, "change:visibleView", i2);
            }
            get _isFormInPanel() {
              return this._balloon.hasView(this.formView);
            }
            get _areActionsInPanel() {
              return this._balloon.hasView(this.actionsView);
            }
            get _areActionsVisible() {
              return this._balloon.visibleView === this.actionsView;
            }
            get _isUIInPanel() {
              return this._isFormInPanel || this._areActionsInPanel;
            }
            get _isUIVisible() {
              return this._balloon.visibleView == this.formView || this._areActionsVisible;
            }
            _getBalloonPositionData() {
              const t3 = this.editor.editing.view, e3 = this.editor.model, n2 = t3.document;
              let o2 = null;
              if (e3.markers.has(Tb)) {
                const e4 = Array.from(this.editor.editing.mapper.markerNameToElements(Tb)), n3 = t3.createRange(t3.createPositionBefore(e4[0]), t3.createPositionAfter(e4[e4.length - 1]));
                o2 = t3.domConverter.viewRangeToDom(n3);
              } else
                o2 = () => {
                  const e4 = this._getSelectedLinkElement();
                  return e4 ? t3.domConverter.mapViewToDom(e4) : t3.domConverter.viewRangeToDom(n2.selection.getFirstRange());
                };
              return { target: o2 };
            }
            _getSelectedLinkElement() {
              const t3 = this.editor.editing.view, e3 = t3.document.selection, n2 = e3.getSelectedElement();
              if (e3.isCollapsed || n2 && jg(n2))
                return Bb(e3.getFirstPosition());
              {
                const n3 = e3.getFirstRange().getTrimmed(), o2 = Bb(n3.start), i2 = Bb(n3.end);
                return o2 && o2 == i2 && t3.createRangeIn(o2).getTrimmed().isEqual(n3) ? o2 : null;
              }
            }
            _showFakeVisualSelection() {
              const t3 = this.editor.model;
              t3.change((e3) => {
                const n2 = t3.document.selection.getFirstRange();
                if (t3.markers.has(Tb))
                  e3.updateMarker(Tb, { range: n2 });
                else if (n2.start.isAtEnd) {
                  const o2 = n2.start.getLastMatchingPosition(({ item: e4 }) => !t3.schema.isContent(e4), { boundaries: n2 });
                  e3.addMarker(Tb, { usingOperation: false, affectsData: false, range: e3.createRange(o2, n2.end) });
                } else
                  e3.addMarker(Tb, { usingOperation: false, affectsData: false, range: n2 });
              });
            }
            _hideFakeVisualSelection() {
              const t3 = this.editor.model;
              t3.markers.has(Tb) && t3.change((t4) => {
                t4.removeMarker(Tb);
              });
            }
          }
          function Bb(t3) {
            return t3.getAncestors().find((t4) => {
              return (e3 = t4).is("attributeElement") && !!e3.getCustomProperty("link");
              var e3;
            });
          }
          const zb = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
          class Pb extends ue {
            static get requires() {
              return [Ng];
            }
            static get pluginName() {
              return "AutoLink";
            }
            init() {
              const t3 = this.editor.model.document.selection;
              t3.on("change:range", () => {
                this.isEnabled = !t3.anchor.parent.is("element", "codeBlock");
              }), this._enableTypingHandling();
            }
            afterInit() {
              this._enableEnterHandling(), this._enableShiftEnterHandling();
            }
            _enableTypingHandling() {
              const t3 = this.editor, e3 = new jm(t3.model, (t4) => {
                if (!function(t5) {
                  return t5.length > 4 && " " === t5[t5.length - 1] && " " !== t5[t5.length - 2];
                }(t4))
                  return;
                const e4 = Lb(t4.substr(0, t4.length - 1));
                return e4 ? { url: e4 } : void 0;
              });
              e3.on("matched:data", (e4, n2) => {
                const { batch: o2, range: i2, url: r2 } = n2;
                if (!o2.isTyping)
                  return;
                const s2 = i2.end.getShiftedBy(-1), a2 = s2.getShiftedBy(-r2.length), c2 = t3.model.createRange(a2, s2);
                this._applyAutoLink(r2, c2);
              }), e3.bind("isEnabled").to(this);
            }
            _enableEnterHandling() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.commands.get("enter");
              n2 && n2.on("execute", () => {
                const t4 = e3.document.selection.getFirstPosition();
                if (!t4.parent.previousSibling)
                  return;
                const n3 = e3.createRangeIn(t4.parent.previousSibling);
                this._checkAndApplyAutoLinkOnRange(n3);
              });
            }
            _enableShiftEnterHandling() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.commands.get("shiftEnter");
              n2 && n2.on("execute", () => {
                const t4 = e3.document.selection.getFirstPosition(), n3 = e3.createRange(e3.createPositionAt(t4.parent, 0), t4.getShiftedBy(-1));
                this._checkAndApplyAutoLinkOnRange(n3);
              });
            }
            _checkAndApplyAutoLinkOnRange(t3) {
              const e3 = this.editor.model, { text: n2, range: o2 } = Rm(t3, e3), i2 = Lb(n2);
              if (i2) {
                const t4 = e3.createRange(o2.end.getShiftedBy(-i2.length), o2.end);
                this._applyAutoLink(i2, t4);
              }
            }
            _applyAutoLink(t3, e3) {
              const n2 = this.editor.model, o2 = this.editor.plugins.get("Delete");
              this.isEnabled && function(t4, e4) {
                return e4.schema.checkAttributeInSelection(e4.createSelection(t4), "linkHref");
              }(e3, n2) && n2.enqueueChange((i2) => {
                const r2 = this.editor.config.get("link.defaultProtocol"), s2 = ub(t3, r2);
                i2.setAttribute("linkHref", s2, e3), n2.enqueueChange(() => {
                  o2.requestUndoOnBackspace();
                });
              });
            }
          }
          function Lb(t3) {
            const e3 = zb.exec(t3);
            return e3 ? e3[2] : null;
          }
          class Ob extends me {
            constructor(t3, e3) {
              super(t3), this.type = e3;
            }
            refresh() {
              this.value = this._getValue(), this.isEnabled = this._checkEnabled();
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.document, o2 = Array.from(n2.selection.getSelectedBlocks()).filter((t4) => jb(t4, e3.schema)), i2 = void 0 !== t3.forceValue ? !t3.forceValue : this.value;
              e3.change((t4) => {
                if (i2) {
                  let e4 = o2[o2.length - 1].nextSibling, n3 = Number.POSITIVE_INFINITY, i3 = [];
                  for (; e4 && "listItem" == e4.name && 0 !== e4.getAttribute("listIndent"); ) {
                    const t5 = e4.getAttribute("listIndent");
                    t5 < n3 && (n3 = t5);
                    const o3 = t5 - n3;
                    i3.push({ element: e4, listIndent: o3 }), e4 = e4.nextSibling;
                  }
                  i3 = i3.reverse();
                  for (const e5 of i3)
                    t4.setAttribute("listIndent", e5.listIndent, e5.element);
                }
                if (!i2) {
                  let t5 = Number.POSITIVE_INFINITY;
                  for (const e4 of o2)
                    e4.is("element", "listItem") && e4.getAttribute("listIndent") < t5 && (t5 = e4.getAttribute("listIndent"));
                  t5 = 0 === t5 ? 1 : t5, Rb(o2, true, t5), Rb(o2, false, t5);
                }
                for (const e4 of o2.reverse())
                  i2 && "listItem" == e4.name ? t4.rename(e4, "paragraph") : i2 || "listItem" == e4.name ? i2 || "listItem" != e4.name || e4.getAttribute("listType") == this.type || t4.setAttribute("listType", this.type, e4) : (t4.setAttributes({ listType: this.type, listIndent: 0 }, e4), t4.rename(e4, "listItem"));
                this.fire("_executeCleanup", o2);
              });
            }
            _getValue() {
              const t3 = Aa(this.editor.model.document.selection.getSelectedBlocks());
              return !!t3 && t3.is("element", "listItem") && t3.getAttribute("listType") == this.type;
            }
            _checkEnabled() {
              if (this.value)
                return true;
              const t3 = this.editor.model.document.selection, e3 = this.editor.model.schema, n2 = Aa(t3.getSelectedBlocks());
              return !!n2 && jb(n2, e3);
            }
          }
          function Rb(t3, e3, n2) {
            const o2 = e3 ? t3[0] : t3[t3.length - 1];
            if (o2.is("element", "listItem")) {
              let i2 = o2[e3 ? "previousSibling" : "nextSibling"], r2 = o2.getAttribute("listIndent");
              for (; i2 && i2.is("element", "listItem") && i2.getAttribute("listIndent") >= n2; )
                r2 > i2.getAttribute("listIndent") && (r2 = i2.getAttribute("listIndent")), i2.getAttribute("listIndent") == r2 && t3[e3 ? "unshift" : "push"](i2), i2 = i2[e3 ? "previousSibling" : "nextSibling"];
            }
          }
          function jb(t3, e3) {
            return e3.checkChild(t3.parent, "listItem") && !e3.isObject(t3);
          }
          class Fb extends me {
            constructor(t3, e3) {
              super(t3), this._indentBy = "forward" == e3 ? 1 : -1;
            }
            refresh() {
              this.isEnabled = this._checkEnabled();
            }
            execute() {
              const t3 = this.editor.model, e3 = t3.document;
              let n2 = Array.from(e3.selection.getSelectedBlocks());
              t3.change((t4) => {
                const e4 = n2[n2.length - 1];
                let o2 = e4.nextSibling;
                for (; o2 && "listItem" == o2.name && o2.getAttribute("listIndent") > e4.getAttribute("listIndent"); )
                  n2.push(o2), o2 = o2.nextSibling;
                this._indentBy < 0 && (n2 = n2.reverse());
                for (const e5 of n2) {
                  const n3 = e5.getAttribute("listIndent") + this._indentBy;
                  n3 < 0 ? t4.rename(e5, "paragraph") : t4.setAttribute("listIndent", n3, e5);
                }
                this.fire("_executeCleanup", n2);
              });
            }
            _checkEnabled() {
              const t3 = Aa(this.editor.model.document.selection.getSelectedBlocks());
              if (!t3 || !t3.is("element", "listItem"))
                return false;
              if (this._indentBy > 0) {
                const e3 = t3.getAttribute("listIndent"), n2 = t3.getAttribute("listType");
                let o2 = t3.previousSibling;
                for (; o2 && o2.is("element", "listItem") && o2.getAttribute("listIndent") >= e3; ) {
                  if (o2.getAttribute("listIndent") == e3)
                    return o2.getAttribute("listType") == n2;
                  o2 = o2.previousSibling;
                }
                return false;
              }
              return true;
            }
          }
          function Vb(t3, e3) {
            const n2 = e3.mapper, o2 = e3.writer, i2 = "numbered" == t3.getAttribute("listType") ? "ol" : "ul", r2 = function(t4) {
              const e4 = t4.createContainerElement("li");
              return e4.getFillerOffset = Yb, e4;
            }(o2), s2 = o2.createContainerElement(i2, null);
            return o2.insert(o2.createPositionAt(s2, 0), r2), n2.bindElements(t3, r2), r2;
          }
          function Ub(t3, e3, n2, o2) {
            const i2 = e3.parent, r2 = n2.mapper, s2 = n2.writer;
            let a2 = r2.toViewPosition(o2.createPositionBefore(t3));
            const c2 = Wb(t3.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: t3.getAttribute("listIndent") }), l2 = t3.previousSibling;
            if (c2 && c2.getAttribute("listIndent") == t3.getAttribute("listIndent")) {
              const t4 = r2.toViewElement(c2);
              a2 = s2.breakContainer(s2.createPositionAfter(t4));
            } else if (l2 && "listItem" == l2.name) {
              a2 = r2.toViewPosition(o2.createPositionAt(l2, "end"));
              const t4 = r2.findMappedViewAncestor(a2), e4 = function(t5) {
                for (const e5 of t5.getChildren())
                  if ("ul" == e5.name || "ol" == e5.name)
                    return e5;
                return null;
              }(t4);
              a2 = e4 ? s2.createPositionBefore(e4) : s2.createPositionAt(t4, "end");
            } else
              a2 = r2.toViewPosition(o2.createPositionBefore(t3));
            if (a2 = qb(a2), s2.insert(a2, i2), l2 && "listItem" == l2.name) {
              const t4 = r2.toViewElement(l2), n3 = s2.createRange(s2.createPositionAt(t4, 0), a2).getWalker({ ignoreElementEnd: true });
              for (const t5 of n3)
                if (t5.item.is("element", "li")) {
                  const o3 = s2.breakContainer(s2.createPositionBefore(t5.item)), i3 = t5.item.parent, r3 = s2.createPositionAt(e3, "end");
                  Hb(s2, r3.nodeBefore, r3.nodeAfter), s2.move(s2.createRangeOn(i3), r3), n3.position = o3;
                }
            } else {
              const n3 = i2.nextSibling;
              if (n3 && (n3.is("element", "ul") || n3.is("element", "ol"))) {
                let o3 = null;
                for (const e4 of n3.getChildren()) {
                  const n4 = r2.toModelElement(e4);
                  if (!(n4 && n4.getAttribute("listIndent") > t3.getAttribute("listIndent")))
                    break;
                  o3 = e4;
                }
                o3 && (s2.breakContainer(s2.createPositionAfter(o3)), s2.move(s2.createRangeOn(o3.parent), s2.createPositionAt(e3, "end")));
              }
            }
            Hb(s2, i2, i2.nextSibling), Hb(s2, i2.previousSibling, i2);
          }
          function Hb(t3, e3, n2) {
            return !e3 || !n2 || "ul" != e3.name && "ol" != e3.name || e3.name != n2.name || e3.getAttribute("class") !== n2.getAttribute("class") ? null : t3.mergeContainers(t3.createPositionAfter(e3));
          }
          function qb(t3) {
            return t3.getLastMatchingPosition((t4) => t4.item.is("uiElement"));
          }
          function Wb(t3, e3) {
            const n2 = !!e3.sameIndent, o2 = !!e3.smallerIndent, i2 = e3.listIndent;
            let r2 = t3;
            for (; r2 && "listItem" == r2.name; ) {
              const t4 = r2.getAttribute("listIndent");
              if (n2 && i2 == t4 || o2 && i2 > t4)
                return r2;
              r2 = "forward" === e3.direction ? r2.nextSibling : r2.previousSibling;
            }
            return null;
          }
          function Gb(t3, e3, n2, o2) {
            t3.ui.componentFactory.add(e3, (i2) => {
              const r2 = t3.commands.get(e3), s2 = new gh(i2);
              return s2.set({ label: n2, icon: o2, tooltip: true, isToggleable: true }), s2.bind("isOn", "isEnabled").to(r2, "value", "isEnabled"), s2.on("execute", () => {
                t3.execute(e3), t3.editing.view.focus();
              }), s2;
            });
          }
          function Yb() {
            const t3 = !this.isEmpty && ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
            return this.isEmpty || t3 ? 0 : Bi.call(this);
          }
          function Qb(t3) {
            return (e3, n2, o2) => {
              const i2 = o2.consumable;
              if (!i2.test(n2.item, "insert") || !i2.test(n2.item, "attribute:listType") || !i2.test(n2.item, "attribute:listIndent"))
                return;
              i2.consume(n2.item, "insert"), i2.consume(n2.item, "attribute:listType"), i2.consume(n2.item, "attribute:listIndent");
              const r2 = n2.item;
              Ub(r2, Vb(r2, o2), o2, t3);
            };
          }
          function Kb(t3, e3, n2) {
            if (!n2.consumable.test(e3.item, t3.name))
              return;
            const o2 = n2.mapper.toViewElement(e3.item), i2 = n2.writer;
            i2.breakContainer(i2.createPositionBefore(o2)), i2.breakContainer(i2.createPositionAfter(o2));
            const r2 = o2.parent, s2 = "numbered" == e3.attributeNewValue ? "ol" : "ul";
            i2.rename(s2, r2);
          }
          function $b(t3, e3, n2) {
            n2.consumable.consume(e3.item, t3.name);
            const o2 = n2.mapper.toViewElement(e3.item).parent, i2 = n2.writer;
            Hb(i2, o2, o2.nextSibling), Hb(i2, o2.previousSibling, o2);
          }
          function Zb(t3, e3, n2) {
            if ("listItem" != e3.item.name) {
              let t4 = n2.mapper.toViewPosition(e3.range.start);
              const o2 = n2.writer, i2 = [];
              for (; ("ul" == t4.parent.name || "ol" == t4.parent.name) && (t4 = o2.breakContainer(t4), "li" == t4.parent.name); ) {
                const e4 = t4, n3 = o2.createPositionAt(t4.parent, "end");
                if (!e4.isEqual(n3)) {
                  const t5 = o2.remove(o2.createRange(e4, n3));
                  i2.push(t5);
                }
                t4 = o2.createPositionAfter(t4.parent);
              }
              if (i2.length > 0) {
                for (let e4 = 0; e4 < i2.length; e4++) {
                  const n3 = t4.nodeBefore;
                  if (t4 = o2.insert(t4, i2[e4]).end, e4 > 0) {
                    const e5 = Hb(o2, n3, n3.nextSibling);
                    e5 && e5.parent == n3 && t4.offset--;
                  }
                }
                Hb(o2, t4.nodeBefore, t4.nodeAfter);
              }
            }
          }
          function Jb(t3, e3, n2) {
            const o2 = n2.mapper.toViewPosition(e3.position), i2 = o2.nodeBefore, r2 = o2.nodeAfter;
            Hb(n2.writer, i2, r2);
          }
          function Xb(t3, e3, n2) {
            if (n2.consumable.consume(e3.viewItem, { name: true })) {
              const t4 = n2.writer, o2 = t4.createElement("listItem"), i2 = function(t5) {
                let e4 = 0, n3 = t5.parent;
                for (; n3; ) {
                  if (n3.is("element", "li"))
                    e4++;
                  else {
                    const t6 = n3.previousSibling;
                    t6 && t6.is("element", "li") && e4++;
                  }
                  n3 = n3.parent;
                }
                return e4;
              }(e3.viewItem);
              t4.setAttribute("listIndent", i2, o2);
              const r2 = e3.viewItem.parent && "ol" == e3.viewItem.parent.name ? "numbered" : "bulleted";
              if (t4.setAttribute("listType", r2, o2), !n2.safeInsert(o2, e3.modelCursor))
                return;
              const s2 = function(t5, e4, n3) {
                const { writer: o3, schema: i3 } = n3;
                let r3 = o3.createPositionAfter(t5);
                for (const s3 of e4)
                  if ("ul" == s3.name || "ol" == s3.name)
                    r3 = n3.convertItem(s3, r3).modelCursor;
                  else {
                    const e5 = n3.convertItem(s3, o3.createPositionAt(t5, "end")), a2 = e5.modelRange.start.nodeAfter;
                    a2 && a2.is("element") && !i3.checkChild(t5, a2.name) && (t5 = e5.modelCursor.parent.is("element", "listItem") ? e5.modelCursor.parent : iw(e5.modelCursor), r3 = o3.createPositionAfter(t5));
                  }
                return r3;
              }(o2, e3.viewItem.getChildren(), n2);
              e3.modelRange = t4.createRange(e3.modelCursor, s2), n2.updateConversionResult(o2, e3);
            }
          }
          function tw(t3, e3, n2) {
            if (n2.consumable.test(e3.viewItem, { name: true })) {
              const t4 = Array.from(e3.viewItem.getChildren());
              for (const e4 of t4) {
                !(e4.is("element", "li") || sw(e4)) && e4._remove();
              }
            }
          }
          function ew(t3, e3, n2) {
            if (n2.consumable.test(e3.viewItem, { name: true })) {
              if (0 === e3.viewItem.childCount)
                return;
              const t4 = [...e3.viewItem.getChildren()];
              let n3 = false;
              for (const e4 of t4)
                n3 && !sw(e4) && e4._remove(), sw(e4) && (n3 = true);
            }
          }
          function nw(t3) {
            return (e3, n2) => {
              if (n2.isPhantom)
                return;
              const o2 = n2.modelPosition.nodeBefore;
              if (o2 && o2.is("element", "listItem")) {
                const e4 = n2.mapper.toViewElement(o2), i2 = e4.getAncestors().find(sw), r2 = t3.createPositionAt(e4, 0).getWalker();
                for (const t4 of r2) {
                  if ("elementStart" == t4.type && t4.item.is("element", "li")) {
                    n2.viewPosition = t4.previousPosition;
                    break;
                  }
                  if ("elementEnd" == t4.type && t4.item == i2) {
                    n2.viewPosition = t4.nextPosition;
                    break;
                  }
                }
              }
            };
          }
          function ow(t3, [e3, n2]) {
            let o2, i2 = e3.is("documentFragment") ? e3.getChild(0) : e3;
            if (o2 = n2 ? this.createSelection(n2) : this.document.selection, i2 && i2.is("element", "listItem")) {
              const t4 = o2.getFirstPosition();
              let e4 = null;
              if (t4.parent.is("element", "listItem") ? e4 = t4.parent : t4.nodeBefore && t4.nodeBefore.is("element", "listItem") && (e4 = t4.nodeBefore), e4) {
                const t5 = e4.getAttribute("listIndent");
                if (t5 > 0)
                  for (; i2 && i2.is("element", "listItem"); )
                    i2._setAttribute("listIndent", i2.getAttribute("listIndent") + t5), i2 = i2.nextSibling;
              }
            }
          }
          function iw(t3) {
            const e3 = new Va({ startPosition: t3 });
            let n2;
            do {
              n2 = e3.next();
            } while (!n2.value.item.is("element", "listItem"));
            return n2.value.item;
          }
          function rw(t3, e3, n2, o2, i2, r2) {
            const s2 = Wb(e3.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t3, foo: "b" }), a2 = i2.mapper, c2 = i2.writer, l2 = s2 ? s2.getAttribute("listIndent") : null;
            let d2;
            if (s2)
              if (l2 == t3) {
                const t4 = a2.toViewElement(s2).parent;
                d2 = c2.createPositionAfter(t4);
              } else {
                const t4 = r2.createPositionAt(s2, "end");
                d2 = a2.toViewPosition(t4);
              }
            else
              d2 = n2;
            d2 = qb(d2);
            for (const t4 of [...o2.getChildren()])
              sw(t4) && (d2 = c2.move(c2.createRangeOn(t4), d2).end, Hb(c2, t4, t4.nextSibling), Hb(c2, t4.previousSibling, t4));
          }
          function sw(t3) {
            return t3.is("element", "ol") || t3.is("element", "ul");
          }
          class aw extends ue {
            static get pluginName() {
              return "ListEditing";
            }
            static get requires() {
              return [xg, Ng];
            }
            init() {
              const t3 = this.editor;
              t3.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
              const e3 = t3.data, n2 = t3.editing;
              var o2;
              t3.model.document.registerPostFixer((e4) => function(t4, e5) {
                const n3 = t4.document.differ.getChanges(), o3 = /* @__PURE__ */ new Map();
                let i3 = false;
                for (const o4 of n3)
                  if ("insert" == o4.type && "listItem" == o4.name)
                    r3(o4.position);
                  else if ("insert" == o4.type && "listItem" != o4.name) {
                    if ("$text" != o4.name) {
                      const n4 = o4.position.nodeAfter;
                      n4.hasAttribute("listIndent") && (e5.removeAttribute("listIndent", n4), i3 = true), n4.hasAttribute("listType") && (e5.removeAttribute("listType", n4), i3 = true), n4.hasAttribute("listStyle") && (e5.removeAttribute("listStyle", n4), i3 = true), n4.hasAttribute("listReversed") && (e5.removeAttribute("listReversed", n4), i3 = true), n4.hasAttribute("listStart") && (e5.removeAttribute("listStart", n4), i3 = true);
                      for (const e6 of Array.from(t4.createRangeIn(n4)).filter((t5) => t5.item.is("element", "listItem")))
                        r3(e6.previousPosition);
                    }
                    r3(o4.position.getShiftedBy(o4.length));
                  } else
                    "remove" == o4.type && "listItem" == o4.name ? r3(o4.position) : ("attribute" == o4.type && "listIndent" == o4.attributeKey || "attribute" == o4.type && "listType" == o4.attributeKey) && r3(o4.range.start);
                for (const t5 of o3.values())
                  s2(t5), a2(t5);
                return i3;
                function r3(t5) {
                  const e6 = t5.nodeBefore;
                  if (e6 && e6.is("element", "listItem")) {
                    let t6 = e6;
                    if (o3.has(t6))
                      return;
                    for (let e7 = t6.previousSibling; e7 && e7.is("element", "listItem"); e7 = t6.previousSibling)
                      if (t6 = e7, o3.has(t6))
                        return;
                    o3.set(e6, t6);
                  } else {
                    const e7 = t5.nodeAfter;
                    e7 && e7.is("element", "listItem") && o3.set(e7, e7);
                  }
                }
                function s2(t5) {
                  let n4 = 0, o4 = null;
                  for (; t5 && t5.is("element", "listItem"); ) {
                    const r4 = t5.getAttribute("listIndent");
                    if (r4 > n4) {
                      let s3;
                      null === o4 ? (o4 = r4 - n4, s3 = n4) : (o4 > r4 && (o4 = r4), s3 = r4 - o4), e5.setAttribute("listIndent", s3, t5), i3 = true;
                    } else
                      o4 = null, n4 = t5.getAttribute("listIndent") + 1;
                    t5 = t5.nextSibling;
                  }
                }
                function a2(t5) {
                  let n4 = [], o4 = null;
                  for (; t5 && t5.is("element", "listItem"); ) {
                    const r4 = t5.getAttribute("listIndent");
                    if (o4 && o4.getAttribute("listIndent") > r4 && (n4 = n4.slice(0, r4 + 1)), 0 != r4)
                      if (n4[r4]) {
                        const o5 = n4[r4];
                        t5.getAttribute("listType") != o5 && (e5.setAttribute("listType", o5, t5), i3 = true);
                      } else
                        n4[r4] = t5.getAttribute("listType");
                    o4 = t5, t5 = t5.nextSibling;
                  }
                }
              }(t3.model, e4)), n2.mapper.registerViewToModelLength("li", cw), e3.mapper.registerViewToModelLength("li", cw), n2.mapper.on("modelToViewPosition", nw(n2.view)), n2.mapper.on("viewToModelPosition", (o2 = t3.model, (t4, e4) => {
                const n3 = e4.viewPosition, i3 = n3.parent, r3 = e4.mapper;
                if ("ul" == i3.name || "ol" == i3.name) {
                  if (n3.isAtEnd) {
                    const t5 = r3.toModelElement(n3.nodeBefore), i4 = r3.getModelLength(n3.nodeBefore);
                    e4.modelPosition = o2.createPositionBefore(t5).getShiftedBy(i4);
                  } else {
                    const t5 = r3.toModelElement(n3.nodeAfter);
                    e4.modelPosition = o2.createPositionBefore(t5);
                  }
                  t4.stop();
                } else if ("li" == i3.name && n3.nodeBefore && ("ul" == n3.nodeBefore.name || "ol" == n3.nodeBefore.name)) {
                  const s2 = r3.toModelElement(i3);
                  let a2 = 1, c2 = n3.nodeBefore;
                  for (; c2 && sw(c2); )
                    a2 += r3.getModelLength(c2), c2 = c2.previousSibling;
                  e4.modelPosition = o2.createPositionBefore(s2).getShiftedBy(a2), t4.stop();
                }
              })), e3.mapper.on("modelToViewPosition", nw(n2.view)), t3.conversion.for("editingDowncast").add((e4) => {
                e4.on("insert", Zb, { priority: "high" }), e4.on("insert:listItem", Qb(t3.model)), e4.on("attribute:listType:listItem", Kb, { priority: "high" }), e4.on("attribute:listType:listItem", $b, { priority: "low" }), e4.on("attribute:listIndent:listItem", function(t4) {
                  return (e5, n3, o3) => {
                    if (!o3.consumable.consume(n3.item, "attribute:listIndent"))
                      return;
                    const i3 = o3.mapper.toViewElement(n3.item), r3 = o3.writer;
                    r3.breakContainer(r3.createPositionBefore(i3)), r3.breakContainer(r3.createPositionAfter(i3));
                    const s2 = i3.parent, a2 = s2.previousSibling, c2 = r3.createRangeOn(s2);
                    r3.remove(c2), a2 && a2.nextSibling && Hb(r3, a2, a2.nextSibling), rw(n3.attributeOldValue + 1, n3.range.start, c2.start, i3, o3, t4), Ub(n3.item, i3, o3, t4);
                    for (const t5 of n3.item.getChildren())
                      o3.consumable.consume(t5, "insert");
                  };
                }(t3.model)), e4.on("remove:listItem", function(t4) {
                  return (e5, n3, o3) => {
                    const i3 = o3.mapper.toViewPosition(n3.position).getLastMatchingPosition((t5) => !t5.item.is("element", "li")).nodeAfter, r3 = o3.writer;
                    r3.breakContainer(r3.createPositionBefore(i3)), r3.breakContainer(r3.createPositionAfter(i3));
                    const s2 = i3.parent, a2 = s2.previousSibling, c2 = r3.createRangeOn(s2), l2 = r3.remove(c2);
                    a2 && a2.nextSibling && Hb(r3, a2, a2.nextSibling), rw(o3.mapper.toModelElement(i3).getAttribute("listIndent") + 1, n3.position, c2.start, i3, o3, t4);
                    for (const t5 of r3.createRangeIn(l2).getItems())
                      o3.mapper.unbindViewElement(t5);
                    e5.stop();
                  };
                }(t3.model)), e4.on("remove", Jb, { priority: "low" });
              }), t3.conversion.for("dataDowncast").add((e4) => {
                e4.on("insert", Zb, { priority: "high" }), e4.on("insert:listItem", Qb(t3.model));
              }), t3.conversion.for("upcast").add((t4) => {
                t4.on("element:ul", tw, { priority: "high" }), t4.on("element:ol", tw, { priority: "high" }), t4.on("element:li", ew, { priority: "high" }), t4.on("element:li", Xb);
              }), t3.model.on("insertContent", ow, { priority: "high" }), t3.commands.add("numberedList", new Ob(t3, "numbered")), t3.commands.add("bulletedList", new Ob(t3, "bulleted")), t3.commands.add("indentList", new Fb(t3, "forward")), t3.commands.add("outdentList", new Fb(t3, "backward"));
              const i2 = n2.view.document;
              this.listenTo(i2, "enter", (t4, e4) => {
                const n3 = this.editor.model.document, o3 = n3.selection.getLastPosition().parent;
                n3.selection.isCollapsed && "listItem" == o3.name && o3.isEmpty && (this.editor.execute("outdentList"), e4.preventDefault(), t4.stop());
              }, { context: "li" }), this.listenTo(i2, "delete", (t4, e4) => {
                if ("backward" !== e4.direction)
                  return;
                const n3 = this.editor.model.document.selection;
                if (!n3.isCollapsed)
                  return;
                const o3 = n3.getFirstPosition();
                if (!o3.isAtStart)
                  return;
                const i3 = o3.parent;
                if ("listItem" !== i3.name)
                  return;
                i3.previousSibling && "listItem" === i3.previousSibling.name || (this.editor.execute("outdentList"), e4.preventDefault(), t4.stop());
              }, { context: "li" });
              const r2 = (t4) => (e4, n3) => {
                this.editor.commands.get(t4).isEnabled && (this.editor.execute(t4), n3());
              };
              t3.keystrokes.set("Tab", r2("indentList")), t3.keystrokes.set("Shift+Tab", r2("outdentList"));
            }
            afterInit() {
              const t3 = this.editor.commands, e3 = t3.get("indent"), n2 = t3.get("outdent");
              e3 && e3.registerChildCommand(t3.get("indentList")), n2 && n2.registerChildCommand(t3.get("outdentList"));
            }
          }
          function cw(t3) {
            let e3 = 1;
            for (const n2 of t3.getChildren())
              if ("ul" == n2.name || "ol" == n2.name)
                for (const t4 of n2.getChildren())
                  e3 += cw(t4);
            return e3;
          }
          class lw extends ue {
            static get pluginName() {
              return "ListUI";
            }
            init() {
              const t3 = this.editor.t;
              Gb(this.editor, "numberedList", t3("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), Gb(this.editor, "bulletedList", t3("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
            }
          }
          function dw(t3, e3) {
            return (t4) => {
              t4.on("attribute:url:media", n2);
            };
            function n2(n3, o2, i2) {
              if (!i2.consumable.consume(o2.item, n3.name))
                return;
              const r2 = o2.attributeNewValue, s2 = i2.writer, a2 = i2.mapper.toViewElement(o2.item), c2 = [...a2.getChildren()].find((t4) => t4.getCustomProperty("media-content"));
              s2.remove(c2);
              const l2 = t3.getMediaViewElement(s2, r2, e3);
              s2.insert(s2.createPositionAt(a2, 0), l2);
            }
          }
          function hw(t3, e3, n2, o2) {
            return t3.createContainerElement("figure", { class: "media" }, [e3.getMediaViewElement(t3, n2, o2), t3.createSlot()]);
          }
          function uw(t3) {
            const e3 = t3.getSelectedElement();
            return e3 && e3.is("element", "media") ? e3 : null;
          }
          function gw(t3, e3, n2) {
            t3.change((o2) => {
              const i2 = o2.createElement("media", { url: e3 });
              t3.insertContent(i2, n2), o2.setSelection(i2, "on");
            });
          }
          class mw extends me {
            refresh() {
              const t3 = this.editor.model, e3 = t3.document.selection, n2 = uw(e3);
              this.value = n2 ? n2.getAttribute("url") : null, this.isEnabled = function(t4) {
                const e4 = t4.getSelectedElement();
                return !!e4 && "media" === e4.name;
              }(e3) || function(t4, e4) {
                let n3 = Gg(t4, e4).start.parent;
                n3.isEmpty && !e4.schema.isLimit(n3) && (n3 = n3.parent);
                return e4.schema.checkChild(n3, "media");
              }(e3, t3);
            }
            execute(t3) {
              const e3 = this.editor.model, n2 = e3.document.selection, o2 = uw(n2);
              o2 ? e3.change((e4) => {
                e4.setAttribute("url", t3, o2);
              }) : gw(e3, t3, Gg(n2, e3));
            }
          }
          class pw {
            constructor(t3, e3) {
              const n2 = e3.providers, o2 = e3.extraProviders || [], i2 = new Set(e3.removeProviders), r2 = n2.concat(o2).filter((t4) => {
                const e4 = t4.name;
                return e4 ? !i2.has(e4) : (c("media-embed-no-provider-name", { provider: t4 }), false);
              });
              this.locale = t3, this.providerDefinitions = r2;
            }
            hasMedia(t3) {
              return !!this._getMedia(t3);
            }
            getMediaViewElement(t3, e3, n2) {
              return this._getMedia(e3).getViewElement(t3, n2);
            }
            _getMedia(t3) {
              if (!t3)
                return new fw(this.locale);
              t3 = t3.trim();
              for (const e3 of this.providerDefinitions) {
                const n2 = e3.html, o2 = So(e3.url);
                for (const e4 of o2) {
                  const o3 = this._getUrlMatches(t3, e4);
                  if (o3)
                    return new fw(this.locale, t3, o3, n2);
                }
              }
              return null;
            }
            _getUrlMatches(t3, e3) {
              let n2 = t3.match(e3);
              if (n2)
                return n2;
              let o2 = t3.replace(/^https?:\/\//, "");
              return n2 = o2.match(e3), n2 || (o2 = o2.replace(/^www\./, ""), n2 = o2.match(e3), n2 || null);
            }
          }
          class fw {
            constructor(t3, e3, n2, o2) {
              this.url = this._getValidUrl(e3), this._t = t3.t, this._match = n2, this._previewRenderer = o2;
            }
            getViewElement(t3, e3) {
              const n2 = {};
              let o2;
              if (e3.renderForEditingView || e3.renderMediaPreview && this.url && this._previewRenderer) {
                this.url && (n2["data-oembed-url"] = this.url), e3.renderForEditingView && (n2.class = "ck-media__wrapper");
                const i2 = this._getPreviewHtml(e3);
                o2 = t3.createRawElement("div", n2, (t4, e4) => {
                  e4.setContentOf(t4, i2);
                });
              } else
                this.url && (n2.url = this.url), o2 = t3.createEmptyElement(e3.elementName, n2);
              return t3.setCustomProperty("media-content", true, o2), o2;
            }
            _getPreviewHtml(t3) {
              return this._previewRenderer ? this._previewRenderer(this._match) : this.url && t3.renderForEditingView ? this._getPlaceholderHtml() : "";
            }
            _getPlaceholderHtml() {
              const t3 = new dh(), e3 = new ah();
              t3.text = this._t("Open media in new tab"), e3.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', e3.viewBox = "0 0 64 42";
              return new Od({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [e3] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }, t3] }] }).render().outerHTML;
            }
            _getValidUrl(t3) {
              return t3 ? t3.match(/^https?/) ? t3 : "https://" + t3 : null;
            }
          }
          var kw = n(7442), bw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(kw.Z, bw);
          kw.Z.locals;
          class ww extends ue {
            static get pluginName() {
              return "MediaEmbedEditing";
            }
            constructor(t3) {
              super(t3), t3.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: (t4) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t4[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>` }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: (t4) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t4[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>` }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)/, /^youtube\.com\/embed\/([\w-]+)/, /^youtu\.be\/([\w-]+)/], html: (t4) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${t4[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>` }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: (t4) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t4[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>` }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }), this.registry = new pw(t3.locale, t3.config.get("mediaEmbed"));
            }
            init() {
              const t3 = this.editor, e3 = t3.model.schema, n2 = t3.t, o2 = t3.conversion, i2 = t3.config.get("mediaEmbed.previewsInData"), r2 = t3.config.get("mediaEmbed.elementName"), s2 = this.registry;
              t3.commands.add("mediaEmbed", new mw(t3)), e3.register("media", { isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["url"] }), o2.for("dataDowncast").elementToStructure({ model: "media", view: (t4, { writer: e4 }) => {
                const n3 = t4.getAttribute("url");
                return hw(e4, s2, n3, { elementName: r2, renderMediaPreview: n3 && i2 });
              } }), o2.for("dataDowncast").add(dw(s2, { elementName: r2, renderMediaPreview: i2 })), o2.for("editingDowncast").elementToStructure({ model: "media", view: (t4, { writer: e4 }) => {
                const o3 = t4.getAttribute("url");
                return function(t5, e5, n3) {
                  return e5.setCustomProperty("media", true, t5), Fg(t5, e5, { label: n3 });
                }(hw(e4, s2, o3, { elementName: r2, renderForEditingView: true }), e4, n2("media widget"));
              } }), o2.for("editingDowncast").add(dw(s2, { elementName: r2, renderForEditingView: true })), o2.for("upcast").elementToElement({ view: (t4) => ["oembed", r2].includes(t4.name) && t4.getAttribute("url") ? { name: true } : null, model: (t4, { writer: e4 }) => {
                const n3 = t4.getAttribute("url");
                if (s2.hasMedia(n3))
                  return e4.createElement("media", { url: n3 });
              } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (t4, { writer: e4 }) => {
                const n3 = t4.getAttribute("data-oembed-url");
                if (s2.hasMedia(n3))
                  return e4.createElement("media", { url: n3 });
              } }).add((t4) => {
                t4.on("element:figure", function(t5, e4, n3) {
                  if (!n3.consumable.consume(e4.viewItem, { name: true, classes: "media" }))
                    return;
                  const { modelRange: o3, modelCursor: i3 } = n3.convertChildren(e4.viewItem, e4.modelCursor);
                  e4.modelRange = o3, e4.modelCursor = i3;
                  Aa(o3.getItems()) || n3.consumable.revert(e4.viewItem, { name: true, classes: "media" });
                });
              });
            }
          }
          const Cw = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
          class Aw extends ue {
            static get requires() {
              return [Am, Ng, up];
            }
            static get pluginName() {
              return "AutoMediaEmbed";
            }
            constructor(t3) {
              super(t3), this._timeoutId = null, this._positionToInsert = null;
            }
            init() {
              const t3 = this.editor, e3 = t3.model.document;
              this.listenTo(t3.plugins.get("ClipboardPipeline"), "inputTransformation", () => {
                const t4 = e3.selection.getFirstRange(), n2 = Jl.fromPosition(t4.start);
                n2.stickiness = "toPrevious";
                const o2 = Jl.fromPosition(t4.end);
                o2.stickiness = "toNext", e3.once("change:data", () => {
                  this._embedMediaBetweenPositions(n2, o2), n2.detach(), o2.detach();
                }, { priority: "high" });
              }), t3.commands.get("undo").on("execute", () => {
                this._timeoutId && (is.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
              }, { priority: "high" });
            }
            _embedMediaBetweenPositions(t3, e3) {
              const n2 = this.editor, o2 = n2.plugins.get(ww).registry, i2 = new rc(t3, e3), r2 = i2.getWalker({ ignoreElementEnd: true });
              let s2 = "";
              for (const t4 of r2)
                t4.item.is("$textProxy") && (s2 += t4.item.data);
              if (s2 = s2.trim(), !s2.match(Cw))
                return void i2.detach();
              if (!o2.hasMedia(s2))
                return void i2.detach();
              n2.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Jl.fromPosition(t3), this._timeoutId = is.window.setTimeout(() => {
                n2.model.change((t4) => {
                  let e4;
                  this._timeoutId = null, t4.remove(i2), i2.detach(), "$graveyard" !== this._positionToInsert.root.rootName && (e4 = this._positionToInsert), gw(n2.model, s2, e4), this._positionToInsert.detach(), this._positionToInsert = null;
                }), n2.plugins.get("Delete").requestUndoOnBackspace();
              }, 100)) : i2.detach();
            }
          }
          var _w = n(9292), vw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(_w.Z, vw);
          _w.Z.locals;
          class yw extends Ld {
            constructor(t3, e3) {
              super(e3);
              const n2 = e3.t;
              this.focusTracker = new _a(), this.keystrokes = new va(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n2("Save"), Md.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t4) => !!t4), this.cancelButtonView = this._createButton(n2("Cancel"), Md.cancel, "ck-button-cancel", "cancel"), this._focusables = new Bd(), this._focusCycler = new Nh({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this._validators = t3, this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] }), Td(this);
            }
            render() {
              super.render(), Nd({ view: this });
              [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
                this._focusables.add(t4), this.focusTracker.add(t4.element);
              }), this.keystrokes.listenTo(this.element);
              const t3 = (t4) => t4.stopPropagation();
              this.keystrokes.set("arrowright", t3), this.keystrokes.set("arrowleft", t3), this.keystrokes.set("arrowup", t3), this.keystrokes.set("arrowdown", t3), this.listenTo(this.urlInputView.element, "selectstart", (t4, e3) => {
                e3.stopPropagation();
              }, { priority: "high" });
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            get url() {
              return this.urlInputView.fieldView.element.value.trim();
            }
            set url(t3) {
              this.urlInputView.fieldView.element.value = t3.trim();
            }
            isValid() {
              this.resetFormStatus();
              for (const t3 of this._validators) {
                const e3 = t3(this);
                if (e3)
                  return this.urlInputView.errorText = e3, false;
              }
              return true;
            }
            resetFormStatus() {
              this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
            }
            _createUrlInput() {
              const t3 = this.locale.t, e3 = new bu(this.locale, wu), n2 = e3.fieldView;
              return this._urlInputViewInfoDefault = t3("Paste the media URL in the input."), this._urlInputViewInfoTip = t3("Tip: Paste the URL into the content to embed faster."), e3.label = t3("Media URL"), e3.infoText = this._urlInputViewInfoDefault, n2.on("input", () => {
                e3.infoText = n2.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = n2.element.value.trim();
              }), e3;
            }
            _createButton(t3, e3, n2, o2) {
              const i2 = new gh(this.locale);
              return i2.set({ label: t3, icon: e3, tooltip: true }), i2.extendTemplate({ attributes: { class: n2 } }), o2 && i2.delegate("execute").to(this, o2), i2;
            }
          }
          class xw extends ue {
            static get requires() {
              return [ww];
            }
            static get pluginName() {
              return "MediaEmbedUI";
            }
            init() {
              const t3 = this.editor, e3 = t3.commands.get("mediaEmbed"), n2 = t3.plugins.get(ww).registry;
              t3.ui.componentFactory.add("mediaEmbed", (o2) => {
                const i2 = Jh(o2), r2 = new yw(function(t4, e4) {
                  return [(e5) => {
                    if (!e5.url.length)
                      return t4("The URL must not be empty.");
                  }, (n3) => {
                    if (!e4.hasMedia(n3.url))
                      return t4("This media URL is not supported.");
                  }];
                }(t3.t, n2), t3.locale);
                return this._setUpDropdown(i2, r2, e3, t3), this._setUpForm(i2, r2, e3), i2;
              });
            }
            _setUpDropdown(t3, e3, n2) {
              const o2 = this.editor, i2 = o2.t, r2 = t3.buttonView;
              function s2() {
                o2.editing.view.focus(), t3.isOpen = false;
              }
              t3.bind("isEnabled").to(n2), t3.panelView.children.add(e3), r2.set({ label: i2("Insert media"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>', tooltip: true }), r2.on("open", () => {
                e3.disableCssTransitions(), e3.url = n2.value || "", e3.urlInputView.fieldView.select(), e3.focus(), e3.enableCssTransitions();
              }, { priority: "low" }), t3.on("submit", () => {
                e3.isValid() && (o2.execute("mediaEmbed", e3.url), s2());
              }), t3.on("change:isOpen", () => e3.resetFormStatus()), t3.on("cancel", () => s2());
            }
            _setUpForm(t3, e3, n2) {
              e3.delegate("submit", "cancel").to(t3), e3.urlInputView.bind("value").to(n2, "value"), e3.urlInputView.bind("isReadOnly").to(n2, "isEnabled", (t4) => !t4);
            }
          }
          var Ew = n(4652), Dw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(Ew.Z, Dw);
          Ew.Z.locals;
          function Iw(t3, e3) {
            if (!t3.childCount)
              return;
            const n2 = new dg(t3.document), o2 = function(t4, e4) {
              const n3 = e4.createRangeIn(t4), o3 = new Ho({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }), i3 = [];
              for (const t5 of n3)
                if ("elementStart" === t5.type && o3.match(t5.item)) {
                  const e5 = Tw(t5.item);
                  i3.push({ element: t5.item, id: e5.id, order: e5.order, indent: e5.indent });
                }
              return i3;
            }(t3, n2);
            if (!o2.length)
              return;
            let i2 = null, r2 = 1;
            o2.forEach((t4, s2) => {
              const a2 = function(t5, e4) {
                if (!t5)
                  return true;
                if (t5.id !== e4.id)
                  return e4.indent - t5.indent != 1;
                const n3 = e4.element.previousSibling;
                if (!n3)
                  return true;
                return o3 = n3, !(o3.is("element", "ol") || o3.is("element", "ul"));
                var o3;
              }(o2[s2 - 1], t4), c2 = a2 ? null : o2[s2 - 1], l2 = (h2 = t4, (d2 = c2) ? h2.indent - d2.indent : h2.indent - 1);
              var d2, h2;
              if (a2 && (i2 = null, r2 = 1), !i2 || 0 !== l2) {
                const o3 = function(t5, e4) {
                  const n3 = new RegExp(`@list l${t5.id}:level${t5.indent}\\s*({[^}]*)`, "gi"), o4 = /mso-level-number-format:([^;]{0,100});/gi, i3 = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, r3 = n3.exec(e4);
                  let s3 = "decimal", a3 = "ol", c3 = null;
                  if (r3 && r3[1]) {
                    const e5 = o4.exec(r3[1]);
                    if (e5 && e5[1] && (s3 = e5[1].trim(), a3 = "bullet" !== s3 && "image" !== s3 ? "ol" : "ul"), "bullet" === s3) {
                      const e6 = function(t6) {
                        const e7 = function(t7) {
                          if (t7.getChild(0).is("$text"))
                            return null;
                          for (const e8 of t7.getChildren()) {
                            if (!e8.is("element", "span"))
                              continue;
                            const t8 = e8.getChild(0);
                            return t8.is("$text") ? t8 : t8.getChild(0);
                          }
                        }(t6);
                        if (!e7)
                          return null;
                        const n4 = e7._data;
                        if ("o" === n4)
                          return "circle";
                        if ("\xB7" === n4)
                          return "disc";
                        if ("\xA7" === n4)
                          return "square";
                        return null;
                      }(t5.element);
                      e6 && (s3 = e6);
                    } else {
                      const t6 = i3.exec(r3[1]);
                      t6 && t6[1] && (c3 = parseInt(t6[1]));
                    }
                  }
                  return { type: a3, startIndex: c3, style: Mw(s3) };
                }(t4, e3);
                if (i2) {
                  if (t4.indent > r2) {
                    const t5 = i2.getChild(i2.childCount - 1), e4 = t5.getChild(t5.childCount - 1);
                    i2 = Sw(o3, e4, n2), r2 += 1;
                  } else if (t4.indent < r2) {
                    const e4 = r2 - t4.indent;
                    i2 = function(t5, e5) {
                      const n3 = t5.getAncestors({ parentFirst: true });
                      let o4 = null, i3 = 0;
                      for (const t6 of n3)
                        if ("ul" !== t6.name && "ol" !== t6.name || i3++, i3 === e5) {
                          o4 = t6;
                          break;
                        }
                      return o4;
                    }(i2, e4), r2 = parseInt(t4.indent);
                  }
                } else
                  i2 = Sw(o3, t4.element, n2);
                t4.indent <= r2 && (i2.is("element", o3.type) || (i2 = n2.rename(o3.type, i2)));
              }
              const u2 = function(t5, e4) {
                return function(t6, e5) {
                  const n3 = new Ho({ name: "span", styles: { "mso-list": "Ignore" } }), o3 = e5.createRangeIn(t6);
                  for (const t7 of o3)
                    "elementStart" === t7.type && n3.match(t7.item) && e5.remove(t7.item);
                }(t5, e4), e4.rename("li", t5);
              }(t4.element, n2);
              n2.appendChild(u2, i2);
            });
          }
          function Mw(t3) {
            if (t3.startsWith("arabic-leading-zero"))
              return "decimal-leading-zero";
            switch (t3) {
              case "alpha-upper":
                return "upper-alpha";
              case "alpha-lower":
                return "lower-alpha";
              case "roman-upper":
                return "upper-roman";
              case "roman-lower":
                return "lower-roman";
              case "circle":
              case "disc":
              case "square":
                return t3;
              default:
                return null;
            }
          }
          function Sw(t3, e3, n2) {
            const o2 = e3.parent, i2 = n2.createElement(t3.type), r2 = o2.getChildIndex(e3) + 1;
            return n2.insertChild(r2, i2, o2), t3.style && n2.setStyle("list-style-type", t3.style, i2), t3.startIndex && t3.startIndex > 1 && n2.setAttribute("start", t3.startIndex, i2), i2;
          }
          function Tw(t3) {
            const e3 = {}, n2 = t3.getStyle("mso-list");
            if (n2) {
              const t4 = n2.match(/(^|\s{1,100})l(\d+)/i), o2 = n2.match(/\s{0,100}lfo(\d+)/i), i2 = n2.match(/\s{0,100}level(\d+)/i);
              t4 && o2 && i2 && (e3.id = t4[2], e3.order = o2[1], e3.indent = i2[1]);
            }
            return e3;
          }
          const Nw = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
          class Bw {
            constructor(t3) {
              this.document = t3;
            }
            isActive(t3) {
              return Nw.test(t3);
            }
            execute(t3) {
              const e3 = new dg(this.document), { body: n2 } = t3._parsedData;
              !function(t4, e4) {
                for (const n3 of t4.getChildren())
                  if (n3.is("element", "b") && "normal" === n3.getStyle("font-weight")) {
                    const o2 = t4.getChildIndex(n3);
                    e4.remove(n3), e4.insertChild(o2, n3.getChildren(), t4);
                  }
              }(n2, e3), function(t4, e4) {
                for (const n3 of e4.createRangeIn(t4)) {
                  const t5 = n3.item;
                  if (t5.is("element", "li")) {
                    const n4 = t5.getChild(0);
                    n4 && n4.is("element", "p") && e4.unwrapElement(n4);
                  }
                }
              }(n2, e3), t3.content = n2;
            }
          }
          function zw(t3, e3) {
            if (!t3.childCount)
              return;
            const n2 = new dg(), o2 = function(t4, e4) {
              const n3 = e4.createRangeIn(t4), o3 = new Ho({ name: /v:(.+)/ }), i3 = [];
              for (const t5 of n3) {
                if ("elementStart" != t5.type)
                  continue;
                const e5 = t5.item, n4 = e5.previousSibling && e5.previousSibling.name || null;
                o3.match(e5) && e5.getAttribute("o:gfxdata") && "v:shapetype" !== n4 && i3.push(t5.item.getAttribute("id"));
              }
              return i3;
            }(t3, n2);
            !function(t4, e4, n3) {
              const o3 = n3.createRangeIn(e4), i3 = new Ho({ name: "img" }), r2 = [];
              for (const e5 of o3)
                if (i3.match(e5.item)) {
                  const n4 = e5.item, o4 = n4.getAttribute("v:shapes") ? n4.getAttribute("v:shapes").split(" ") : [];
                  o4.length && o4.every((e6) => t4.indexOf(e6) > -1) ? r2.push(n4) : n4.getAttribute("src") || r2.push(n4);
                }
              for (const t5 of r2)
                n3.remove(t5);
            }(o2, t3, n2), function(t4, e4) {
              const n3 = e4.createRangeIn(t4), o3 = new Ho({ name: /v:(.+)/ }), i3 = [];
              for (const t5 of n3)
                "elementStart" == t5.type && o3.match(t5.item) && i3.push(t5.item);
              for (const t5 of i3)
                e4.remove(t5);
            }(t3, n2);
            const i2 = function(t4, e4) {
              const n3 = e4.createRangeIn(t4), o3 = new Ho({ name: "img" }), i3 = [];
              for (const t5 of n3)
                o3.match(t5.item) && t5.item.getAttribute("src").startsWith("file://") && i3.push(t5.item);
              return i3;
            }(t3, n2);
            i2.length && function(t4, e4, n3) {
              if (t4.length === e4.length)
                for (let o3 = 0; o3 < t4.length; o3++) {
                  const i3 = `data:${e4[o3].type};base64,${Pw(e4[o3].hex)}`;
                  n3.setAttribute("src", i3, t4[o3]);
                }
            }(i2, function(t4) {
              if (!t4)
                return [];
              const e4 = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, n3 = new RegExp("(?:(" + e4.source + "))([\\da-fA-F\\s]+)\\}", "g"), o3 = t4.match(n3), i3 = [];
              if (o3)
                for (const t5 of o3) {
                  let n4 = false;
                  t5.includes("\\pngblip") ? n4 = "image/png" : t5.includes("\\jpegblip") && (n4 = "image/jpeg"), n4 && i3.push({ hex: t5.replace(e4, "").replace(/[^\da-fA-F]/g, ""), type: n4 });
                }
              return i3;
            }(e3), n2);
          }
          function Pw(t3) {
            return btoa(t3.match(/\w{2}/g).map((t4) => String.fromCharCode(parseInt(t4, 16))).join(""));
          }
          const Lw = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, Ow = /xmlns:o="urn:schemas-microsoft-com/i;
          class Rw {
            constructor(t3) {
              this.document = t3;
            }
            isActive(t3) {
              return Lw.test(t3) || Ow.test(t3);
            }
            execute(t3) {
              const { body: e3, stylesString: n2 } = t3._parsedData;
              Iw(e3, n2), zw(e3, t3.dataTransfer.getData("text/rtf")), t3.content = e3;
            }
          }
          function jw(t3) {
            return t3.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t4, e3) => 1 === e3.length ? " " : Array(e3.length + 1).join("\xA0 ").substr(0, e3.length));
          }
          function Fw(t3, e3) {
            const n2 = new DOMParser(), o2 = function(t4) {
              return jw(jw(t4)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/ <\//g, "\xA0</").replace(/ <o:p><\/o:p>/g, "\xA0<o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
            }(function(t4) {
              const e4 = "</body>", n3 = "</html>", o3 = t4.indexOf(e4);
              if (o3 < 0)
                return t4;
              const i3 = t4.indexOf(n3, o3 + e4.length);
              return t4.substring(0, o3 + e4.length) + (i3 >= 0 ? t4.substring(i3) : "");
            }(t3 = t3.replace(/<!--\[if gte vml 1]>/g, ""))), i2 = n2.parseFromString(o2, "text/html");
            !function(t4) {
              t4.querySelectorAll("span[style*=spacerun]").forEach((t5) => {
                const e4 = t5.innerText.length || 0;
                t5.innerHTML = Array(e4 + 1).join("\xA0 ").substr(0, e4);
              });
            }(i2);
            const r2 = i2.body.innerHTML, s2 = function(t4, e4) {
              const n3 = new Ji(e4), o3 = new gs(n3, { renderingMode: "data" }), i3 = t4.createDocumentFragment(), r3 = t4.body.childNodes;
              for (; r3.length > 0; )
                i3.appendChild(r3[0]);
              return o3.domToView(i3, { skipComments: true });
            }(i2, e3), a2 = function(t4) {
              const e4 = [], n3 = [], o3 = Array.from(t4.getElementsByTagName("style"));
              for (const t5 of o3)
                t5.sheet && t5.sheet.cssRules && t5.sheet.cssRules.length && (e4.push(t5.sheet), n3.push(t5.innerHTML));
              return { styles: e4, stylesString: n3.join(" ") };
            }(i2);
            return { body: s2, bodyString: r2, styles: a2.styles, stylesString: a2.stylesString };
          }
          function Vw(t3, e3, n2, o2, i2 = 1) {
            e3 > i2 ? o2.setAttribute(t3, e3, n2) : o2.removeAttribute(t3, n2);
          }
          function Uw(t3, e3, n2 = {}) {
            const o2 = t3.createElement("tableCell", n2);
            return t3.insertElement("paragraph", o2), t3.insert(o2, e3), o2;
          }
          function Hw(t3, e3) {
            const n2 = e3.parent.parent, o2 = parseInt(n2.getAttribute("headingColumns") || 0), { column: i2 } = t3.getCellLocation(e3);
            return !!o2 && i2 < o2;
          }
          function qw() {
            return (t3) => {
              t3.on("element:table", (t4, e3, n2) => {
                const o2 = e3.viewItem;
                if (!n2.consumable.test(o2, { name: true }))
                  return;
                const { rows: i2, headingRows: r2, headingColumns: s2 } = function(t5) {
                  const e4 = { headingRows: 0, headingColumns: 0 }, n3 = [], o3 = [];
                  let i3;
                  for (const r3 of Array.from(t5.getChildren()))
                    if ("tbody" === r3.name || "thead" === r3.name || "tfoot" === r3.name) {
                      "thead" !== r3.name || i3 || (i3 = r3);
                      const t6 = Array.from(r3.getChildren()).filter((t7) => t7.is("element", "tr"));
                      for (const r4 of t6)
                        if ("thead" === r4.parent.name && r4.parent === i3)
                          e4.headingRows++, n3.push(r4);
                        else {
                          o3.push(r4);
                          const t7 = Gw(r4);
                          t7 > e4.headingColumns && (e4.headingColumns = t7);
                        }
                    }
                  return e4.rows = [...n3, ...o3], e4;
                }(o2), a2 = {};
                s2 && (a2.headingColumns = s2), r2 && (a2.headingRows = r2);
                const c2 = n2.writer.createElement("table", a2);
                if (n2.safeInsert(c2, e3.modelCursor)) {
                  if (n2.consumable.consume(o2, { name: true }), i2.forEach((t5) => n2.convertItem(t5, n2.writer.createPositionAt(c2, "end"))), n2.convertChildren(o2, n2.writer.createPositionAt(c2, "end")), c2.isEmpty) {
                    const t5 = n2.writer.createElement("tableRow");
                    n2.writer.insert(t5, n2.writer.createPositionAt(c2, "end")), Uw(n2.writer, n2.writer.createPositionAt(t5, "end"));
                  }
                  n2.updateConversionResult(c2, e3);
                }
              });
            };
          }
          function Ww(t3) {
            return (e3) => {
              e3.on(`element:${t3}`, (t4, e4, n2) => {
                if (e4.modelRange && e4.viewItem.isEmpty) {
                  const t5 = e4.modelRange.start.nodeAfter, o2 = n2.writer.createPositionAt(t5, 0);
                  n2.writer.insertElement("paragraph", o2);
                }
              }, { priority: "low" });
            };
          }
          function Gw(t3) {
            let e3 = 0, n2 = 0;
            const o2 = Array.from(t3.getChildren()).filter((t4) => "th" === t4.name || "td" === t4.name);
            for (; n2 < o2.length && "th" === o2[n2].name; ) {
              const t4 = o2[n2];
              e3 += parseInt(t4.getAttribute("colspan") || 1), n2++;
            }
            return e3;
          }
          class Yw {
            constructor(t3, e3 = {}) {
              this._table = t3, this._startRow = void 0 !== e3.row ? e3.row : e3.startRow || 0, this._endRow = void 0 !== e3.row ? e3.row : e3.endRow, this._startColumn = void 0 !== e3.column ? e3.column : e3.startColumn || 0, this._endColumn = void 0 !== e3.column ? e3.column : e3.endColumn, this._includeAllSlots = !!e3.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
            }
            [Symbol.iterator]() {
              return this;
            }
            next() {
              const t3 = this._table.getChild(this._rowIndex);
              if (!t3 || this._isOverEndRow())
                return { done: true };
              if (!t3.is("element", "tableRow"))
                return this._rowIndex++, this.next();
              if (this._isOverEndColumn())
                return this._advanceToNextRow();
              let e3 = null;
              const n2 = this._getSpanned();
              if (n2)
                this._includeAllSlots && !this._shouldSkipSlot() && (e3 = this._formatOutValue(n2.cell, n2.row, n2.column));
              else {
                const n3 = t3.getChild(this._cellIndex);
                if (!n3)
                  return this._advanceToNextRow();
                const o2 = parseInt(n3.getAttribute("colspan") || 1), i2 = parseInt(n3.getAttribute("rowspan") || 1);
                (o2 > 1 || i2 > 1) && this._recordSpans(n3, i2, o2), this._shouldSkipSlot() || (e3 = this._formatOutValue(n3)), this._nextCellAtColumn = this._column + o2;
              }
              return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, e3 || this.next();
            }
            skipRow(t3) {
              this._skipRows.add(t3);
            }
            _advanceToNextRow() {
              return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
            }
            _isOverEndRow() {
              return void 0 !== this._endRow && this._row > this._endRow;
            }
            _isOverEndColumn() {
              return void 0 !== this._endColumn && this._column > this._endColumn;
            }
            _formatOutValue(t3, e3 = this._row, n2 = this._column) {
              return { done: false, value: new Qw(this, t3, e3, n2) };
            }
            _shouldSkipSlot() {
              const t3 = this._skipRows.has(this._row), e3 = this._row < this._startRow, n2 = this._column < this._startColumn, o2 = void 0 !== this._endColumn && this._column > this._endColumn;
              return t3 || e3 || n2 || o2;
            }
            _getSpanned() {
              const t3 = this._spannedCells.get(this._row);
              return t3 && t3.get(this._column) || null;
            }
            _recordSpans(t3, e3, n2) {
              const o2 = { cell: t3, row: this._row, column: this._column };
              for (let t4 = this._row; t4 < this._row + e3; t4++)
                for (let e4 = this._column; e4 < this._column + n2; e4++)
                  t4 == this._row && e4 == this._column || this._markSpannedCell(t4, e4, o2);
            }
            _markSpannedCell(t3, e3, n2) {
              this._spannedCells.has(t3) || this._spannedCells.set(t3, /* @__PURE__ */ new Map());
              this._spannedCells.get(t3).set(e3, n2);
            }
          }
          class Qw {
            constructor(t3, e3, n2, o2) {
              this.cell = e3, this.row = t3._row, this.column = t3._column, this.cellAnchorRow = n2, this.cellAnchorColumn = o2, this._cellIndex = t3._cellIndex, this._rowIndex = t3._rowIndex, this._table = t3._table;
            }
            get isAnchor() {
              return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
            }
            get cellWidth() {
              return parseInt(this.cell.getAttribute("colspan") || 1);
            }
            get cellHeight() {
              return parseInt(this.cell.getAttribute("rowspan") || 1);
            }
            get rowIndex() {
              return this._rowIndex;
            }
            getPositionBefore() {
              return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
            }
          }
          function Kw(t3, e3 = {}) {
            return (n2, { writer: o2 }) => {
              const i2 = n2.getAttribute("headingRows") || 0, r2 = [];
              i2 > 0 && r2.push(o2.createContainerElement("thead", null, o2.createSlot((t4) => t4.is("element", "tableRow") && t4.index < i2))), i2 < t3.getRows(n2) && r2.push(o2.createContainerElement("tbody", null, o2.createSlot((t4) => t4.is("element", "tableRow") && t4.index >= i2)));
              const s2 = o2.createContainerElement("figure", { class: "table" }, [o2.createContainerElement("table", null, r2), o2.createSlot((t4) => !t4.is("element", "tableRow"))]);
              return e3.asWidget ? function(t4, e4) {
                return e4.setCustomProperty("table", true, t4), Fg(t4, e4, { hasSelectionHandle: true });
              }(s2, o2) : s2;
            };
          }
          function $w(t3 = {}) {
            return (e3, { writer: n2 }) => {
              const o2 = e3.parent, i2 = o2.parent, r2 = i2.getChildIndex(o2), s2 = new Yw(i2, { row: r2 }), a2 = i2.getAttribute("headingRows") || 0, c2 = i2.getAttribute("headingColumns") || 0;
              for (const o3 of s2)
                if (o3.cell == e3) {
                  const e4 = o3.row < a2 || o3.column < c2 ? "th" : "td";
                  return t3.asWidget ? Wg(n2.createEditableElement(e4), n2) : n2.createContainerElement(e4);
                }
            };
          }
          function Zw(t3 = {}) {
            return (e3, { writer: n2, consumable: o2, mapper: i2 }) => {
              if (e3.parent.is("element", "tableCell") && Jw(e3))
                return t3.asWidget ? n2.createContainerElement("span", { class: "ck-table-bogus-paragraph" }) : (o2.consume(e3, "insert"), void i2.bindElements(e3, i2.toViewElement(e3.parent)));
            };
          }
          function Jw(t3) {
            return 1 == t3.parent.childCount && ![...t3.getAttributeKeys()].length;
          }
          class Xw extends me {
            refresh() {
              const t3 = this.editor.model, e3 = t3.document.selection, n2 = t3.schema;
              this.isEnabled = function(t4, e4) {
                const n3 = t4.getFirstPosition().parent, o2 = n3 === n3.root ? n3 : n3.parent;
                return e4.checkChild(o2, "table");
              }(e3, n2);
            }
            execute(t3 = {}) {
              const e3 = this.editor.model, n2 = e3.document.selection, o2 = this.editor.plugins.get("TableUtils"), i2 = this.editor.config.get("table"), r2 = Gg(n2, e3), s2 = i2.defaultHeadings.rows, a2 = i2.defaultHeadings.columns;
              void 0 === t3.headingRows && s2 && (t3.headingRows = s2), void 0 === t3.headingColumns && a2 && (t3.headingColumns = a2), e3.change((n3) => {
                const i3 = o2.createTable(n3, t3);
                e3.insertContent(i3, r2), n3.setSelection(n3.createPositionAt(i3.getNodeByPath([0, 0, 0]), 0));
              });
            }
          }
          class tC extends me {
            constructor(t3, e3 = {}) {
              super(t3), this.order = e3.order || "below";
            }
            refresh() {
              const t3 = this.editor.model.document.selection, e3 = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t3).length;
              this.isEnabled = e3;
            }
            execute() {
              const t3 = this.editor, e3 = t3.model.document.selection, n2 = t3.plugins.get("TableUtils"), o2 = "above" === this.order, i2 = n2.getSelectionAffectedTableCells(e3), r2 = n2.getRowIndexes(i2), s2 = o2 ? r2.first : r2.last, a2 = i2[0].findAncestor("table");
              n2.insertRows(a2, { at: o2 ? s2 : s2 + 1, copyStructureFromAbove: !o2 });
            }
          }
          class eC extends me {
            constructor(t3, e3 = {}) {
              super(t3), this.order = e3.order || "right";
            }
            refresh() {
              const t3 = this.editor.model.document.selection, e3 = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t3).length;
              this.isEnabled = e3;
            }
            execute() {
              const t3 = this.editor, e3 = t3.model.document.selection, n2 = t3.plugins.get("TableUtils"), o2 = "left" === this.order, i2 = n2.getSelectionAffectedTableCells(e3), r2 = n2.getColumnIndexes(i2), s2 = o2 ? r2.first : r2.last, a2 = i2[0].findAncestor("table");
              n2.insertColumns(a2, { columns: 1, at: o2 ? s2 : s2 + 1 });
            }
          }
          class nC extends me {
            constructor(t3, e3 = {}) {
              super(t3), this.direction = e3.direction || "horizontally";
            }
            refresh() {
              const t3 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
              this.isEnabled = 1 === t3.length;
            }
            execute() {
              const t3 = this.editor.plugins.get("TableUtils"), e3 = t3.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
              "horizontally" === this.direction ? t3.splitCellHorizontally(e3, 2) : t3.splitCellVertically(e3, 2);
            }
          }
          function oC(t3, e3, n2) {
            const { startRow: o2, startColumn: i2, endRow: r2, endColumn: s2 } = e3, a2 = n2.createElement("table"), c2 = r2 - o2 + 1;
            for (let t4 = 0; t4 < c2; t4++)
              n2.insertElement("tableRow", a2, "end");
            const l2 = [...new Yw(t3, { startRow: o2, endRow: r2, startColumn: i2, endColumn: s2, includeAllSlots: true })];
            for (const { row: t4, column: e4, cell: c3, isAnchor: d2, cellAnchorRow: h2, cellAnchorColumn: u2 } of l2) {
              const l3 = t4 - o2, g2 = a2.getChild(l3);
              if (d2) {
                const o3 = n2.cloneElement(c3);
                n2.append(o3, g2), cC(o3, t4, e4, r2, s2, n2);
              } else
                (h2 < o2 || u2 < i2) && Uw(n2, n2.createPositionAt(g2, "end"));
            }
            return function(t4, e4, n3, o3, i3) {
              const r3 = parseInt(e4.getAttribute("headingRows") || 0);
              if (r3 > 0) {
                Vw("headingRows", r3 - n3, t4, i3, 0);
              }
              const s3 = parseInt(e4.getAttribute("headingColumns") || 0);
              if (s3 > 0) {
                Vw("headingColumns", s3 - o3, t4, i3, 0);
              }
            }(a2, t3, o2, i2, n2), a2;
          }
          function iC(t3, e3, n2 = 0) {
            const o2 = [], i2 = new Yw(t3, { startRow: n2, endRow: e3 - 1 });
            for (const t4 of i2) {
              const { row: n3, cellHeight: i3 } = t4, r2 = n3 + i3 - 1;
              n3 < e3 && e3 <= r2 && o2.push(t4);
            }
            return o2;
          }
          function rC(t3, e3, n2) {
            const o2 = t3.parent, i2 = o2.parent, r2 = o2.index, s2 = e3 - r2, a2 = {}, c2 = parseInt(t3.getAttribute("rowspan")) - s2;
            c2 > 1 && (a2.rowspan = c2);
            const l2 = parseInt(t3.getAttribute("colspan") || 1);
            l2 > 1 && (a2.colspan = l2);
            const d2 = r2 + s2, h2 = [...new Yw(i2, { startRow: r2, endRow: d2, includeAllSlots: true })];
            let u2, g2 = null;
            for (const e4 of h2) {
              const { row: o3, column: i3, cell: r3 } = e4;
              r3 === t3 && void 0 === u2 && (u2 = i3), void 0 !== u2 && u2 === i3 && o3 === d2 && (g2 = Uw(n2, e4.getPositionBefore(), a2));
            }
            return Vw("rowspan", s2, t3, n2), g2;
          }
          function sC(t3, e3) {
            const n2 = [], o2 = new Yw(t3);
            for (const t4 of o2) {
              const { column: o3, cellWidth: i2 } = t4, r2 = o3 + i2 - 1;
              o3 < e3 && e3 <= r2 && n2.push(t4);
            }
            return n2;
          }
          function aC(t3, e3, n2, o2) {
            const i2 = n2 - e3, r2 = {}, s2 = parseInt(t3.getAttribute("colspan")) - i2;
            s2 > 1 && (r2.colspan = s2);
            const a2 = parseInt(t3.getAttribute("rowspan") || 1);
            a2 > 1 && (r2.rowspan = a2);
            const c2 = Uw(o2, o2.createPositionAfter(t3), r2);
            return Vw("colspan", i2, t3, o2), c2;
          }
          function cC(t3, e3, n2, o2, i2, r2) {
            const s2 = parseInt(t3.getAttribute("colspan") || 1), a2 = parseInt(t3.getAttribute("rowspan") || 1);
            if (n2 + s2 - 1 > i2) {
              Vw("colspan", i2 - n2 + 1, t3, r2, 1);
            }
            if (e3 + a2 - 1 > o2) {
              Vw("rowspan", o2 - e3 + 1, t3, r2, 1);
            }
          }
          function lC(t3, e3) {
            const n2 = e3.getColumns(t3), o2 = new Array(n2).fill(0);
            for (const { column: e4 } of new Yw(t3))
              o2[e4]++;
            const i2 = o2.reduce((t4, e4, n3) => e4 ? t4 : [...t4, n3], []);
            if (i2.length > 0) {
              const n3 = i2[i2.length - 1];
              return e3.removeColumns(t3, { at: n3 }), true;
            }
            return false;
          }
          function dC(t3, e3) {
            const n2 = [], o2 = e3.getRows(t3);
            for (let e4 = 0; e4 < o2; e4++) {
              t3.getChild(e4).isEmpty && n2.push(e4);
            }
            if (n2.length > 0) {
              const o3 = n2[n2.length - 1];
              return e3.removeRows(t3, { at: o3 }), true;
            }
            return false;
          }
          function hC(t3, e3) {
            lC(t3, e3) || dC(t3, e3);
          }
          function uC(t3, e3) {
            const n2 = Array.from(new Yw(t3, { startColumn: e3.firstColumn, endColumn: e3.lastColumn, row: e3.lastRow }));
            if (n2.every(({ cellHeight: t4 }) => 1 === t4))
              return e3.lastRow;
            const o2 = n2[0].cellHeight - 1;
            return e3.lastRow + o2;
          }
          function gC(t3, e3) {
            const n2 = Array.from(new Yw(t3, { startRow: e3.firstRow, endRow: e3.lastRow, column: e3.lastColumn }));
            if (n2.every(({ cellWidth: t4 }) => 1 === t4))
              return e3.lastColumn;
            const o2 = n2[0].cellWidth - 1;
            return e3.lastColumn + o2;
          }
          class mC extends me {
            constructor(t3, e3) {
              super(t3), this.direction = e3.direction, this.isHorizontal = "right" == this.direction || "left" == this.direction;
            }
            refresh() {
              const t3 = this._getMergeableCell();
              this.value = t3, this.isEnabled = !!t3;
            }
            execute() {
              const t3 = this.editor.model, e3 = t3.document, n2 = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e3.selection)[0], o2 = this.value, i2 = this.direction;
              t3.change((t4) => {
                const e4 = "right" == i2 || "down" == i2, r2 = e4 ? n2 : o2, s2 = e4 ? o2 : n2, a2 = s2.parent;
                !function(t5, e5, n3) {
                  pC(t5) || (pC(e5) && n3.remove(n3.createRangeIn(e5)), n3.move(n3.createRangeIn(t5), n3.createPositionAt(e5, "end")));
                  n3.remove(t5);
                }(s2, r2, t4);
                const c2 = this.isHorizontal ? "colspan" : "rowspan", l2 = parseInt(n2.getAttribute(c2) || 1), d2 = parseInt(o2.getAttribute(c2) || 1);
                t4.setAttribute(c2, l2 + d2, r2), t4.setSelection(t4.createRangeIn(r2));
                const h2 = this.editor.plugins.get("TableUtils");
                hC(a2.findAncestor("table"), h2);
              });
            }
            _getMergeableCell() {
              const t3 = this.editor.model.document, e3 = this.editor.plugins.get("TableUtils"), n2 = e3.getTableCellsContainingSelection(t3.selection)[0];
              if (!n2)
                return;
              const o2 = this.isHorizontal ? function(t4, e4, n3) {
                const o3 = t4.parent.parent, i3 = "right" == e4 ? t4.nextSibling : t4.previousSibling, r3 = (o3.getAttribute("headingColumns") || 0) > 0;
                if (!i3)
                  return;
                const s2 = "right" == e4 ? t4 : i3, a2 = "right" == e4 ? i3 : t4, { column: c2 } = n3.getCellLocation(s2), { column: l2 } = n3.getCellLocation(a2), d2 = parseInt(s2.getAttribute("colspan") || 1), h2 = Hw(n3, s2), u2 = Hw(n3, a2);
                if (r3 && h2 != u2)
                  return;
                return c2 + d2 === l2 ? i3 : void 0;
              }(n2, this.direction, e3) : function(t4, e4, n3) {
                const o3 = t4.parent, i3 = o3.parent, r3 = i3.getChildIndex(o3);
                if ("down" == e4 && r3 === n3.getRows(i3) - 1 || "up" == e4 && 0 === r3)
                  return;
                const s2 = parseInt(t4.getAttribute("rowspan") || 1), a2 = i3.getAttribute("headingRows") || 0, c2 = "down" == e4 && r3 + s2 === a2, l2 = "up" == e4 && r3 === a2;
                if (a2 && (c2 || l2))
                  return;
                const d2 = parseInt(t4.getAttribute("rowspan") || 1), h2 = "down" == e4 ? r3 + d2 : r3, u2 = [...new Yw(i3, { endRow: h2 })], g2 = u2.find((e5) => e5.cell === t4).column, m2 = u2.find(({ row: t5, cellHeight: n4, column: o4 }) => o4 === g2 && ("down" == e4 ? t5 === h2 : h2 === t5 + n4));
                return m2 && m2.cell;
              }(n2, this.direction, e3);
              if (!o2)
                return;
              const i2 = this.isHorizontal ? "rowspan" : "colspan", r2 = parseInt(n2.getAttribute(i2) || 1);
              return parseInt(o2.getAttribute(i2) || 1) === r2 ? o2 : void 0;
            }
          }
          function pC(t3) {
            return 1 == t3.childCount && t3.getChild(0).is("element", "paragraph") && t3.getChild(0).isEmpty;
          }
          class fC extends me {
            refresh() {
              const t3 = this.editor.plugins.get("TableUtils"), e3 = t3.getSelectionAffectedTableCells(this.editor.model.document.selection), n2 = e3[0];
              if (n2) {
                const o2 = n2.findAncestor("table"), i2 = this.editor.plugins.get("TableUtils").getRows(o2) - 1, r2 = t3.getRowIndexes(e3), s2 = 0 === r2.first && r2.last === i2;
                this.isEnabled = !s2;
              } else
                this.isEnabled = false;
            }
            execute() {
              const t3 = this.editor.model, e3 = this.editor.plugins.get("TableUtils"), n2 = e3.getSelectionAffectedTableCells(t3.document.selection), o2 = e3.getRowIndexes(n2), i2 = n2[0], r2 = i2.findAncestor("table"), s2 = e3.getCellLocation(i2).column;
              t3.change((t4) => {
                const n3 = o2.last - o2.first + 1;
                e3.removeRows(r2, { at: o2.first, rows: n3 });
                const i3 = function(t5, e4, n4, o3) {
                  const i4 = t5.getChild(Math.min(e4, o3 - 1));
                  let r3 = i4.getChild(0), s3 = 0;
                  for (const t6 of i4.getChildren()) {
                    if (s3 > n4)
                      return r3;
                    r3 = t6, s3 += parseInt(t6.getAttribute("colspan") || 1);
                  }
                  return r3;
                }(r2, o2.first, s2, e3.getRows(r2));
                t4.setSelection(t4.createPositionAt(i3, 0));
              });
            }
          }
          class kC extends me {
            refresh() {
              const t3 = this.editor.plugins.get("TableUtils"), e3 = t3.getSelectionAffectedTableCells(this.editor.model.document.selection), n2 = e3[0];
              if (n2) {
                const o2 = n2.findAncestor("table"), i2 = t3.getColumns(o2), { first: r2, last: s2 } = t3.getColumnIndexes(e3);
                this.isEnabled = s2 - r2 < i2 - 1;
              } else
                this.isEnabled = false;
            }
            execute() {
              const t3 = this.editor.plugins.get("TableUtils"), [e3, n2] = function(t4, e4) {
                const n3 = e4.getSelectionAffectedTableCells(t4), o3 = n3[0], i3 = n3.pop(), r3 = [o3, i3];
                return o3.isBefore(i3) ? r3 : r3.reverse();
              }(this.editor.model.document.selection, t3), o2 = e3.parent.parent, i2 = [...new Yw(o2)], r2 = { first: i2.find((t4) => t4.cell === e3).column, last: i2.find((t4) => t4.cell === n2).column }, s2 = function(t4, e4, n3, o3) {
                return parseInt(n3.getAttribute("colspan") || 1) > 1 ? n3 : e4.previousSibling || n3.nextSibling ? n3.nextSibling || e4.previousSibling : o3.first ? t4.reverse().find(({ column: t5 }) => t5 < o3.first).cell : t4.reverse().find(({ column: t5 }) => t5 > o3.last).cell;
              }(i2, e3, n2, r2);
              this.editor.model.change((t4) => {
                const e4 = r2.last - r2.first + 1;
                this.editor.plugins.get("TableUtils").removeColumns(o2, { at: r2.first, columns: e4 }), t4.setSelection(t4.createPositionAt(s2, 0));
              });
            }
          }
          class bC extends me {
            refresh() {
              const t3 = this.editor.plugins.get("TableUtils"), e3 = this.editor.model, n2 = t3.getSelectionAffectedTableCells(e3.document.selection), o2 = n2.length > 0;
              this.isEnabled = o2, this.value = o2 && n2.every((t4) => this._isInHeading(t4, t4.parent.parent));
            }
            execute(t3 = {}) {
              if (t3.forceValue === this.value)
                return;
              const e3 = this.editor.plugins.get("TableUtils"), n2 = this.editor.model, o2 = e3.getSelectionAffectedTableCells(n2.document.selection), i2 = o2[0].findAncestor("table"), { first: r2, last: s2 } = e3.getRowIndexes(o2), a2 = this.value ? r2 : s2 + 1, c2 = i2.getAttribute("headingRows") || 0;
              n2.change((t4) => {
                if (a2) {
                  const e4 = iC(i2, a2, a2 > c2 ? c2 : 0);
                  for (const { cell: n3 } of e4)
                    rC(n3, a2, t4);
                }
                Vw("headingRows", a2, i2, t4, 0);
              });
            }
            _isInHeading(t3, e3) {
              const n2 = parseInt(e3.getAttribute("headingRows") || 0);
              return !!n2 && t3.parent.index < n2;
            }
          }
          class wC extends me {
            refresh() {
              const t3 = this.editor.model, e3 = this.editor.plugins.get("TableUtils"), n2 = e3.getSelectionAffectedTableCells(t3.document.selection), o2 = n2.length > 0;
              this.isEnabled = o2, this.value = o2 && n2.every((t4) => Hw(e3, t4));
            }
            execute(t3 = {}) {
              if (t3.forceValue === this.value)
                return;
              const e3 = this.editor.plugins.get("TableUtils"), n2 = this.editor.model, o2 = e3.getSelectionAffectedTableCells(n2.document.selection), i2 = o2[0].findAncestor("table"), { first: r2, last: s2 } = e3.getColumnIndexes(o2), a2 = this.value ? r2 : s2 + 1;
              n2.change((t4) => {
                if (a2) {
                  const e4 = sC(i2, a2);
                  for (const { cell: n3, column: o3 } of e4)
                    aC(n3, o3, a2, t4);
                }
                Vw("headingColumns", a2, i2, t4, 0);
              });
            }
          }
          class CC extends ue {
            static get pluginName() {
              return "TableUtils";
            }
            init() {
              this.decorate("insertColumns"), this.decorate("insertRows");
            }
            getCellLocation(t3) {
              const e3 = t3.parent, n2 = e3.parent, o2 = n2.getChildIndex(e3), i2 = new Yw(n2, { row: o2 });
              for (const { cell: e4, row: n3, column: o3 } of i2)
                if (e4 === t3)
                  return { row: n3, column: o3 };
            }
            createTable(t3, e3) {
              const n2 = t3.createElement("table"), o2 = parseInt(e3.rows) || 2, i2 = parseInt(e3.columns) || 2;
              return AC(t3, n2, 0, o2, i2), e3.headingRows && Vw("headingRows", Math.min(e3.headingRows, o2), n2, t3, 0), e3.headingColumns && Vw("headingColumns", Math.min(e3.headingColumns, i2), n2, t3, 0), n2;
            }
            insertRows(t3, e3 = {}) {
              const n2 = this.editor.model, o2 = e3.at || 0, i2 = e3.rows || 1, r2 = void 0 !== e3.copyStructureFromAbove, s2 = e3.copyStructureFromAbove ? o2 - 1 : o2, c2 = this.getRows(t3), l2 = this.getColumns(t3);
              if (o2 > c2)
                throw new a("tableutils-insertrows-insert-out-of-range", this, { options: e3 });
              n2.change((e4) => {
                const n3 = t3.getAttribute("headingRows") || 0;
                if (n3 > o2 && Vw("headingRows", n3 + i2, t3, e4, 0), !r2 && (0 === o2 || o2 === c2))
                  return void AC(e4, t3, o2, i2, l2);
                const a2 = r2 ? Math.max(o2, s2) : o2, d2 = new Yw(t3, { endRow: a2 }), h2 = new Array(l2).fill(1);
                for (const { row: t4, column: n4, cellHeight: a3, cellWidth: c3, cell: l3 } of d2) {
                  const d3 = t4 + a3 - 1, u2 = t4 <= s2 && s2 <= d3;
                  t4 < o2 && o2 <= d3 ? (e4.setAttribute("rowspan", a3 + i2, l3), h2[n4] = -c3) : r2 && u2 && (h2[n4] = c3);
                }
                for (let n4 = 0; n4 < i2; n4++) {
                  const n5 = e4.createElement("tableRow");
                  e4.insert(n5, t3, o2);
                  for (let t4 = 0; t4 < h2.length; t4++) {
                    const o3 = h2[t4], i3 = e4.createPositionAt(n5, "end");
                    o3 > 0 && Uw(e4, i3, o3 > 1 ? { colspan: o3 } : null), t4 += Math.abs(o3) - 1;
                  }
                }
              });
            }
            insertColumns(t3, e3 = {}) {
              const n2 = this.editor.model, o2 = e3.at || 0, i2 = e3.columns || 1;
              n2.change((e4) => {
                const n3 = t3.getAttribute("headingColumns");
                o2 < n3 && e4.setAttribute("headingColumns", n3 + i2, t3);
                const r2 = this.getColumns(t3);
                if (0 === o2 || r2 === o2) {
                  for (const n4 of t3.getChildren())
                    n4.is("element", "tableRow") && _C(i2, e4, e4.createPositionAt(n4, o2 ? "end" : 0));
                  return;
                }
                const s2 = new Yw(t3, { column: o2, includeAllSlots: true });
                for (const t4 of s2) {
                  const { row: n4, cell: r3, cellAnchorColumn: a2, cellAnchorRow: c2, cellWidth: l2, cellHeight: d2 } = t4;
                  if (a2 < o2) {
                    e4.setAttribute("colspan", l2 + i2, r3);
                    const t5 = c2 + d2 - 1;
                    for (let e5 = n4; e5 <= t5; e5++)
                      s2.skipRow(e5);
                  } else
                    _C(i2, e4, t4.getPositionBefore());
                }
              });
            }
            removeRows(t3, e3) {
              const n2 = this.editor.model, o2 = e3.rows || 1, i2 = this.getRows(t3), r2 = e3.at, s2 = r2 + o2 - 1;
              if (s2 > i2 - 1)
                throw new a("tableutils-removerows-row-index-out-of-range", this, { table: t3, options: e3 });
              n2.change((e4) => {
                const { cellsToMove: n3, cellsToTrim: o3 } = function(t4, e5, n4) {
                  const o4 = /* @__PURE__ */ new Map(), i3 = [];
                  for (const { row: r3, column: s3, cellHeight: a2, cell: c2 } of new Yw(t4, { endRow: n4 })) {
                    const t5 = r3 + a2 - 1;
                    if (r3 >= e5 && r3 <= n4 && t5 > n4) {
                      const t6 = a2 - (n4 - r3 + 1);
                      o4.set(s3, { cell: c2, rowspan: t6 });
                    }
                    if (r3 < e5 && t5 >= e5) {
                      let o5;
                      o5 = t5 >= n4 ? n4 - e5 + 1 : t5 - e5 + 1, i3.push({ cell: c2, rowspan: a2 - o5 });
                    }
                  }
                  return { cellsToMove: o4, cellsToTrim: i3 };
                }(t3, r2, s2);
                if (n3.size) {
                  !function(t4, e5, n4, o4) {
                    const i3 = [...new Yw(t4, { includeAllSlots: true, row: e5 })], r3 = t4.getChild(e5);
                    let s3;
                    for (const { column: t5, cell: e6, isAnchor: a2 } of i3)
                      if (n4.has(t5)) {
                        const { cell: e7, rowspan: i4 } = n4.get(t5), a3 = s3 ? o4.createPositionAfter(s3) : o4.createPositionAt(r3, 0);
                        o4.move(o4.createRangeOn(e7), a3), Vw("rowspan", i4, e7, o4), s3 = e7;
                      } else
                        a2 && (s3 = e6);
                  }(t3, s2 + 1, n3, e4);
                }
                for (let n4 = s2; n4 >= r2; n4--)
                  e4.remove(t3.getChild(n4));
                for (const { rowspan: t4, cell: n4 } of o3)
                  Vw("rowspan", t4, n4, e4);
                !function(t4, e5, n4, o4) {
                  const i3 = t4.getAttribute("headingRows") || 0;
                  if (e5 < i3) {
                    Vw("headingRows", n4 < i3 ? i3 - (n4 - e5 + 1) : e5, t4, o4, 0);
                  }
                }(t3, r2, s2, e4), lC(t3, this) || dC(t3, this);
              });
            }
            removeColumns(t3, e3) {
              const n2 = this.editor.model, o2 = e3.at, i2 = e3.columns || 1, r2 = e3.at + i2 - 1;
              n2.change((e4) => {
                !function(t4, e5, n3) {
                  const o3 = t4.getAttribute("headingColumns") || 0;
                  if (o3 && e5.first < o3) {
                    const i3 = Math.min(o3 - 1, e5.last) - e5.first + 1;
                    n3.setAttribute("headingColumns", o3 - i3, t4);
                  }
                }(t3, { first: o2, last: r2 }, e4);
                for (let n3 = r2; n3 >= o2; n3--)
                  for (const { cell: o3, column: i3, cellWidth: r3 } of [...new Yw(t3)])
                    i3 <= n3 && r3 > 1 && i3 + r3 > n3 ? Vw("colspan", r3 - 1, o3, e4) : i3 === n3 && e4.remove(o3);
                dC(t3, this) || lC(t3, this);
              });
            }
            splitCellVertically(t3, e3 = 2) {
              const n2 = this.editor.model, o2 = t3.parent.parent, i2 = parseInt(t3.getAttribute("rowspan") || 1), r2 = parseInt(t3.getAttribute("colspan") || 1);
              n2.change((n3) => {
                if (r2 > 1) {
                  const { newCellsSpan: o3, updatedSpan: s2 } = vC(r2, e3);
                  Vw("colspan", s2, t3, n3);
                  const a2 = {};
                  o3 > 1 && (a2.colspan = o3), i2 > 1 && (a2.rowspan = i2);
                  _C(r2 > e3 ? e3 - 1 : r2 - 1, n3, n3.createPositionAfter(t3), a2);
                }
                if (r2 < e3) {
                  const s2 = e3 - r2, a2 = [...new Yw(o2)], { column: c2 } = a2.find(({ cell: e4 }) => e4 === t3), l2 = a2.filter(({ cell: e4, cellWidth: n4, column: o3 }) => e4 !== t3 && o3 === c2 || o3 < c2 && o3 + n4 > c2);
                  for (const { cell: t4, cellWidth: e4 } of l2)
                    n3.setAttribute("colspan", e4 + s2, t4);
                  const d2 = {};
                  i2 > 1 && (d2.rowspan = i2), _C(s2, n3, n3.createPositionAfter(t3), d2);
                  const h2 = o2.getAttribute("headingColumns") || 0;
                  h2 > c2 && Vw("headingColumns", h2 + s2, o2, n3);
                }
              });
            }
            splitCellHorizontally(t3, e3 = 2) {
              const n2 = this.editor.model, o2 = t3.parent, i2 = o2.parent, r2 = i2.getChildIndex(o2), s2 = parseInt(t3.getAttribute("rowspan") || 1), a2 = parseInt(t3.getAttribute("colspan") || 1);
              n2.change((n3) => {
                if (s2 > 1) {
                  const o3 = [...new Yw(i2, { startRow: r2, endRow: r2 + s2 - 1, includeAllSlots: true })], { newCellsSpan: c2, updatedSpan: l2 } = vC(s2, e3);
                  Vw("rowspan", l2, t3, n3);
                  const { column: d2 } = o3.find(({ cell: e4 }) => e4 === t3), h2 = {};
                  c2 > 1 && (h2.rowspan = c2), a2 > 1 && (h2.colspan = a2);
                  for (const t4 of o3) {
                    const { column: e4, row: o4 } = t4, i3 = e4 === d2, s3 = (o4 + r2 + l2) % c2 == 0;
                    o4 >= r2 + l2 && i3 && s3 && _C(1, n3, t4.getPositionBefore(), h2);
                  }
                }
                if (s2 < e3) {
                  const o3 = e3 - s2, c2 = [...new Yw(i2, { startRow: 0, endRow: r2 })];
                  for (const { cell: e4, cellHeight: i3, row: s3 } of c2)
                    if (e4 !== t3 && s3 + i3 > r2) {
                      const t4 = i3 + o3;
                      n3.setAttribute("rowspan", t4, e4);
                    }
                  const l2 = {};
                  a2 > 1 && (l2.colspan = a2), AC(n3, i2, r2 + 1, o3, 1, l2);
                  const d2 = i2.getAttribute("headingRows") || 0;
                  d2 > r2 && Vw("headingRows", d2 + o3, i2, n3);
                }
              });
            }
            getColumns(t3) {
              return [...t3.getChild(0).getChildren()].reduce((t4, e3) => t4 + parseInt(e3.getAttribute("colspan") || 1), 0);
            }
            getRows(t3) {
              return Array.from(t3.getChildren()).reduce((t4, e3) => e3.is("element", "tableRow") ? t4 + 1 : t4, 0);
            }
            createTableWalker(t3, e3 = {}) {
              return new Yw(t3, e3);
            }
            getSelectedTableCells(t3) {
              const e3 = [];
              for (const n2 of this.sortRanges(t3.getRanges())) {
                const t4 = n2.getContainedElement();
                t4 && t4.is("element", "tableCell") && e3.push(t4);
              }
              return e3;
            }
            getTableCellsContainingSelection(t3) {
              const e3 = [];
              for (const n2 of t3.getRanges()) {
                const t4 = n2.start.findAncestor("tableCell");
                t4 && e3.push(t4);
              }
              return e3;
            }
            getSelectionAffectedTableCells(t3) {
              const e3 = this.getSelectedTableCells(t3);
              return e3.length ? e3 : this.getTableCellsContainingSelection(t3);
            }
            getRowIndexes(t3) {
              const e3 = t3.map((t4) => t4.parent.index);
              return this._getFirstLastIndexesObject(e3);
            }
            getColumnIndexes(t3) {
              const e3 = t3[0].findAncestor("table"), n2 = [...new Yw(e3)].filter((e4) => t3.includes(e4.cell)).map((t4) => t4.column);
              return this._getFirstLastIndexesObject(n2);
            }
            isSelectionRectangular(t3) {
              if (t3.length < 2 || !this._areCellInTheSameTableSection(t3))
                return false;
              const e3 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set();
              let o2 = 0;
              for (const i3 of t3) {
                const { row: t4, column: r2 } = this.getCellLocation(i3), s2 = parseInt(i3.getAttribute("rowspan") || 1), a2 = parseInt(i3.getAttribute("colspan") || 1);
                e3.add(t4), n2.add(r2), s2 > 1 && e3.add(t4 + s2 - 1), a2 > 1 && n2.add(r2 + a2 - 1), o2 += s2 * a2;
              }
              const i2 = function(t4, e4) {
                const n3 = Array.from(t4.values()), o3 = Array.from(e4.values()), i3 = Math.max(...n3), r2 = Math.min(...n3), s2 = Math.max(...o3), a2 = Math.min(...o3);
                return (i3 - r2 + 1) * (s2 - a2 + 1);
              }(e3, n2);
              return i2 == o2;
            }
            sortRanges(t3) {
              return Array.from(t3).sort(yC);
            }
            _getFirstLastIndexesObject(t3) {
              const e3 = t3.sort((t4, e4) => t4 - e4);
              return { first: e3[0], last: e3[e3.length - 1] };
            }
            _areCellInTheSameTableSection(t3) {
              const e3 = t3[0].findAncestor("table"), n2 = this.getRowIndexes(t3), o2 = parseInt(e3.getAttribute("headingRows") || 0);
              if (!this._areIndexesInSameSection(n2, o2))
                return false;
              const i2 = parseInt(e3.getAttribute("headingColumns") || 0), r2 = this.getColumnIndexes(t3);
              return this._areIndexesInSameSection(r2, i2);
            }
            _areIndexesInSameSection({ first: t3, last: e3 }, n2) {
              return t3 < n2 === e3 < n2;
            }
          }
          function AC(t3, e3, n2, o2, i2, r2 = {}) {
            for (let s2 = 0; s2 < o2; s2++) {
              const o3 = t3.createElement("tableRow");
              t3.insert(o3, e3, n2), _C(i2, t3, t3.createPositionAt(o3, "end"), r2);
            }
          }
          function _C(t3, e3, n2, o2 = {}) {
            for (let i2 = 0; i2 < t3; i2++)
              Uw(e3, n2, o2);
          }
          function vC(t3, e3) {
            if (t3 < e3)
              return { newCellsSpan: 1, updatedSpan: 1 };
            const n2 = Math.floor(t3 / e3);
            return { newCellsSpan: n2, updatedSpan: t3 - n2 * e3 + n2 };
          }
          function yC(t3, e3) {
            const n2 = t3.start, o2 = e3.start;
            return n2.isBefore(o2) ? -1 : 1;
          }
          class xC extends me {
            refresh() {
              const t3 = this.editor.plugins.get(CC), e3 = t3.getSelectedTableCells(this.editor.model.document.selection);
              this.isEnabled = t3.isSelectionRectangular(e3, this.editor.plugins.get(CC));
            }
            execute() {
              const t3 = this.editor.model, e3 = this.editor.plugins.get(CC);
              t3.change((n2) => {
                const o2 = e3.getSelectedTableCells(t3.document.selection), i2 = o2.shift(), { mergeWidth: r2, mergeHeight: s2 } = function(t4, e4, n3) {
                  let o3 = 0, i3 = 0;
                  for (const t5 of e4) {
                    const { row: e5, column: r4 } = n3.getCellLocation(t5);
                    o3 = IC(t5, r4, o3, "colspan"), i3 = IC(t5, e5, i3, "rowspan");
                  }
                  const { row: r3, column: s3 } = n3.getCellLocation(t4);
                  return { mergeWidth: o3 - s3, mergeHeight: i3 - r3 };
                }(i2, o2, e3);
                Vw("colspan", r2, i2, n2), Vw("rowspan", s2, i2, n2);
                for (const t4 of o2)
                  EC(t4, i2, n2);
                hC(i2.findAncestor("table"), e3), n2.setSelection(i2, "in");
              });
            }
          }
          function EC(t3, e3, n2) {
            DC(t3) || (DC(e3) && n2.remove(n2.createRangeIn(e3)), n2.move(n2.createRangeIn(t3), n2.createPositionAt(e3, "end"))), n2.remove(t3);
          }
          function DC(t3) {
            return 1 == t3.childCount && t3.getChild(0).is("element", "paragraph") && t3.getChild(0).isEmpty;
          }
          function IC(t3, e3, n2, o2) {
            const i2 = parseInt(t3.getAttribute(o2) || 1);
            return Math.max(n2, e3 + i2);
          }
          class MC extends me {
            constructor(t3) {
              super(t3), this.affectsData = false;
            }
            refresh() {
              const t3 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
              this.isEnabled = t3.length > 0;
            }
            execute() {
              const t3 = this.editor.model, e3 = this.editor.plugins.get("TableUtils"), n2 = e3.getSelectionAffectedTableCells(t3.document.selection), o2 = e3.getRowIndexes(n2), i2 = n2[0].findAncestor("table"), r2 = [];
              for (let e4 = o2.first; e4 <= o2.last; e4++)
                for (const n3 of i2.getChild(e4).getChildren())
                  r2.push(t3.createRangeOn(n3));
              t3.change((t4) => {
                t4.setSelection(r2);
              });
            }
          }
          class SC extends me {
            constructor(t3) {
              super(t3), this.affectsData = false;
            }
            refresh() {
              const t3 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
              this.isEnabled = t3.length > 0;
            }
            execute() {
              const t3 = this.editor.plugins.get("TableUtils"), e3 = this.editor.model, n2 = t3.getSelectionAffectedTableCells(e3.document.selection), o2 = n2[0], i2 = n2.pop(), r2 = o2.findAncestor("table"), s2 = t3.getCellLocation(o2), a2 = t3.getCellLocation(i2), c2 = Math.min(s2.column, a2.column), l2 = Math.max(s2.column, a2.column), d2 = [];
              for (const t4 of new Yw(r2, { startColumn: c2, endColumn: l2 }))
                d2.push(e3.createRangeOn(t4.cell));
              e3.change((t4) => {
                t4.setSelection(d2);
              });
            }
          }
          function TC(t3) {
            t3.document.registerPostFixer((e3) => function(t4, e4) {
              const n2 = e4.document.differ.getChanges();
              let o2 = false;
              const i2 = /* @__PURE__ */ new Set();
              for (const e5 of n2) {
                let n3;
                "table" == e5.name && "insert" == e5.type && (n3 = e5.position.nodeAfter), "tableRow" != e5.name && "tableCell" != e5.name || (n3 = e5.position.findAncestor("table")), zC(e5) && (n3 = e5.range.start.findAncestor("table")), n3 && !i2.has(n3) && (o2 = NC(n3, t4) || o2, o2 = BC(n3, t4) || o2, i2.add(n3));
              }
              return o2;
            }(e3, t3));
          }
          function NC(t3, e3) {
            let n2 = false;
            const o2 = function(t4) {
              const e4 = parseInt(t4.getAttribute("headingRows") || 0), n3 = Array.from(t4.getChildren()).reduce((t5, e5) => e5.is("element", "tableRow") ? t5 + 1 : t5, 0), o3 = [];
              for (const { row: i2, cell: r2, cellHeight: s2 } of new Yw(t4)) {
                if (s2 < 2)
                  continue;
                const t5 = i2 < e4 ? e4 : n3;
                if (i2 + s2 > t5) {
                  const e5 = t5 - i2;
                  o3.push({ cell: r2, rowspan: e5 });
                }
              }
              return o3;
            }(t3);
            if (o2.length) {
              n2 = true;
              for (const t4 of o2)
                Vw("rowspan", t4.rowspan, t4.cell, e3, 1);
            }
            return n2;
          }
          function BC(t3, e3) {
            let n2 = false;
            const o2 = function(t4) {
              const e4 = new Array(t4.childCount).fill(0);
              for (const { rowIndex: n3 } of new Yw(t4, { includeAllSlots: true }))
                e4[n3]++;
              return e4;
            }(t3), i2 = [];
            for (const [e4, n3] of o2.entries())
              !n3 && t3.getChild(e4).is("element", "tableRow") && i2.push(e4);
            if (i2.length) {
              n2 = true;
              for (const n3 of i2.reverse())
                e3.remove(t3.getChild(n3)), o2.splice(n3, 1);
            }
            const r2 = o2.filter((e4, n3) => t3.getChild(n3).is("element", "tableRow")), s2 = r2[0];
            if (!r2.every((t4) => t4 === s2)) {
              const o3 = r2.reduce((t4, e4) => e4 > t4 ? e4 : t4, 0);
              for (const [i3, s3] of r2.entries()) {
                const r3 = o3 - s3;
                if (r3) {
                  for (let n3 = 0; n3 < r3; n3++)
                    Uw(e3, e3.createPositionAt(t3.getChild(i3), "end"));
                  n2 = true;
                }
              }
            }
            return n2;
          }
          function zC(t3) {
            const e3 = "attribute" === t3.type, n2 = t3.attributeKey;
            return e3 && ("headingRows" === n2 || "colspan" === n2 || "rowspan" === n2);
          }
          function PC(t3) {
            t3.document.registerPostFixer((e3) => function(t4, e4) {
              const n2 = e4.document.differ.getChanges();
              let o2 = false;
              for (const e5 of n2)
                "insert" == e5.type && "table" == e5.name && (o2 = LC(e5.position.nodeAfter, t4) || o2), "insert" == e5.type && "tableRow" == e5.name && (o2 = OC(e5.position.nodeAfter, t4) || o2), "insert" == e5.type && "tableCell" == e5.name && (o2 = RC(e5.position.nodeAfter, t4) || o2), jC(e5) && (o2 = RC(e5.position.parent, t4) || o2);
              return o2;
            }(e3, t3));
          }
          function LC(t3, e3) {
            let n2 = false;
            for (const o2 of t3.getChildren())
              o2.is("element", "tableRow") && (n2 = OC(o2, e3) || n2);
            return n2;
          }
          function OC(t3, e3) {
            let n2 = false;
            for (const o2 of t3.getChildren())
              n2 = RC(o2, e3) || n2;
            return n2;
          }
          function RC(t3, e3) {
            if (0 == t3.childCount)
              return e3.insertElement("paragraph", t3), true;
            const n2 = Array.from(t3.getChildren()).filter((t4) => t4.is("$text"));
            for (const t4 of n2)
              e3.wrap(e3.createRangeOn(t4), "paragraph");
            return !!n2.length;
          }
          function jC(t3) {
            return !(!t3.position || !t3.position.parent.is("element", "tableCell")) && ("insert" == t3.type && "$text" == t3.name || "remove" == t3.type);
          }
          function FC(t3, e3) {
            if (!t3.is("element", "paragraph"))
              return false;
            const n2 = e3.toViewElement(t3);
            return !!n2 && Jw(t3) !== n2.is("element", "span");
          }
          var VC = n(3881), UC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(VC.Z, UC);
          VC.Z.locals;
          class HC extends ue {
            static get pluginName() {
              return "TableEditing";
            }
            static get requires() {
              return [CC];
            }
            init() {
              const t3 = this.editor, e3 = t3.model, n2 = e3.schema, o2 = t3.conversion, i2 = t3.plugins.get(CC);
              n2.register("table", { allowWhere: "$block", allowAttributes: ["headingRows", "headingColumns"], isObject: true, isBlock: true }), n2.register("tableRow", { allowIn: "table", isLimit: true }), n2.register("tableCell", { allowIn: "tableRow", allowChildren: "$block", allowAttributes: ["colspan", "rowspan"], isLimit: true, isSelectable: true }), o2.for("upcast").add((t4) => {
                t4.on("element:figure", (t5, e4, n3) => {
                  if (!n3.consumable.test(e4.viewItem, { name: true, classes: "table" }))
                    return;
                  const o3 = function(t6) {
                    for (const e5 of t6.getChildren())
                      if (e5.is("element", "table"))
                        return e5;
                  }(e4.viewItem);
                  if (!o3 || !n3.consumable.test(o3, { name: true }))
                    return;
                  n3.consumable.consume(e4.viewItem, { name: true, classes: "table" });
                  const i3 = Aa(n3.convertItem(o3, e4.modelCursor).modelRange.getItems());
                  i3 ? (n3.convertChildren(e4.viewItem, n3.writer.createPositionAt(i3, "end")), n3.updateConversionResult(i3, e4)) : n3.consumable.revert(e4.viewItem, { name: true, classes: "table" });
                });
              }), o2.for("upcast").add(qw()), o2.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: Kw(i2, { asWidget: true }) }), o2.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: Kw(i2) }), o2.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), o2.for("upcast").add((t4) => {
                t4.on("element:tr", (t5, e4) => {
                  e4.viewItem.isEmpty && 0 == e4.modelCursor.index && t5.stop();
                }, { priority: "high" });
              }), o2.for("downcast").elementToElement({ model: "tableRow", view: (t4, { writer: e4 }) => t4.isEmpty ? e4.createEmptyElement("tr") : e4.createContainerElement("tr") }), o2.for("upcast").elementToElement({ model: "tableCell", view: "td" }), o2.for("upcast").elementToElement({ model: "tableCell", view: "th" }), o2.for("upcast").add(Ww("td")), o2.for("upcast").add(Ww("th")), o2.for("editingDowncast").elementToElement({ model: "tableCell", view: $w({ asWidget: true }) }), o2.for("dataDowncast").elementToElement({ model: "tableCell", view: $w() }), o2.for("editingDowncast").elementToElement({ model: "paragraph", view: Zw({ asWidget: true }), converterPriority: "high" }), o2.for("dataDowncast").elementToElement({ model: "paragraph", view: Zw(), converterPriority: "high" }), o2.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), o2.for("upcast").attributeToAttribute({ model: { key: "colspan", value: qC("colspan") }, view: "colspan" }), o2.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), o2.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: qC("rowspan") }, view: "rowspan" }), t3.data.mapper.on("modelToViewPosition", (t4, e4) => {
                const n3 = e4.modelPosition.parent, o3 = e4.modelPosition.nodeBefore;
                if (!n3.is("element", "tableCell"))
                  return;
                if (!o3 || !o3.is("element", "paragraph"))
                  return;
                const i3 = e4.mapper.toViewElement(o3), r2 = e4.mapper.toViewElement(n3);
                i3 === r2 && (e4.viewPosition = e4.mapper.findPositionIn(r2, o3.maxOffset));
              }), t3.config.define("table.defaultHeadings.rows", 0), t3.config.define("table.defaultHeadings.columns", 0), t3.commands.add("insertTable", new Xw(t3)), t3.commands.add("insertTableRowAbove", new tC(t3, { order: "above" })), t3.commands.add("insertTableRowBelow", new tC(t3, { order: "below" })), t3.commands.add("insertTableColumnLeft", new eC(t3, { order: "left" })), t3.commands.add("insertTableColumnRight", new eC(t3, { order: "right" })), t3.commands.add("removeTableRow", new fC(t3)), t3.commands.add("removeTableColumn", new kC(t3)), t3.commands.add("splitTableCellVertically", new nC(t3, { direction: "vertically" })), t3.commands.add("splitTableCellHorizontally", new nC(t3, { direction: "horizontally" })), t3.commands.add("mergeTableCells", new xC(t3)), t3.commands.add("mergeTableCellRight", new mC(t3, { direction: "right" })), t3.commands.add("mergeTableCellLeft", new mC(t3, { direction: "left" })), t3.commands.add("mergeTableCellDown", new mC(t3, { direction: "down" })), t3.commands.add("mergeTableCellUp", new mC(t3, { direction: "up" })), t3.commands.add("setTableColumnHeader", new wC(t3)), t3.commands.add("setTableRowHeader", new bC(t3)), t3.commands.add("selectTableRow", new MC(t3)), t3.commands.add("selectTableColumn", new SC(t3)), TC(e3), PC(e3), this.listenTo(e3.document, "change:data", () => {
                !function(t4, e4) {
                  const n3 = t4.document.differ;
                  for (const t5 of n3.getChanges()) {
                    let n4, o3 = false;
                    if ("attribute" == t5.type) {
                      const e5 = t5.range.start.nodeAfter;
                      if (!e5 || !e5.is("element", "table"))
                        continue;
                      if ("headingRows" != t5.attributeKey && "headingColumns" != t5.attributeKey)
                        continue;
                      n4 = e5, o3 = "headingRows" == t5.attributeKey;
                    } else
                      "tableRow" != t5.name && "tableCell" != t5.name || (n4 = t5.position.findAncestor("table"), o3 = "tableRow" == t5.name);
                    if (!n4)
                      continue;
                    const i3 = n4.getAttribute("headingRows") || 0, r2 = n4.getAttribute("headingColumns") || 0, s2 = new Yw(n4);
                    for (const t6 of s2) {
                      const n5 = t6.row < i3 || t6.column < r2 ? "th" : "td", s3 = e4.mapper.toViewElement(t6.cell);
                      s3 && s3.is("element") && s3.name != n5 && e4.reconvertItem(o3 ? t6.cell.parent : t6.cell);
                    }
                  }
                }(e3, t3.editing), function(t4, e4) {
                  const n3 = t4.document.differ, o3 = /* @__PURE__ */ new Set();
                  for (const t5 of n3.getChanges()) {
                    const e5 = "attribute" == t5.type ? t5.range.start.parent : t5.position.parent;
                    e5.is("element", "tableCell") && o3.add(e5);
                  }
                  for (const t5 of o3.values()) {
                    const n4 = Array.from(t5.getChildren()).filter((t6) => FC(t6, e4.mapper));
                    for (const t6 of n4)
                      e4.reconvertItem(t6);
                  }
                }(e3, t3.editing);
              });
            }
          }
          function qC(t3) {
            return (e3) => {
              const n2 = parseInt(e3.getAttribute(t3));
              return Number.isNaN(n2) || n2 <= 0 ? null : n2;
            };
          }
          var WC = n(1613), GC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(WC.Z, GC);
          WC.Z.locals;
          class YC extends Ld {
            constructor(t3) {
              super(t3);
              const e3 = this.bindTemplate;
              this.items = this._createGridCollection(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (t4, e4) => `${e4} \xD7 ${t4}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": e3.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck-insert-table-dropdown__label"] }, children: [{ text: e3.to("label") }] }], on: { mousedown: e3.to((t4) => {
                t4.preventDefault();
              }), click: e3.to(() => {
                this.fire("execute");
              }) } }), this.on("boxover", (t4, e4) => {
                const { row: n2, column: o2 } = e4.target.dataset;
                this.set({ rows: parseInt(n2), columns: parseInt(o2) });
              }), this.on("change:columns", () => {
                this._highlightGridBoxes();
              }), this.on("change:rows", () => {
                this._highlightGridBoxes();
              });
            }
            focus() {
            }
            focusLast() {
            }
            _highlightGridBoxes() {
              const t3 = this.rows, e3 = this.columns;
              this.items.map((n2, o2) => {
                const i2 = Math.floor(o2 / 10) < t3 && o2 % 10 < e3;
                n2.set("isOn", i2);
              });
            }
            _createGridCollection() {
              const t3 = [];
              for (let e3 = 0; e3 < 100; e3++) {
                const n2 = Math.floor(e3 / 10), o2 = e3 % 10;
                t3.push(new QC(this.locale, n2 + 1, o2 + 1));
              }
              return this.createCollection(t3);
            }
          }
          class QC extends Ld {
            constructor(t3, e3, n2) {
              super(t3);
              const o2 = this.bindTemplate;
              this.set("isOn", false), this.setTemplate({ tag: "div", attributes: { class: ["ck-insert-table-dropdown-grid-box", o2.if("isOn", "ck-on")], "data-row": e3, "data-column": n2 } });
            }
          }
          class KC extends ue {
            static get pluginName() {
              return "TableUI";
            }
            init() {
              const t3 = this.editor, e3 = this.editor.t, n2 = "ltr" === t3.locale.contentLanguageDirection;
              t3.ui.componentFactory.add("insertTable", (n3) => {
                const o2 = t3.commands.get("insertTable"), i2 = Jh(n3);
                let r2;
                return i2.bind("isEnabled").to(o2), i2.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: e3("Insert table"), tooltip: true }), i2.on("change:isOpen", () => {
                  r2 || (r2 = new YC(n3), i2.panelView.children.add(r2), r2.delegate("execute").to(i2), i2.buttonView.on("open", () => {
                    r2.rows = 0, r2.columns = 0;
                  }), i2.on("execute", () => {
                    t3.execute("insertTable", { rows: r2.rows, columns: r2.columns }), t3.editing.view.focus();
                  }));
                }), i2;
              }), t3.ui.componentFactory.add("tableColumn", (t4) => {
                const o2 = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: e3("Header column"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: n2 ? "insertTableColumnLeft" : "insertTableColumnRight", label: e3("Insert column left") } }, { type: "button", model: { commandName: n2 ? "insertTableColumnRight" : "insertTableColumnLeft", label: e3("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: e3("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: e3("Select column") } }];
                return this._prepareDropdown(e3("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', o2, t4);
              }), t3.ui.componentFactory.add("tableRow", (t4) => {
                const n3 = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: e3("Header row"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: e3("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: e3("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: e3("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: e3("Select row") } }];
                return this._prepareDropdown(e3("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', n3, t4);
              }), t3.ui.componentFactory.add("mergeTableCells", (t4) => {
                const o2 = [{ type: "button", model: { commandName: "mergeTableCellUp", label: e3("Merge cell up") } }, { type: "button", model: { commandName: n2 ? "mergeTableCellRight" : "mergeTableCellLeft", label: e3("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: e3("Merge cell down") } }, { type: "button", model: { commandName: n2 ? "mergeTableCellLeft" : "mergeTableCellRight", label: e3("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: e3("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: e3("Split cell horizontally") } }];
                return this._prepareMergeSplitButtonDropdown(e3("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', o2, t4);
              });
            }
            _prepareDropdown(t3, e3, n2, o2) {
              const i2 = this.editor, r2 = Jh(o2), s2 = this._fillDropdownWithListOptions(r2, n2);
              return r2.buttonView.set({ label: t3, icon: e3, tooltip: true }), r2.bind("isEnabled").toMany(s2, "isEnabled", (...t4) => t4.some((t5) => t5)), this.listenTo(r2, "execute", (t4) => {
                i2.execute(t4.source.commandName), i2.editing.view.focus();
              }), r2;
            }
            _prepareMergeSplitButtonDropdown(t3, e3, n2, o2) {
              const i2 = this.editor, r2 = Jh(o2, vh), s2 = "mergeTableCells", a2 = i2.commands.get(s2), c2 = this._fillDropdownWithListOptions(r2, n2);
              return r2.buttonView.set({ label: t3, icon: e3, tooltip: true, isEnabled: true }), r2.bind("isEnabled").toMany([a2, ...c2], "isEnabled", (...t4) => t4.some((t5) => t5)), this.listenTo(r2.buttonView, "execute", () => {
                i2.execute(s2), i2.editing.view.focus();
              }), this.listenTo(r2, "execute", (t4) => {
                i2.execute(t4.source.commandName), i2.editing.view.focus();
              }), r2;
            }
            _fillDropdownWithListOptions(t3, e3) {
              const n2 = this.editor, o2 = [], i2 = new Io();
              for (const t4 of e3)
                $C(t4, n2, o2, i2);
              return tu(t3, i2, n2.ui.componentFactory), o2;
            }
          }
          function $C(t3, e3, n2, o2) {
            const i2 = t3.model = new Au(t3.model), { commandName: r2, bindIsOn: s2 } = t3.model;
            if ("button" === t3.type || "switchbutton" === t3.type) {
              const t4 = e3.commands.get(r2);
              n2.push(t4), i2.set({ commandName: r2 }), i2.bind("isEnabled").to(t4), s2 && i2.bind("isOn").to(t4, "value");
            }
            i2.set({ withText: true }), o2.add(t3);
          }
          var ZC = n(6945), JC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(ZC.Z, JC);
          ZC.Z.locals;
          class XC extends ue {
            static get pluginName() {
              return "TableSelection";
            }
            static get requires() {
              return [CC, CC];
            }
            init() {
              const t3 = this.editor.model;
              this.listenTo(t3, "deleteContent", (t4, e3) => this._handleDeleteContent(t4, e3), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
            }
            getSelectedTableCells() {
              const t3 = this.editor.plugins.get(CC), e3 = this.editor.model.document.selection, n2 = t3.getSelectedTableCells(e3);
              return 0 == n2.length ? null : n2;
            }
            getSelectionAsFragment() {
              const t3 = this.editor.plugins.get(CC), e3 = this.getSelectedTableCells();
              return e3 ? this.editor.model.change((n2) => {
                const o2 = n2.createDocumentFragment(), { first: i2, last: r2 } = t3.getColumnIndexes(e3), { first: s2, last: a2 } = t3.getRowIndexes(e3), c2 = e3[0].findAncestor("table");
                let l2 = a2, d2 = r2;
                if (t3.isSelectionRectangular(e3)) {
                  const t4 = { firstColumn: i2, lastColumn: r2, firstRow: s2, lastRow: a2 };
                  l2 = uC(c2, t4), d2 = gC(c2, t4);
                }
                const h2 = oC(c2, { startRow: s2, startColumn: i2, endRow: l2, endColumn: d2 }, n2);
                return n2.insert(h2, o2, 0), o2;
              }) : null;
            }
            setCellSelection(t3, e3) {
              const n2 = this._getCellsToSelect(t3, e3);
              this.editor.model.change((t4) => {
                t4.setSelection(n2.cells.map((e4) => t4.createRangeOn(e4)), { backward: n2.backward });
              });
            }
            getFocusCell() {
              const t3 = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
              return t3 && t3.is("element", "tableCell") ? t3 : null;
            }
            getAnchorCell() {
              const t3 = Aa(this.editor.model.document.selection.getRanges()).getContainedElement();
              return t3 && t3.is("element", "tableCell") ? t3 : null;
            }
            _defineSelectionConverter() {
              const t3 = this.editor, e3 = /* @__PURE__ */ new Set();
              t3.conversion.for("editingDowncast").add((t4) => t4.on("selection", (t5, n2, o2) => {
                const i2 = o2.writer;
                !function(t6) {
                  for (const n3 of e3)
                    t6.removeClass("ck-editor__editable_selected", n3);
                  e3.clear();
                }(i2);
                const r2 = this.getSelectedTableCells();
                if (!r2)
                  return;
                for (const t6 of r2) {
                  const n3 = o2.mapper.toViewElement(t6);
                  i2.addClass("ck-editor__editable_selected", n3), e3.add(n3);
                }
                const s2 = o2.mapper.toViewElement(r2[r2.length - 1]);
                i2.setSelection(s2, 0);
              }, { priority: "lowest" }));
            }
            _enablePluginDisabling() {
              const t3 = this.editor;
              this.on("change:isEnabled", () => {
                if (!this.isEnabled) {
                  const e3 = this.getSelectedTableCells();
                  if (!e3)
                    return;
                  t3.model.change((n2) => {
                    const o2 = n2.createPositionAt(e3[0], 0), i2 = t3.model.schema.getNearestSelectionRange(o2);
                    n2.setSelection(i2);
                  });
                }
              });
            }
            _handleDeleteContent(t3, e3) {
              const n2 = this.editor.plugins.get(CC), [o2, i2] = e3, r2 = this.editor.model, s2 = !i2 || "backward" == i2.direction, a2 = n2.getSelectedTableCells(o2);
              a2.length && (t3.stop(), r2.change((t4) => {
                const e4 = a2[s2 ? a2.length - 1 : 0];
                r2.change((t5) => {
                  for (const e5 of a2)
                    r2.deleteContent(t5.createSelection(e5, "in"));
                });
                const n3 = r2.schema.getNearestSelectionRange(t4.createPositionAt(e4, 0));
                o2.is("documentSelection") ? t4.setSelection(n3) : o2.setTo(n3);
              }));
            }
            _getCellsToSelect(t3, e3) {
              const n2 = this.editor.plugins.get("TableUtils"), o2 = n2.getCellLocation(t3), i2 = n2.getCellLocation(e3), r2 = Math.min(o2.row, i2.row), s2 = Math.max(o2.row, i2.row), a2 = Math.min(o2.column, i2.column), c2 = Math.max(o2.column, i2.column), l2 = new Array(s2 - r2 + 1).fill(null).map(() => []), d2 = { startRow: r2, endRow: s2, startColumn: a2, endColumn: c2 };
              for (const { row: e4, cell: n3 } of new Yw(t3.findAncestor("table"), d2))
                l2[e4 - r2].push(n3);
              const h2 = i2.row < o2.row, u2 = i2.column < o2.column;
              return h2 && l2.reverse(), u2 && l2.forEach((t4) => t4.reverse()), { cells: l2.flat(), backward: h2 || u2 };
            }
          }
          class tA extends ue {
            static get pluginName() {
              return "TableClipboard";
            }
            static get requires() {
              return [XC, CC];
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view.document;
              this.listenTo(e3, "copy", (t4, e4) => this._onCopyCut(t4, e4)), this.listenTo(e3, "cut", (t4, e4) => this._onCopyCut(t4, e4)), this.listenTo(t3.model, "insertContent", (t4, e4) => this._onInsertContent(t4, ...e4), { priority: "high" }), this.decorate("_replaceTableSlotCell");
            }
            _onCopyCut(t3, e3) {
              const n2 = this.editor.plugins.get(XC);
              if (!n2.getSelectedTableCells())
                return;
              if ("cut" == t3.name && this.editor.isReadOnly)
                return;
              e3.preventDefault(), t3.stop();
              const o2 = this.editor.data, i2 = this.editor.editing.view.document, r2 = o2.toView(n2.getSelectionAsFragment());
              i2.fire("clipboardOutput", { dataTransfer: e3.dataTransfer, content: r2, method: t3.name });
            }
            _onInsertContent(t3, e3, n2) {
              if (n2 && !n2.is("documentSelection"))
                return;
              const o2 = this.editor.model, i2 = this.editor.plugins.get(CC);
              let r2 = eA(e3, o2);
              if (!r2)
                return;
              const s2 = i2.getSelectionAffectedTableCells(o2.document.selection);
              s2.length ? (t3.stop(), o2.change((t4) => {
                const e4 = { width: i2.getColumns(r2), height: i2.getRows(r2) }, n3 = function(t5, e5, n4, o4) {
                  const i3 = t5[0].findAncestor("table"), r3 = o4.getColumnIndexes(t5), s3 = o4.getRowIndexes(t5), a3 = { firstColumn: r3.first, lastColumn: r3.last, firstRow: s3.first, lastRow: s3.last }, c3 = 1 === t5.length;
                  c3 && (a3.lastRow += e5.height - 1, a3.lastColumn += e5.width - 1, function(t6, e6, n5, o5) {
                    const i4 = o5.getColumns(t6), r4 = o5.getRows(t6);
                    n5 > i4 && o5.insertColumns(t6, { at: i4, columns: n5 - i4 });
                    e6 > r4 && o5.insertRows(t6, { at: r4, rows: e6 - r4 });
                  }(i3, a3.lastRow + 1, a3.lastColumn + 1, o4));
                  c3 || !o4.isSelectionRectangular(t5) ? function(t6, e6, n5) {
                    const { firstRow: o5, lastRow: i4, firstColumn: r4, lastColumn: s4 } = e6, a4 = { first: o5, last: i4 }, c4 = { first: r4, last: s4 };
                    oA(t6, r4, a4, n5), oA(t6, s4 + 1, a4, n5), nA(t6, o5, c4, n5), nA(t6, i4 + 1, c4, n5, o5);
                  }(i3, a3, n4) : (a3.lastRow = uC(i3, a3), a3.lastColumn = gC(i3, a3));
                  return a3;
                }(s2, e4, t4, i2), o3 = n3.lastRow - n3.firstRow + 1, a2 = n3.lastColumn - n3.firstColumn + 1, c2 = { startRow: 0, startColumn: 0, endRow: Math.min(o3, e4.height) - 1, endColumn: Math.min(a2, e4.width) - 1 };
                r2 = oC(r2, c2, t4);
                const l2 = s2[0].findAncestor("table"), d2 = this._replaceSelectedCellsWithPasted(r2, e4, l2, n3, t4);
                if (this.editor.plugins.get("TableSelection").isEnabled) {
                  const e5 = i2.sortRanges(d2.map((e6) => t4.createRangeOn(e6)));
                  t4.setSelection(e5);
                } else
                  t4.setSelection(d2[0], 0);
              })) : hC(r2, i2);
            }
            _replaceSelectedCellsWithPasted(t3, e3, n2, o2, i2) {
              const { width: r2, height: s2 } = e3, a2 = function(t4, e4, n3) {
                const o3 = new Array(n3).fill(null).map(() => new Array(e4).fill(null));
                for (const { column: e5, row: n4, cell: i3 } of new Yw(t4))
                  o3[n4][e5] = i3;
                return o3;
              }(t3, r2, s2), c2 = [...new Yw(n2, { startRow: o2.firstRow, endRow: o2.lastRow, startColumn: o2.firstColumn, endColumn: o2.lastColumn, includeAllSlots: true })], l2 = [];
              let d2;
              for (const t4 of c2) {
                const { row: e4, column: n3 } = t4;
                n3 === o2.firstColumn && (d2 = t4.getPositionBefore());
                const c3 = e4 - o2.firstRow, h3 = n3 - o2.firstColumn, u3 = a2[c3 % s2][h3 % r2], g3 = u3 ? i2.cloneElement(u3) : null, m3 = this._replaceTableSlotCell(t4, g3, d2, i2);
                m3 && (cC(m3, e4, n3, o2.lastRow, o2.lastColumn, i2), l2.push(m3), d2 = i2.createPositionAfter(m3));
              }
              const h2 = parseInt(n2.getAttribute("headingRows") || 0), u2 = parseInt(n2.getAttribute("headingColumns") || 0), g2 = o2.firstRow < h2 && h2 <= o2.lastRow, m2 = o2.firstColumn < u2 && u2 <= o2.lastColumn;
              if (g2) {
                const t4 = nA(n2, h2, { first: o2.firstColumn, last: o2.lastColumn }, i2, o2.firstRow);
                l2.push(...t4);
              }
              if (m2) {
                const t4 = oA(n2, u2, { first: o2.firstRow, last: o2.lastRow }, i2);
                l2.push(...t4);
              }
              return l2;
            }
            _replaceTableSlotCell(t3, e3, n2, o2) {
              const { cell: i2, isAnchor: r2 } = t3;
              return r2 && o2.remove(i2), e3 ? (o2.insert(e3, n2), e3) : null;
            }
            getTableIfOnlyTableInContent(t3, e3) {
              return eA(t3, e3);
            }
          }
          function eA(t3, e3) {
            if (!t3.is("documentFragment") && !t3.is("element"))
              return null;
            if (t3.is("element", "table"))
              return t3;
            if (1 == t3.childCount && t3.getChild(0).is("element", "table"))
              return t3.getChild(0);
            const n2 = e3.createRangeIn(t3);
            for (const t4 of n2.getItems())
              if (t4.is("element", "table")) {
                const o2 = e3.createRange(n2.start, e3.createPositionBefore(t4));
                if (e3.hasContent(o2, { ignoreWhitespaces: true }))
                  return null;
                const i2 = e3.createRange(e3.createPositionAfter(t4), n2.end);
                return e3.hasContent(i2, { ignoreWhitespaces: true }) ? null : t4;
              }
            return null;
          }
          function nA(t3, e3, n2, o2, i2 = 0) {
            if (e3 < 1)
              return;
            return iC(t3, e3, i2).filter(({ column: t4, cellWidth: e4 }) => iA(t4, e4, n2)).map(({ cell: t4 }) => rC(t4, e3, o2));
          }
          function oA(t3, e3, n2, o2) {
            if (e3 < 1)
              return;
            return sC(t3, e3).filter(({ row: t4, cellHeight: e4 }) => iA(t4, e4, n2)).map(({ cell: t4, column: n3 }) => aC(t4, n3, e3, o2));
          }
          function iA(t3, e3, n2) {
            const o2 = t3 + e3 - 1, { first: i2, last: r2 } = n2;
            return t3 >= i2 && t3 <= r2 || t3 < i2 && o2 >= i2;
          }
          class rA extends ue {
            static get pluginName() {
              return "TableKeyboard";
            }
            static get requires() {
              return [XC, CC];
            }
            init() {
              const t3 = this.editor.editing.view.document;
              this.editor.keystrokes.set("Tab", (...t4) => this._handleTabOnSelectedTable(...t4), { priority: "low" }), this.editor.keystrokes.set("Tab", this._getTabHandler(true), { priority: "low" }), this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(false), { priority: "low" }), this.listenTo(t3, "arrowKey", (...t4) => this._onArrowKey(...t4), { context: "table" });
            }
            _handleTabOnSelectedTable(t3, e3) {
              const n2 = this.editor, o2 = n2.model.document.selection.getSelectedElement();
              o2 && o2.is("element", "table") && (e3(), n2.model.change((t4) => {
                t4.setSelection(t4.createRangeIn(o2.getChild(0).getChild(0)));
              }));
            }
            _getTabHandler(t3) {
              const e3 = this.editor, n2 = this.editor.plugins.get(CC);
              return (o2, i2) => {
                const r2 = e3.model.document.selection;
                let s2 = n2.getTableCellsContainingSelection(r2)[0];
                if (s2 || (s2 = this.editor.plugins.get("TableSelection").getFocusCell()), !s2)
                  return;
                i2();
                const a2 = s2.parent, c2 = a2.parent, l2 = c2.getChildIndex(a2), d2 = a2.getChildIndex(s2), h2 = 0 === d2;
                if (!t3 && h2 && 0 === l2)
                  return void e3.model.change((t4) => {
                    t4.setSelection(t4.createRangeOn(c2));
                  });
                const u2 = d2 === a2.childCount - 1, g2 = l2 === n2.getRows(c2) - 1;
                if (t3 && g2 && u2 && (e3.execute("insertTableRowBelow"), l2 === n2.getRows(c2) - 1))
                  return void e3.model.change((t4) => {
                    t4.setSelection(t4.createRangeOn(c2));
                  });
                let m2;
                if (t3 && u2) {
                  const t4 = c2.getChild(l2 + 1);
                  m2 = t4.getChild(0);
                } else if (!t3 && h2) {
                  const t4 = c2.getChild(l2 - 1);
                  m2 = t4.getChild(t4.childCount - 1);
                } else
                  m2 = a2.getChild(d2 + (t3 ? 1 : -1));
                e3.model.change((t4) => {
                  t4.setSelection(t4.createRangeIn(m2));
                });
              };
            }
            _onArrowKey(t3, e3) {
              const n2 = this.editor, o2 = pr(e3.keyCode, n2.locale.contentLanguageDirection);
              this._handleArrowKeys(o2, e3.shiftKey) && (e3.preventDefault(), e3.stopPropagation(), t3.stop());
            }
            _handleArrowKeys(t3, e3) {
              const n2 = this.editor.plugins.get(CC), o2 = this.editor.model, i2 = o2.document.selection, r2 = ["right", "down"].includes(t3), s2 = n2.getSelectedTableCells(i2);
              if (s2.length) {
                let n3;
                return n3 = e3 ? this.editor.plugins.get("TableSelection").getFocusCell() : r2 ? s2[s2.length - 1] : s2[0], this._navigateFromCellInDirection(n3, t3, e3), true;
              }
              const a2 = i2.focus.findAncestor("tableCell");
              if (!a2)
                return false;
              if (!i2.isCollapsed)
                if (e3) {
                  if (i2.isBackward == r2 && !i2.containsEntireContent(a2))
                    return false;
                } else {
                  const t4 = i2.getSelectedElement();
                  if (!t4 || !o2.schema.isObject(t4))
                    return false;
                }
              return !!this._isSelectionAtCellEdge(i2, a2, r2) && (this._navigateFromCellInDirection(a2, t3, e3), true);
            }
            _isSelectionAtCellEdge(t3, e3, n2) {
              const o2 = this.editor.model, i2 = this.editor.model.schema, r2 = n2 ? t3.getLastPosition() : t3.getFirstPosition();
              if (!i2.getLimitElement(r2).is("element", "tableCell")) {
                return o2.createPositionAt(e3, n2 ? "end" : 0).isTouching(r2);
              }
              const s2 = o2.createSelection(r2);
              return o2.modifySelection(s2, { direction: n2 ? "forward" : "backward" }), r2.isEqual(s2.focus);
            }
            _navigateFromCellInDirection(t3, e3, n2 = false) {
              const o2 = this.editor.model, i2 = t3.findAncestor("table"), r2 = [...new Yw(i2, { includeAllSlots: true })], { row: s2, column: a2 } = r2[r2.length - 1], c2 = r2.find(({ cell: e4 }) => e4 == t3);
              let { row: l2, column: d2 } = c2;
              switch (e3) {
                case "left":
                  d2--;
                  break;
                case "up":
                  l2--;
                  break;
                case "right":
                  d2 += c2.cellWidth;
                  break;
                case "down":
                  l2 += c2.cellHeight;
              }
              if (l2 < 0 || l2 > s2 || d2 < 0 && l2 <= 0 || d2 > a2 && l2 >= s2)
                return void o2.change((t4) => {
                  t4.setSelection(t4.createRangeOn(i2));
                });
              d2 < 0 ? (d2 = n2 ? 0 : a2, l2--) : d2 > a2 && (d2 = n2 ? a2 : 0, l2++);
              const h2 = r2.find((t4) => t4.row == l2 && t4.column == d2).cell, u2 = ["right", "down"].includes(e3), g2 = this.editor.plugins.get("TableSelection");
              if (n2 && g2.isEnabled) {
                const e4 = g2.getAnchorCell() || t3;
                g2.setCellSelection(e4, h2);
              } else {
                const t4 = o2.createPositionAt(h2, u2 ? 0 : "end");
                o2.change((e4) => {
                  e4.setSelection(t4);
                });
              }
            }
          }
          class sA extends Gs {
            constructor(t3) {
              super(t3), this.domEventType = ["mousemove", "mouseleave"];
            }
            onDomEvent(t3) {
              this.fire(t3.type, t3);
            }
          }
          class aA extends ue {
            static get pluginName() {
              return "TableMouse";
            }
            static get requires() {
              return [XC, CC];
            }
            init() {
              this.editor.editing.view.addObserver(sA), this._enableShiftClickSelection(), this._enableMouseDragSelection();
            }
            _enableShiftClickSelection() {
              const t3 = this.editor, e3 = t3.plugins.get(CC);
              let n2 = false;
              const o2 = t3.plugins.get(XC);
              this.listenTo(t3.editing.view.document, "mousedown", (i2, r2) => {
                const s2 = t3.model.document.selection;
                if (!this.isEnabled || !o2.isEnabled)
                  return;
                if (!r2.domEvent.shiftKey)
                  return;
                const a2 = o2.getAnchorCell() || e3.getTableCellsContainingSelection(s2)[0];
                if (!a2)
                  return;
                const c2 = this._getModelTableCellFromDomEvent(r2);
                c2 && cA(a2, c2) && (n2 = true, o2.setCellSelection(a2, c2), r2.preventDefault());
              }), this.listenTo(t3.editing.view.document, "mouseup", () => {
                n2 = false;
              }), this.listenTo(t3.editing.view.document, "selectionChange", (t4) => {
                n2 && t4.stop();
              }, { priority: "highest" });
            }
            _enableMouseDragSelection() {
              const t3 = this.editor;
              let e3, n2, o2 = false, i2 = false;
              const r2 = t3.plugins.get(XC);
              this.listenTo(t3.editing.view.document, "mousedown", (t4, n3) => {
                this.isEnabled && r2.isEnabled && (n3.domEvent.shiftKey || n3.domEvent.ctrlKey || n3.domEvent.altKey || (e3 = this._getModelTableCellFromDomEvent(n3)));
              }), this.listenTo(t3.editing.view.document, "mousemove", (t4, s2) => {
                if (!s2.domEvent.buttons)
                  return;
                if (!e3)
                  return;
                const a2 = this._getModelTableCellFromDomEvent(s2);
                a2 && cA(e3, a2) && (n2 = a2, o2 || n2 == e3 || (o2 = true)), o2 && (i2 = true, r2.setCellSelection(e3, n2), s2.preventDefault());
              }), this.listenTo(t3.editing.view.document, "mouseup", () => {
                o2 = false, i2 = false, e3 = null, n2 = null;
              }), this.listenTo(t3.editing.view.document, "selectionChange", (t4) => {
                i2 && t4.stop();
              }, { priority: "highest" });
            }
            _getModelTableCellFromDomEvent(t3) {
              const e3 = t3.target, n2 = this.editor.editing.view.createPositionAt(e3, 0);
              return this.editor.editing.mapper.toModelPosition(n2).parent.findAncestor("tableCell", { includeSelf: true });
            }
          }
          function cA(t3, e3) {
            return t3.parent.parent == e3.parent.parent;
          }
          var lA = n(6306), dA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
          Zr()(lA.Z, dA);
          lA.Z.locals;
          function hA(t3) {
            const e3 = t3.getSelectedElement();
            return e3 && gA(e3) ? e3 : null;
          }
          function uA(t3) {
            let e3 = t3.getFirstPosition().parent;
            for (; e3; ) {
              if (e3.is("element") && gA(e3))
                return e3;
              e3 = e3.parent;
            }
            return null;
          }
          function gA(t3) {
            return !!t3.getCustomProperty("table") && jg(t3);
          }
          const mA = { autoRefresh: true }, pA = 36e5;
          class fA {
            constructor(t3, e3 = mA) {
              if (!t3)
                throw new a("token-missing-token-url", this);
              e3.initValue && this._validateTokenValue(e3.initValue), this.set("value", e3.initValue), this._refresh = "function" == typeof t3 ? t3 : () => {
                return e4 = t3, new Promise((t4, n2) => {
                  const o2 = new XMLHttpRequest();
                  o2.open("GET", e4), o2.addEventListener("load", () => {
                    const e5 = o2.status, i2 = o2.response;
                    return e5 < 200 || e5 > 299 ? n2(new a("token-cannot-download-new-token", null)) : t4(i2);
                  }), o2.addEventListener("error", () => n2(new Error("Network Error"))), o2.addEventListener("abort", () => n2(new Error("Abort"))), o2.send();
                });
                var e4;
              }, this._options = Object.assign({}, mA, e3);
            }
            init() {
              return new Promise((t3, e3) => {
                this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), t3(this)) : this.refreshToken().then(t3).catch(e3);
              });
            }
            refreshToken() {
              return this._refresh().then((t3) => {
                this._validateTokenValue(t3), this.set("value", t3), this._options.autoRefresh && this._registerRefreshTokenTimeout();
              }).then(() => this);
            }
            destroy() {
              clearTimeout(this._tokenRefreshTimeout);
            }
            _validateTokenValue(t3) {
              const e3 = "string" == typeof t3, n2 = !/^".*"$/.test(t3), o2 = e3 && 3 === t3.split(".").length;
              if (!n2 || !o2)
                throw new a("token-not-in-jwt-format", this);
            }
            _registerRefreshTokenTimeout() {
              const t3 = this._getTokenRefreshTimeoutTime();
              clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
                this.refreshToken();
              }, t3);
            }
            _getTokenRefreshTimeoutTime() {
              try {
                const [, t3] = this.value.split("."), { exp: e3 } = JSON.parse(atob(t3));
                if (!e3)
                  return pA;
                return Math.floor((1e3 * e3 - Date.now()) / 2);
              } catch (t3) {
                return pA;
              }
            }
            static create(t3, e3 = mA) {
              return new fA(t3, e3).init();
            }
          }
          he(fA, re);
          const kA = fA, bA = /^data:(\S*?);base64,/;
          class wA {
            constructor(t3, e3, n2) {
              if (!t3)
                throw new a("fileuploader-missing-file", null);
              if (!e3)
                throw new a("fileuploader-missing-token", null);
              if (!n2)
                throw new a("fileuploader-missing-api-address", null);
              this.file = function(t4) {
                if ("string" != typeof t4)
                  return false;
                const e4 = t4.match(bA);
                return !(!e4 || !e4.length);
              }(t3) ? function(t4, e4 = 512) {
                try {
                  const n3 = t4.match(bA)[1], o2 = atob(t4.replace(bA, "")), i2 = [];
                  for (let t5 = 0; t5 < o2.length; t5 += e4) {
                    const n4 = o2.slice(t5, t5 + e4), r2 = new Array(n4.length);
                    for (let t6 = 0; t6 < n4.length; t6++)
                      r2[t6] = n4.charCodeAt(t6);
                    i2.push(new Uint8Array(r2));
                  }
                  return new Blob(i2, { type: n3 });
                } catch (t5) {
                  throw new a("fileuploader-decoding-image-data-error", null);
                }
              }(t3) : t3, this._token = e3, this._apiAddress = n2;
            }
            onProgress(t3) {
              return this.on("progress", (e3, n2) => t3(n2)), this;
            }
            onError(t3) {
              return this.once("error", (e3, n2) => t3(n2)), this;
            }
            abort() {
              this.xhr.abort();
            }
            send() {
              return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
            }
            _prepareRequest() {
              const t3 = new XMLHttpRequest();
              t3.open("POST", this._apiAddress), t3.setRequestHeader("Authorization", this._token.value), t3.responseType = "json", this.xhr = t3;
            }
            _attachXHRListeners() {
              const t3 = this, e3 = this.xhr;
              function n2(e4) {
                return () => t3.fire("error", e4);
              }
              e3.addEventListener("error", n2("Network Error")), e3.addEventListener("abort", n2("Abort")), e3.upload && e3.upload.addEventListener("progress", (t4) => {
                t4.lengthComputable && this.fire("progress", { total: t4.total, uploaded: t4.loaded });
              }), e3.addEventListener("load", () => {
                const t4 = e3.status, n3 = e3.response;
                if (t4 < 200 || t4 > 299)
                  return this.fire("error", n3.message || n3.error);
              });
            }
            _sendRequest() {
              const t3 = new FormData(), e3 = this.xhr;
              return t3.append("file", this.file), new Promise((n2, o2) => {
                e3.addEventListener("load", () => {
                  const t4 = e3.status, i2 = e3.response;
                  return t4 < 200 || t4 > 299 ? i2.message ? o2(new a("fileuploader-uploading-data-failed", this, { message: i2.message })) : o2(i2.error) : n2(i2);
                }), e3.addEventListener("error", () => o2(new Error("Network Error"))), e3.addEventListener("abort", () => o2(new Error("Abort"))), e3.send(t3);
              });
            }
          }
          he(wA, f);
          class CA {
            constructor(t3, e3) {
              if (!t3)
                throw new a("uploadgateway-missing-token", null);
              if (!e3)
                throw new a("uploadgateway-missing-api-address", null);
              this._token = t3, this._apiAddress = e3;
            }
            upload(t3) {
              return new wA(t3, this._token, this._apiAddress);
            }
          }
          class AA extends Lo {
            static get pluginName() {
              return "CloudServicesCore";
            }
            createToken(t3, e3) {
              return new kA(t3, e3);
            }
            createUploadGateway(t3, e3) {
              return new CA(t3, e3);
            }
          }
          class _A extends pg {
          }
          _A.builtinPlugins = [class extends ue {
            static get requires() {
              return [Am, xg, Tm, xm, Om, up];
            }
            static get pluginName() {
              return "Essentials";
            }
          }, class extends ue {
            static get requires() {
              return [mp];
            }
            static get pluginName() {
              return "CKFinderUploadAdapter";
            }
            init() {
              const t3 = this.editor.config.get("ckfinder.uploadUrl");
              t3 && (this.editor.plugins.get(mp).createUploadAdapter = (e3) => new Ap(e3, t3, this.editor.t));
            }
          }, class extends ue {
            static get requires() {
              return [Ng];
            }
            static get pluginName() {
              return "Autoformat";
            }
            afterInit() {
              this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats();
            }
            _addListAutoformats() {
              const t3 = this.editor.commands;
              t3.get("bulletedList") && _p(this.editor, this, /^[*-]\s$/, "bulletedList"), t3.get("numberedList") && _p(this.editor, this, /^1[.|)]\s$/, "numberedList"), t3.get("todoList") && _p(this.editor, this, /^\[\s?\]\s$/, "todoList"), t3.get("checkTodoList") && _p(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
                this.editor.execute("todoList"), this.editor.execute("checkTodoList");
              });
            }
            _addBasicStylesAutoformats() {
              const t3 = this.editor.commands;
              if (t3.get("bold")) {
                const t4 = xp(this.editor, "bold");
                vp(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t4), vp(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t4);
              }
              if (t3.get("italic")) {
                const t4 = xp(this.editor, "italic");
                vp(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t4), vp(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t4);
              }
              if (t3.get("code")) {
                const t4 = xp(this.editor, "code");
                vp(this.editor, this, /(`)([^`]+)(`)$/g, t4);
              }
              if (t3.get("strikethrough")) {
                const t4 = xp(this.editor, "strikethrough");
                vp(this.editor, this, /(~~)([^~]+)(~~)$/g, t4);
              }
            }
            _addHeadingAutoformats() {
              const t3 = this.editor.commands.get("heading");
              t3 && t3.modelElements.filter((t4) => t4.match(/^heading[1-6]$/)).forEach((e3) => {
                const n2 = e3[7], o2 = new RegExp(`^(#{${n2}})\\s$`);
                _p(this.editor, this, o2, () => {
                  if (!t3.isEnabled || t3.value === e3)
                    return false;
                  this.editor.execute("heading", { value: e3 });
                });
              });
            }
            _addBlockQuoteAutoformats() {
              this.editor.commands.get("blockQuote") && _p(this.editor, this, /^>\s$/, "blockQuote");
            }
            _addCodeBlockAutoformats() {
              const t3 = this.editor, e3 = t3.model.document.selection;
              t3.commands.get("codeBlock") && _p(t3, this, /^```$/, () => {
                if (e3.getFirstPosition().parent.is("element", "listItem"))
                  return false;
                this.editor.execute("codeBlock", { usePreviousLanguageChoice: true });
              });
            }
            _addHorizontalLineAutoformats() {
              this.editor.commands.get("horizontalLine") && _p(this.editor, this, /^---$/, "horizontalLine");
            }
          }, class extends ue {
            static get requires() {
              return [Ip, Sp];
            }
            static get pluginName() {
              return "Bold";
            }
          }, class extends ue {
            static get requires() {
              return [Np, zp];
            }
            static get pluginName() {
              return "Italic";
            }
          }, class extends ue {
            static get requires() {
              return [jp, Up];
            }
            static get pluginName() {
              return "BlockQuote";
            }
          }, class extends ue {
            static get pluginName() {
              return "CKFinder";
            }
            static get requires() {
              return ["Link", "CKFinderUploadAdapter", Gp, Hp];
            }
          }, class extends Lo {
            static get pluginName() {
              return "CloudServices";
            }
            static get requires() {
              return [AA];
            }
            init() {
              const t3 = this.context.config.get("cloudServices") || {};
              for (const e3 in t3)
                this[e3] = t3[e3];
              if (this._tokens = /* @__PURE__ */ new Map(), this.tokenUrl)
                return this.token = this.context.plugins.get("CloudServicesCore").createToken(this.tokenUrl), this._tokens.set(this.tokenUrl, this.token), this.token.init();
              this.token = null;
            }
            registerTokenUrl(t3) {
              if (this._tokens.has(t3))
                return Promise.resolve(this.getTokenFor(t3));
              const e3 = this.context.plugins.get("CloudServicesCore").createToken(t3);
              return this._tokens.set(t3, e3), e3.init();
            }
            getTokenFor(t3) {
              const e3 = this._tokens.get(t3);
              if (!e3)
                throw new a("cloudservices-token-not-registered", this);
              return e3;
            }
            destroy() {
              super.destroy();
              for (const t3 of this._tokens.values())
                t3.destroy();
            }
          }, class extends ue {
            static get requires() {
              return [Yp, "ImageUpload"];
            }
            init() {
              const t3 = this.editor;
              t3.plugins.has("ImageBlockEditing") || t3.plugins.has("ImageInlineEditing") || c("easy-image-image-feature-missing", t3);
            }
            static get pluginName() {
              return "EasyImage";
            }
          }, class extends ue {
            static get requires() {
              return [nf, sf];
            }
            static get pluginName() {
              return "Heading";
            }
          }, class extends ue {
            static get requires() {
              return [Ff, Uf];
            }
            static get pluginName() {
              return "Image";
            }
          }, class extends ue {
            static get requires() {
              return [Wf, Gf];
            }
            static get pluginName() {
              return "ImageCaption";
            }
          }, class extends ue {
            static get requires() {
              return [lk, uk];
            }
            static get pluginName() {
              return "ImageStyle";
            }
          }, class extends ue {
            static get requires() {
              return [af, Cf];
            }
            static get pluginName() {
              return "ImageToolbar";
            }
            afterInit() {
              const t3 = this.editor, e3 = t3.t, n2 = t3.plugins.get(af), o2 = t3.plugins.get("ImageUtils");
              var i2;
              n2.register("image", { ariaLabel: e3("Image toolbar"), items: (i2 = t3.config.get("image.toolbar") || [], i2.map((t4) => y(t4) ? t4.name : t4)), getRelatedElement: (t4) => o2.getClosestSelectedImageWidget(t4) });
            }
          }, class extends ue {
            static get pluginName() {
              return "ImageUpload";
            }
            static get requires() {
              return [Bk, wk, Ek];
            }
          }, class extends ue {
            static get pluginName() {
              return "Indent";
            }
            static get requires() {
              return [Pk, Rk];
            }
          }, class extends ue {
            static get requires() {
              return [Ab, Nb, Pb];
            }
            static get pluginName() {
              return "Link";
            }
          }, class extends ue {
            static get requires() {
              return [aw, lw];
            }
            static get pluginName() {
              return "List";
            }
          }, class extends ue {
            static get requires() {
              return [ww, xw, Aw, dm];
            }
            static get pluginName() {
              return "MediaEmbed";
            }
          }, Jp, class extends ue {
            static get pluginName() {
              return "PasteFromOffice";
            }
            static get requires() {
              return [Cg];
            }
            init() {
              const t3 = this.editor, e3 = t3.editing.view.document, n2 = [];
              n2.push(new Rw(e3)), n2.push(new Bw(e3)), t3.plugins.get("ClipboardPipeline").on("inputTransformation", (t4, o2) => {
                if (o2._isTransformedWithPasteFromOffice)
                  return;
                const i2 = o2.dataTransfer.getData("text/html"), r2 = n2.find((t5) => t5.isActive(i2));
                r2 && (o2._parsedData = Fw(i2, e3.stylesProcessor), r2.execute(o2), o2._isTransformedWithPasteFromOffice = true);
              }, { priority: "high" });
            }
          }, class extends ue {
            static get requires() {
              return [HC, KC, XC, aA, rA, tA, dm];
            }
            static get pluginName() {
              return "Table";
            }
          }, class extends ue {
            static get requires() {
              return [af];
            }
            static get pluginName() {
              return "TableToolbar";
            }
            afterInit() {
              const t3 = this.editor, e3 = t3.t, n2 = t3.plugins.get(af), o2 = t3.config.get("table.contentToolbar"), i2 = t3.config.get("table.tableToolbar");
              o2 && n2.register("tableContent", { ariaLabel: e3("Table toolbar"), items: o2, getRelatedElement: uA }), i2 && n2.register("table", { ariaLabel: e3("Table toolbar"), items: i2, getRelatedElement: hA });
            }
          }, class extends ue {
            static get requires() {
              return ["Delete", "Input"];
            }
            static get pluginName() {
              return "TextTransformation";
            }
            constructor(t3) {
              super(t3), t3.config.define("typing", { transformations: { include: $m } });
            }
            init() {
              const t3 = this.editor.model.document.selection;
              t3.on("change:range", () => {
                this.isEnabled = !t3.anchor.parent.is("element", "codeBlock");
              }), this._enableTransformationWatchers();
            }
            _enableTransformationWatchers() {
              const t3 = this.editor, e3 = t3.model, n2 = t3.plugins.get("Delete"), o2 = function(t4) {
                const e4 = t4.extra || [], n3 = t4.remove || [], o3 = (t5) => !n3.includes(t5);
                return function(t5) {
                  const e5 = /* @__PURE__ */ new Set();
                  for (const n4 of t5)
                    if (Km[n4])
                      for (const t6 of Km[n4])
                        e5.add(t6);
                    else
                      e5.add(n4);
                  return Array.from(e5);
                }(t4.include.concat(e4).filter(o3)).filter(o3).map((t5) => Qm[t5] || t5).filter((t5) => "object" == typeof t5).map((t5) => ({ from: Zm(t5.from), to: Jm(t5.to) }));
              }(t3.config.get("typing.transformations")), i2 = new jm(t3.model, (t4) => {
                for (const e4 of o2) {
                  if (e4.from.test(t4))
                    return { normalizedTransformation: e4 };
                }
              });
              i2.on("matched:data", (t4, o3) => {
                if (!o3.batch.isTyping)
                  return;
                const { from: i3, to: r2 } = o3.normalizedTransformation, s2 = i3.exec(o3.text), a2 = r2(s2.slice(1)), c2 = o3.range;
                let l2 = s2.index;
                e3.enqueueChange((t5) => {
                  for (let n3 = 1; n3 < s2.length; n3++) {
                    const o4 = s2[n3], i4 = a2[n3 - 1];
                    if (null == i4) {
                      l2 += o4.length;
                      continue;
                    }
                    const r3 = c2.start.getShiftedBy(l2), d2 = e3.createRange(r3, r3.getShiftedBy(o4.length)), h2 = Xm(r3);
                    e3.insertContent(t5.createText(i4, h2), d2), l2 += i4.length;
                  }
                  e3.enqueueChange(() => {
                    n2.requestUndoOnBackspace();
                  });
                });
              }), i2.bind("isEnabled").to(this);
            }
          }], _A.defaultConfig = { toolbar: { items: ["heading", "|", "bold", "italic", "link", "bulletedList", "numberedList", "|", "outdent", "indent", "|", "uploadImage", "blockQuote", "insertTable", "mediaEmbed", "undo", "redo"] }, image: { toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "toggleImageCaption", "imageTextAlternative"] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, language: "en" };
        })(), o = o.default;
      })();
    });
  }
});

// dep:@ckeditor_ckeditor5-build-classic
var ckeditor_ckeditor5_build_classic_default = require_ckeditor();
export {
  ckeditor_ckeditor5_build_classic_default as default
};
//# sourceMappingURL=@ckeditor_ckeditor5-build-classic.js.map
